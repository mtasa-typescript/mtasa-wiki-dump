from src.fetch.function import CompoundFunctionData, FunctionData, FunctionArgument, ListType, FunctionUrl, \
 FunctionType, FunctionDoc, FunctionOOP

CompoundFunctionData(server=FunctionData(signature=FunctionType(name='addAccount', return_types=['account'], arguments=[FunctionArgument(name='name', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pass', argument_type='string', default_value=None, optional=False), FunctionArgument(name='allowCaseVariations', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function adds an account to the list of registered accounts of the current server.', arguments={'name': 'The name of the account you wish to make, this normally is the players name.', 'pass': 'The password to set for this account for future logins.', 'allowCaseVariations': 'Whether the username is case sensitive (if this is set to true, usernames Bob and bob will refer to different accounts)'}, result="Returns an [[account]] or ''false'' if the account already exists or an error occured."), oop=None, url=FunctionUrl(url='/wiki/AddAccount', name='addAccount', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='copyAccountData', return_types=['bool'], arguments=[FunctionArgument(name='theAccount', argument_type='account', default_value=None, optional=False), FunctionArgument(name='fromAccount', argument_type='account', default_value=None, optional=False)]), docs=FunctionDoc(description='This function copies all of the data from one [[account]] to another.', arguments={'theAccount': 'The account you wish to copy the data to.', 'fromAccount': 'The account you wish to copy the data from.'}, result="Returns a ''true'' if the accounts were valid, ''false'' otherwise."), oop=FunctionOOP(class_name='account', method_name='copyDataTo', field=None), url=FunctionUrl(url='/wiki/CopyAccountData', name='copyAccountData', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAccount', return_types=['account'], arguments=[FunctionArgument(name='username', argument_type='string', default_value=None, optional=False), FunctionArgument(name='password', argument_type='string', default_value=None, optional=True), FunctionArgument(name='caseSensitive', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description='This function returns an [[account]] for a specific user. ', arguments={'username': 'The username of the account you want to retrieve\n{{OptionalArg}}', 'password': 'The password for the account. If this argument is not specified, you can get the account whatever password it is, otherwise the password must match the accounts.\n{{New items|3.0157|1.5.6|', 'caseSensitive': ': Specifies whether to ignore the case when searching for an account.\n|16257}}'}, result="Returns an [[account]] or ''false'' if an account matching the username specified (and password, if specified) could not be found."), oop=None, url=FunctionUrl(url='/wiki/GetAccount', name='getAccount', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAccountData', return_types=['string'], arguments=[FunctionArgument(name='theAccount', argument_type='account', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function retrieves a string that has been stored using [[setAccountData]]. Data stored as account data is persistent across user's sessions and maps, unless they are logged into a guest account.", arguments={'theAccount': 'The account you wish to retrieve the data from.', 'key': 'The key under which the data is stored'}, result="Returns a [[string]] containing the stored data or ''false'' if no data was stored under that key."), oop=FunctionOOP(class_name='account', method_name='getData', field=None), url=FunctionUrl(url='/wiki/GetAccountData', name='getAccountData', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAccountName', return_types=['string'], arguments=[FunctionArgument(name='theAccount', argument_type='account', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the name of an [[account]].', arguments={'theAccount': 'The account you wish to get the name of.'}, result="Returns a string containing the account's name, ''false'' if the account does not exist or an invalid argument was passed to the function."), oop=FunctionOOP(class_name='account', method_name='getName', field='name'), url=FunctionUrl(url='/wiki/GetAccountName', name='getAccountName', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAccountPlayer', return_types=['player'], arguments=[FunctionArgument(name='theAccount', argument_type='account', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the [[player]] element that is currently using a specified [[account]], i.e. is logged into it. Only one player can use an account at a time.', arguments={'theAccount': 'The account you wish to get the player of.'}, result="Returns a [[player]] element if the account is currently in use, ''false'' otherwise."), oop=FunctionOOP(class_name='account', method_name='getPlayer', field='player'), url=FunctionUrl(url='/wiki/GetAccountPlayer', name='getAccountPlayer', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAccountSerial', return_types=['string'], arguments=[FunctionArgument(name='theAccount', argument_type='account', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the last [[serial]] that logged onto the specified [[account]].\n}}', arguments={'theAccount': 'The account to get serial from'}, result="Returns ''string'' containing the serial, the string is empty if the account was never used. Returns ''false'' if invalid arguments were specified."), oop=FunctionOOP(class_name='account', method_name='getSerial', field='serial'), url=FunctionUrl(url='/wiki/GetAccountSerial', name='getAccountSerial', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAccounts', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function returns a table over all the [[account]]s that exist in the server internal.db file. (Note: accounts.xml is no longer used after version 1.0.4)', arguments={}, result='A [[table]] over the accounts that exist in the server internal.db file. This table might be empty.'), oop=FunctionOOP(class_name='Account', method_name='getAll', field=None), url=FunctionUrl(url='/wiki/GetAccounts', name='getAccounts', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAccountsBySerial', return_types=['table'], arguments=[FunctionArgument(name='serial', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a [[table]] containing all accounts that were logged onto from specified [[serial]]. If the serial is empty string, it will return all accounts that were never logged onto.\n}}', arguments={'serial': 'The serial to get accounts from'}, result="Returns ''[[table]]'' containing the accounts associated with specified serial. Returns ''false'' if invalid arguments were specified."), oop=None, url=FunctionUrl(url='/wiki/GetAccountsBySerial', name='getAccountsBySerial', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAllAccountData', return_types=['table'], arguments=[FunctionArgument(name='theAccount', argument_type='account', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a table containing all the user data for the [[account]] provided', arguments={'theAccount': 'The account you wish to retrieve all data from.'}, result='A [[table]] containing all the user data. This table might be empty.'), oop=FunctionOOP(class_name='account', method_name='getAllData', field='data'), url=FunctionUrl(url='/wiki/GetAllAccountData', name='getAllAccountData', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerAccount', return_types=['account'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="This function returns the specified player's [[account]] object.", arguments={'thePlayer': 'The player element you want to get the account of.'}, result="Returns the player's account object, or ''false'' if the player passed to the function is invalid."), oop=FunctionOOP(class_name='player', method_name='getAccount', field='account'), url=FunctionUrl(url='/wiki/GetPlayerAccount', name='getPlayerAccount', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isGuestAccount', return_types=['bool'], arguments=[FunctionArgument(name='theAccount', argument_type='account', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks to see if an [[account]] is a guest account. A guest account is an account automatically created for a user when they join the server and deleted when they quit or login to another account. Data stored in a guest account is not stored after the player has left the server. As a consequence, this function will check if a player is logged in or not.', arguments={'theAccount': 'The account you want to check to see if it is a guest account.'}, result="Returns ''true'' if the account is a guest account, ''false'' otherwise."), oop=FunctionOOP(class_name='account', method_name='isGuest', field='guest'), url=FunctionUrl(url='/wiki/IsGuestAccount', name='isGuestAccount', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='logIn', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='theAccount', argument_type='account', default_value=None, optional=False), FunctionArgument(name='thePassword', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This functions logs the given player in to the given [[account]]. You need to provide the password needed to log into that account.', arguments={'thePlayer': 'The player to log into an account', 'theAccount': 'The account to log the player into', 'thePassword': 'The password needed to sign into this account'}, result="Returns ''true'' if the player was successfully logged into the given account. Returns ''false'' or ''nil'' if the log in failed for some reason, ie. the player was already logged in to some account (use [[logOut]] first), if the account was already in use or if it failed for some other reason."), oop=FunctionOOP(class_name='player', method_name='logIn', field=None), url=FunctionUrl(url='/wiki/LogIn', name='logIn', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='logOut', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function logs the given player out of his current [[account]].', arguments={'thePlayer': 'The player to log out of his current account'}, result="Returns ''true'' if the player was successfully logged out, ''false'' or ''nil'' if it failed for some reason, ie. the player was never logged in."), oop=None, url=FunctionUrl(url='/wiki/LogOut', name='logOut', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removeAccount', return_types=['bool'], arguments=[FunctionArgument(name='theAccount', argument_type='account', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to delete existing player [[account]]s.', arguments={'theAccount': 'The account you wish to remove'}, result="Returns ''true'' if account was successfully removed, ''false'' if the account does not exist."), oop=FunctionOOP(class_name='account', method_name='remove', field=None), url=FunctionUrl(url='/wiki/RemoveAccount', name='removeAccount', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setAccountData', return_types=['bool'], arguments=[FunctionArgument(name='theAccount', argument_type='account', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='var', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets a string to be stored in an [[account]]. This can then be retrieved using [[getAccountData]]. Data stored as account data is persistent across user's sessions and maps, unless they are logged into a guest account. Even if logged into a guest account, account data can be useful as a way to store a reference to your own account system, though it's persistence is equivalent to that of using [[setElementData]] on the player's element.", arguments={'theAccount': 'The account you wish to retrieve the data from.', 'key': 'The key under which you wish to store the data', 'value': 'The value you wish to store. Set to false to remove the data. NOTE: you cannot store tables as values, but you can use toJSON strings.'}, result="Returns a ''true'' if the account data was set, ''false'' if an invalid argument was specified."), oop=FunctionOOP(class_name='account', method_name='setData', field=None), url=FunctionUrl(url='/wiki/SetAccountData', name='setAccountData', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setAccountPassword', return_types=['bool'], arguments=[FunctionArgument(name='theAccount', argument_type='account', default_value=None, optional=False), FunctionArgument(name='password', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the password of the specified [[account]].', arguments={'theAccount': 'the account whose password you want to set', 'password': "the password\n{{Note|The password will always be encrypted with '''sha256''', other types are no longer supported. See [https://github.com/multitheftauto/mtasa-blue/wiki/CAccountPassword CAccountPassword] for more information.}}"}, result="Returns ''true'' if the password was set correctly, ''false'' otherwise."), oop=FunctionOOP(class_name='account', method_name='setPassword', field='password'), url=FunctionUrl(url='/wiki/SetAccountPassword', name='setAccountPassword', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAccountByID', return_types=['account'], arguments=[FunctionArgument(name='id', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the account with the specific ID.\n}}', arguments={'id': 'The ID to get account from'}, result="Returns ''[[account]]'' associated with specified ID. Returns ''false'' if invalid arguments were specified or there is no account with this ID."), oop=None, url=FunctionUrl(url='/wiki/GetAccountByID', name='getAccountByID', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAccountID', return_types=['int'], arguments=[FunctionArgument(name='theAccount', argument_type='account', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the ID of an [[account]].\n}}', arguments={'theAccount': 'The account you wish to get the ID of.'}, result="Returns a int containing the account's ID, ''false'' if the account does not exist or an invalid argument was passed to the function."), oop=FunctionOOP(class_name='account', method_name='getID', field='id'), url=FunctionUrl(url='/wiki/GetAccountID', name='getAccountID', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAccountIP', return_types=['string'], arguments=[FunctionArgument(name='theAccount', argument_type='account', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the IP address of an [[account]].\n}}', arguments={'theAccount': 'The account you wish to get the IP of.'}, result="Returns a string containing the account's IP, ''false'' if the account does not exist or an invalid argument was passed to the function."), oop=FunctionOOP(class_name='account', method_name='getIP', field='ip'), url=FunctionUrl(url='/wiki/GetAccountIP', name='getAccountIP', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAccountsByData', return_types=['table'], arguments=[FunctionArgument(name='dataName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a [[table]] containing all accounts with specified dataName and value (set with setAccountData).\n}}', arguments={'dataName': 'The name of the data', 'value': 'The value the dataName should have'}, result="Returns ''[[table]]'' containing the accounts associated with specified value at dataName. Returns ''false'' if invalid arguments were specified."), oop=None, url=FunctionUrl(url='/wiki/GetAccountsByData', name='getAccountsByData', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAccountsByIP', return_types=['table'], arguments=[FunctionArgument(name='ip', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a [[table]] containing all accounts that were logged onto from specified IP-address.\n}}', arguments={'ip': 'The IP to get accounts from'}, result="Returns ''[[table]]'' containing the accounts associated with specified IP-address. Returns ''false'' if invalid arguments were specified."), oop=None, url=FunctionUrl(url='/wiki/GetAccountsByIP', name='getAccountsByIP', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setAccountName', return_types=['bool'], arguments=[FunctionArgument(name='theAccount', argument_type='account', default_value=None, optional=False), FunctionArgument(name='name', argument_type='string', default_value=None, optional=False), FunctionArgument(name='allowCaseVariations', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function sets the name of an [[account]].\n}}', arguments={'theAccount': 'The account you wish to change the name.', 'name': 'The new name.', 'allowCaseVariations': 'Whether the username is case sensitive (if this is set to true, usernames Bob and bob will refer to different accounts)'}, result="Returns a ''true'' if the account name was set, ''false'' if an invalid argument was specified."), oop=FunctionOOP(class_name='account', method_name='setName', field='name'), url=FunctionUrl(url='/wiki/SetAccountName', name='setAccountName', category='Account functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclCreate', return_types=['acl'], arguments=[FunctionArgument(name='aclName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function creates an ACL entry in the Access Control List system with the specified name.', arguments={'aclName': 'The name of the ACL entry to add.'}, result='Returns the created ACL object if successful. Returns false if an ACL of the given name could not be created.'), oop=None, url=FunctionUrl(url='/wiki/AclCreate', name='aclCreate', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclCreateGroup', return_types=['aclgroup'], arguments=[FunctionArgument(name='groupName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function creates a group in the ACL. An ACL group can contain objects like players and resources. They specify who has access to the ACL's in this group.", arguments={'groupName': 'The name of the group to create'}, result='Returns the pointer to the created aclgroup if successful. Returns false if failed.'), oop=None, url=FunctionUrl(url='/wiki/AclCreateGroup', name='aclCreateGroup', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclDestroy', return_types=['bool'], arguments=[FunctionArgument(name='theACL', argument_type='acl', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function destroys the ACL passed. The destroyed ACL will no longer be valid.", arguments={'theACL': 'The ACL to destroy'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if successfully destroyed and ''false'' if it could not be deleted (ie. it's not valid)."), oop=FunctionOOP(class_name='acl', method_name='destroy', field=None), url=FunctionUrl(url='/wiki/AclDestroy', name='aclDestroy', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclDestroyGroup', return_types=['bool'], arguments=[FunctionArgument(name='aclGroup', argument_type='aclgroup', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function destroys the given ACL group. The destroyed ACL group will no longer be valid.", arguments={'aclGroup': 'The aclgroup element to destroy'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the ACL group was successfully deleted, ''false'' if it could not be deleted for some reason (ie. invalid argument)."), oop=FunctionOOP(class_name='aclgroup', method_name='destroy', field=None), url=FunctionUrl(url='/wiki/AclDestroyGroup', name='aclDestroyGroup', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclGet', return_types=['acl'], arguments=[FunctionArgument(name='aclName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="Get the ACL with the given name. If need to get most of the ACL's, you should consider using [[aclList]] to get a table of them all.", arguments={'aclName': 'The name to get the ACL belonging to'}, result="Returns the ACL with that name if it could be retrieved, ''false''/''nil'' if the ACL does not exist or it fails for some other reason."), oop=FunctionOOP(class_name='ACL', method_name='get', field=None), url=FunctionUrl(url='/wiki/AclGet', name='aclGet', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclGetGroup', return_types=['aclgroup'], arguments=[FunctionArgument(name='groupName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function is used to get the ACL group with the given name. If you need most of the groups you should consider using [[aclGroupList]] instead to get a table containing them all.", arguments={'groupName': 'The name to get the ACL group from'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns the ACL group if it could be found. Returns false/nil if it did not exist or failed for some reason."), oop=FunctionOOP(class_name='ACLGroup', method_name='get', field=None), url=FunctionUrl(url='/wiki/AclGetGroup', name='aclGetGroup', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclGetName', return_types=['string'], arguments=[FunctionArgument(name='theAcl', argument_type='acl', default_value=None, optional=False)]), docs=FunctionDoc(description='Get the name of given ACL.', arguments={'theACL': 'The ACL to get the name of'}, result="Returns the name of the given ACL as a string if successful. Returns ''false''/''nil'' if unsuccessful, ie the ACL is invalid."), oop=FunctionOOP(class_name='acl', method_name='getName', field='name'), url=FunctionUrl(url='/wiki/AclGetName', name='aclGetName', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclGetRight', return_types=['bool'], arguments=[FunctionArgument(name='theAcl', argument_type='acl', default_value=None, optional=False), FunctionArgument(name='rightName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function returns whether the access for the given right is set to true or false in the ACL.", arguments={'theAcl': 'The ACL to get the right from', 'rightName': 'The right name to return the access value of.'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' or ''false'' if the ACL gives access or not to the given function. Returns ''nil'' if it failed for some reason, e.g. an invalid ACL was specified or the right specified does not exist in the ACL."), oop=FunctionOOP(class_name='acl', method_name='getRight', field=None), url=FunctionUrl(url='/wiki/AclGetRight', name='aclGetRight', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclGroupAddACL', return_types=['bool'], arguments=[FunctionArgument(name='theGroup', argument_type='aclgroup', default_value=None, optional=False), FunctionArgument(name='theACL', argument_type='acl', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function adds the given ACL to the given ACL group. This makes the resources and players in the given ACL group have access to what's specified in the given ACL. The rights for something in the different ACL's in a group are OR-ed together, which means if one ACL gives access to something, this ACL group will have access to that.", arguments={'theGroup': 'The group to add the ACL to', 'theACL': 'The ACL to add to the group'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the ACL could be successfully added to the ACL group, ''false''/''nil'' if either of the elements are invalid, the ACL is already in that group or if something else goes wrong."), oop=FunctionOOP(class_name='aclgroup', method_name='addACL', field=None), url=FunctionUrl(url='/wiki/AclGroupAddACL', name='aclGroupAddACL', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclGroupAddObject', return_types=['bool'], arguments=[FunctionArgument(name='theGroup', argument_type='aclgroup', default_value=None, optional=False), FunctionArgument(name='theObjectName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function adds an object to the given ACL group. An object can be a player's account, specified as:\n  ''user.<accountname>''\nOr a resource, specified as:\n  ''resource.<resourcename>''\nObjects are specified as strings. The ACL groups work for the user accounts and the resources that are specified in them.", arguments={'theGroup': 'The group to add the object name string too.', 'theObjectName': 'The object string to add to the given ACL.'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the object was successfully added to the ACL, ''false'' if it already existed in the list."), oop=FunctionOOP(class_name='aclgroup', method_name='addObject', field=None), url=FunctionUrl(url='/wiki/AclGroupAddObject', name='aclGroupAddObject', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclGroupGetName', return_types=['string'], arguments=[FunctionArgument(name='aclGroup', argument_type='aclgroup', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function is used to get the name of the given ACL group.", arguments={'aclGroup': 'The ACL group to get the name of'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns the name of the given ACL group as a string if successful, otherwise ''false'' or ''nil'' if the aclGroup is invalid or it fails for some other reason."), oop=FunctionOOP(class_name='aclgroup', method_name='getName', field='name'), url=FunctionUrl(url='/wiki/AclGroupGetName', name='aclGroupGetName', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclGroupList', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function returns a table of all the ACL groups.', arguments={}, result="Returns a table of all the ACL groups if successful, returns an empty table if no ACL groups exist. ''false''/''nil'' can be returned if this function fails for some other reason."), oop=FunctionOOP(class_name='ACLGroup', method_name='list', field=None), url=FunctionUrl(url='/wiki/AclGroupList', name='aclGroupList', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='aclGroupListACL', return_types=['table'], arguments=[FunctionArgument(name='theGroup', argument_type='aclgroup', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function returns a table over all the ACL's that exist in a given ACL group.", arguments={'theGroup': 'The ACL group to get the ACL elements from'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns a table of the ACL elements in the given ACL group. This table might be empty. Returns ''false'' or ''nil'' if theGroup is invalid or it fails for some other reason."), oop=FunctionOOP(class_name='aclgroup', method_name='listACL', field='aclList'), url=FunctionUrl(url='/wiki/AclGroupListACL', name='aclGroupListACL', category='ACL functions', function_type=ListType.SERVER)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclGroupListObjects', return_types=['table'], arguments=[FunctionArgument(name='theGroup', argument_type='aclgroup', default_value=None, optional=False)]), docs=FunctionDoc(description='<!-- Change this to "Client function" or "Server function" appropriately-->\n<!-- Describe in plain english what this function does. Don\'t go into details, just give an overview -->\nThis function returns a table over all the objects that exist in a given ACL group. These are objects like players and resources.', arguments={'theGroup': 'The ACL group to get the objects from'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns a table of strings in the given ACL group. This table might be empty. Returns ''false'' or ''nil'' if theGroup is invalid or it fails for some other reason."), oop=FunctionOOP(class_name='aclgroup', method_name='listObjects', field='objects'), url=FunctionUrl(url='/wiki/AclGroupListObjects', name='aclGroupListObjects', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclGroupRemoveACL', return_types=['bool'], arguments=[FunctionArgument(name='theGroup', argument_type='aclgroup', default_value=None, optional=False), FunctionArgument(name='theACL', argument_type='acl', default_value=None, optional=False)]), docs=FunctionDoc(description='This function removes the given ACL from the given ACL group.', arguments={'theGroup': 'The group to remove the given ACL from', 'theACL': 'The ACL to remove from the given group'}, result="Returns ''true'' if the ACL was successfully removed from the ACL group, ''false''/''nil'' if it could not be removed for some reason, ie. either of the elements were invalid."), oop=FunctionOOP(class_name='aclgroup', method_name='removeACL', field=None), url=FunctionUrl(url='/wiki/AclGroupRemoveACL', name='aclGroupRemoveACL', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclGroupRemoveObject', return_types=['bool'], arguments=[FunctionArgument(name='theGroup', argument_type='aclgroup', default_value=None, optional=False), FunctionArgument(name='theObjectString', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function removes the given object from the given ACL group. The object can be a resource or a player. See [[aclGroupAddObject]] for more details.", arguments={'theGroup': 'The ACL group to remove the object string from', 'theObjectString': 'The object to remove from the ACL group'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the object existed in the ACL and could be remoevd, ''false'' if it could not be removed for some reason, ie. it did not exist in the given ACL group."), oop=FunctionOOP(class_name='aclgroup', method_name='removeObject', field=None), url=FunctionUrl(url='/wiki/AclGroupRemoveObject', name='aclGroupRemoveObject', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclList', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function returns a list of all the ACLs.', arguments={}, result="Returns a table of all the ACLs. This table can be empty if no ACLs exist. It can also return ''false''/''nil'' if it failed for some reason."), oop=FunctionOOP(class_name='ACL', method_name='list', field=None), url=FunctionUrl(url='/wiki/AclList', name='aclList', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclListRights', return_types=['table'], arguments=[FunctionArgument(name='theACL', argument_type='acl', default_value=None, optional=False), FunctionArgument(name='allowedType', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a table of all the rights that a given ACL has.', arguments={'theACL': 'The ACL to get the rights from', 'allowedType': 'The allowed right type. Possible values are general, function, resource and command'}, result="Returns a table over the rights as strings in the given ACL. This table might be empty. Returns ''false'' or ''nil'' if theACL is invalid or it fails for some other reason."), oop=FunctionOOP(class_name='acl', method_name='listRights', field=None), url=FunctionUrl(url='/wiki/AclListRights', name='aclListRights', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclReload', return_types=['bool'], arguments=[]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function reloads the ACL's and the ACL groups from the ACL XML file. All ACL and ACL group elements are invalid after a call to this and should not be used anymore.", arguments={}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the XML was successfully reloaded from the file, ''false'' or ''nil'' if the XML was invalid, didn't exist or could not be loaded for some other reason."), oop=FunctionOOP(class_name='ACL', method_name='reload', field=None), url=FunctionUrl(url='/wiki/AclReload', name='aclReload', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclRemoveRight', return_types=['bool'], arguments=[FunctionArgument(name='theAcl', argument_type='acl', default_value=None, optional=False), FunctionArgument(name='rightName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function removes the given right (string) from the given ACL.", arguments={'theAcl': 'The ACL to remove the right from', 'rightName': 'The ACL name to remove from the right from'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the given right was successfully removed from the given ACL, ''false'' or ''nil'' if it could not be removed for some reason, ie. it didn't exist in the ACL."), oop=FunctionOOP(class_name='acl', method_name='removeRight', field=None), url=FunctionUrl(url='/wiki/AclRemoveRight', name='aclRemoveRight', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclSave', return_types=['bool'], arguments=[]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThe ACL XML file is automatically saved whenever the ACL is modified, but the automatic save can be delayed by up to 10 seconds for performance reasons. Calling this function will force an immediate save. ", arguments={}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the ACL was successfully changed, ''false'' or ''nil'' if it could not be saved for some reason, ie. file in use."), oop=FunctionOOP(class_name='ACL', method_name='save', field=None), url=FunctionUrl(url='/wiki/AclSave', name='aclSave', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='aclSetRight', return_types=['bool'], arguments=[FunctionArgument(name='theAcl', argument_type='acl', default_value=None, optional=False), FunctionArgument(name='rightName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='hasAccess', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This functions changes or adds the given right in the given ACL. The access can be ''true'' or ''false'' and specifies whether the ACL gives access to the right or not.", arguments={'theAcl': 'The ACL to change the right of', 'rightName': 'The right to add/change the access property of', 'hasAccess': 'Whether the access should be set to true or false'}, result="Returns ''true'' if the access was successfully changed, ''false'' or ''nil'' if it failed for some reason, ie. invalid ACL or the rightname is invalid."), oop=FunctionOOP(class_name='acl', method_name='setRight', field=None), url=FunctionUrl(url='/wiki/AclSetRight', name='aclSetRight', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isObjectInACLGroup', return_types=['bool'], arguments=[FunctionArgument(name='theObject', argument_type='string', default_value=None, optional=False), FunctionArgument(name='theGroup', argument_type='aclgroup', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to determine if an object is in a group.', arguments={'theObject': 'the name of the object to check. Examples: resource.ctf, user.Jim.', 'theGroup': 'the ACL group pointer of the group from which the object should be found.'}, result="Returns ''true'' if the object is in the specified group, ''false'' otherwise."), oop=FunctionOOP(class_name='aclgroup', method_name='doesContainObject', field=None), url=FunctionUrl(url='/wiki/IsObjectInACLGroup', name='isObjectInACLGroup', category='ACL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='addBan', return_types=['ban'], arguments=[FunctionArgument(name='IP', argument_type='string', default_value=None, optional=False), FunctionArgument(name='Username', argument_type='string', default_value=None, optional=False), FunctionArgument(name='Serial', argument_type='string', default_value=None, optional=False), FunctionArgument(name='responsibleElement', argument_type='player', default_value=None, optional=False), FunctionArgument(name='reason', argument_type='string', default_value=None, optional=False), FunctionArgument(name='seconds', argument_type='int', default_value='0', optional=False)]), docs=FunctionDoc(description='This function will add a [[ban]] for the specified IP/username/serial to the server.', arguments={'IP': "The IP to be banned. If you dont want to ban by IP, set this to nil.\n'''or'''", 'Username': "The http://community.mtasa.com/ MTA Community username to be banned (now obsolete). If you dont want to ban by username, set this to nil.\n'''or'''", 'Serial': "The serial to be banned. If you dont want to ban by serial, set this to nil.\n''' or any combination.'''\n{{OptionalArg}} ", 'responsibleElement': 'The element that is responsible for banning the IP/username/serial. This can be a player or the root (getRootElement()).', 'reason': 'The reason the IP/username/serial will be banned from the server.', 'seconds': 'The amount of seconds the player will be banned from the server for. This can be 0 for an infinite amount of time.'}, result="Returns the new [[ban]] if the IP/username/serial was banned successfully, ''false'' if invalid arguments are specified."), oop=None, url=FunctionUrl(url='/wiki/AddBan', name='addBan', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='banPlayer', return_types=['ban'], arguments=[FunctionArgument(name='bannedPlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='IP', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='Username', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='Serial', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='string', argument_type='player', default_value=None, optional=False), FunctionArgument(name='reason', argument_type='string', default_value='nil', optional=False), FunctionArgument(name='seconds', argument_type='int', default_value='0', optional=False)]), docs=FunctionDoc(description='This function will ban the specified player by either IP, [[serial]] or username\n}}\nThis function will ban the specified player from the server by IP.\n}}', arguments={'bannedPlayer': 'The player that will be banned from the server.\n{{OptionalArg}} \n{{New feature|3|1.0|', 'IP': 'Will player be banned by IP?', 'Username': 'Will player be banned by username?', 'Serial': 'Will player be banned by serial?\n}}', 'responsibleElement': 'The element that is responsible for banning the player. This can be a player or the root (getRootElement()) (Maximum 30 characters if using a string).', 'reason': 'The reason the player will be banned from the server.', 'seconds': 'The amount of seconds the player will be banned from the server for. This can be 0 for an infinite amount of time.'}, result="Returns a [[ban]] object if banned successfully, or ''false'' if unsuccessful."), oop=FunctionOOP(class_name='player', method_name='ban', field=None), url=FunctionUrl(url='/wiki/BanPlayer', name='banPlayer', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getBanAdmin', return_types=['string'], arguments=[FunctionArgument(name='theBan', argument_type='ban', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will return the responsible admin (nickname of the admin) of the specified [[ban]].', arguments={'theBan': 'The ban you want to return the admin of.'}, result="Returns a ''string'' of the admin if everything was successful, ''false'' if invalid arguments are specified if there was no admin specified for the [[ban]]."), oop=FunctionOOP(class_name='ban', method_name='getAdmin', field='admin'), url=FunctionUrl(url='/wiki/GetBanAdmin', name='getBanAdmin', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getBanIP', return_types=['string'], arguments=[FunctionArgument(name='theBan', argument_type='ban', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will return the IP of the specified [[ban]].', arguments={'theBan': 'The ban in which you want to return the IP of.'}, result="Returns a ''string'' of the IP if everything was successful, ''false'' if invalid arguments are specified if there was no IP specified for the [[ban]]."), oop=FunctionOOP(class_name='ban', method_name='getIP', field='ip'), url=FunctionUrl(url='/wiki/GetBanIP', name='getBanIP', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getBanNick', return_types=['string'], arguments=[FunctionArgument(name='theBan', argument_type='ban', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will return the nickname (nickname that the player had when he was banned) of the specified [[ban]].', arguments={'theBan': 'The ban element which nickname you want to return.'}, result="Returns a ''string'' of the nickname if everything was successfull, ''false'' if invalid arguments are specified if there was no nickname specified for the [[ban]] element."), oop=FunctionOOP(class_name='ban', method_name='getNick', field='nick'), url=FunctionUrl(url='/wiki/GetBanNick', name='getBanNick', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getBanReason', return_types=['string'], arguments=[FunctionArgument(name='theBan', argument_type='ban', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will return the ban reason of the specified [[ban]].', arguments={'theBan': 'The ban in which you want to return the reason of.'}, result="Returns a ''string'' of the reason if everything was successful, ''false'' if invalid arguments are specified if there was no reason specified for the [[ban]]."), oop=FunctionOOP(class_name='ban', method_name='getReason', field='reason'), url=FunctionUrl(url='/wiki/GetBanReason', name='getBanReason', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getBanSerial', return_types=['string'], arguments=[FunctionArgument(name='theBan', argument_type='ban', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will return the [[serial]] of the specified [[ban]].', arguments={'theBan': 'The ban you want to retrieve the serial of.'}, result="Returns a ''string'' of the serial if everything was successful, ''false'' if invalid arguments are specified or if there was no serial specified for the [[ban]]."), oop=FunctionOOP(class_name='ban', method_name='getSerial', field="serial}}\n\n===Required Arguments=== \n*'''theBan:''' The [[ban]] you want to retrieve the serial of.\n\n===Returns===\nReturns a ''string'' of the serial if everything was successful, ''false'' if invalid arguments are specified or if there was no serial specified for the [[ban]].\n\n"), url=FunctionUrl(url='/wiki/GetBanSerial', name='getBanSerial', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getBanTime', return_types=['int'], arguments=[FunctionArgument(name='theBan', argument_type='ban', default_value=None, optional=False)]), docs=FunctionDoc(description="This function will return the time the specified [[ban]] was created, in '''seconds'''.", arguments={'theBan': 'The ban of which you wish to retrieve the time of.'}, result="* Returns an integer of the banning time in the format of seconds from the year 1970.  Use in conjunction with [[getRealTime]] in order to retrieve detailed information.\n* Returns '''false''' if invalid arguments were specified or if there was no banning time specified for the [[ban]]."), oop=FunctionOOP(class_name='ban', method_name='getTime', field="time}}\n\n===Required Arguments=== \n*'''theBan:''' The [[ban]] of which you wish to retrieve the time of.\n\n===Returns===\n* Returns an integer of the banning time in the format of seconds from the year 1970.  Use in conjunction with [[getRealTime]] in order to retrieve detailed information.\n* Returns '''false''' if invalid arguments were specified or if there was no banning time specified for the [[ban]].\n\n"), url=FunctionUrl(url='/wiki/GetBanTime', name='getBanTime', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getBanUsername', return_types=['string'], arguments=[FunctionArgument(name='theBan', argument_type='ban', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will return the username of the specified [[ban]].', arguments={'theBan': 'The ban in which you wish to retrieve the username of.'}, result="Returns a ''string'' of the username if everything was successful, ''false'' if invalid arguments are specified if there was no username specified for the [[ban]]."), oop=None, url=FunctionUrl(url='/wiki/GetBanUsername', name='getBanUsername', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getBans', return_types=['table'], arguments=[]), docs=FunctionDoc(description="This function will return a table containing all the [[ban]]s present in the server's banlist.xml.", arguments={}, result='Returns a [[table]] containing all the [[ban]]s.'), oop=None, url=FunctionUrl(url='/wiki/GetBans', name='getBans', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getUnbanTime', return_types=['int'], arguments=[FunctionArgument(name='theBan', argument_type='ban', default_value=None, optional=False)]), docs=FunctionDoc(description="This function will return the unbanning time of the specified [[ban]] in '''seconds'''.", arguments={'theBan': 'The ban in which you wish to retrieve the unban time of.'}, result="* Returns an integer of the unbanning time in the format of seconds from the year 1970.  Use in conjunction with [[getRealTime]] in order to retrieve detailed information.\n* Returns '''false''' if invalid arguments are specified or if there was no unbanning time specified for the [[ban]]."), oop=FunctionOOP(class_name='ban', method_name='getUnbanTime', field='unbanTime'), url=FunctionUrl(url='/wiki/GetUnbanTime', name='getUnbanTime', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isBan', return_types=['bool'], arguments=[FunctionArgument(name='theBan', argument_type='ban', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks whether the passed value is valid [[ban]] or not.\n}}', arguments={'theBan': 'The value to check'}, result="Returns ''true'' if the value is a ban, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsBan', name='isBan', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='kickPlayer', return_types=['bool'], arguments=[FunctionArgument(name='kickedPlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='string', argument_type='player', default_value=None, optional=False), FunctionArgument(name='reason', argument_type='string', default_value='""', optional=False)]), docs=FunctionDoc(description='This function will kick the specified player from the server.', arguments={'kickedPlayer': 'The player that will be kicked from the server', 'responsiblePlayer': 'The player that is responsible for the event. Note: If left out as in the second syntax, responsible player for the kick will be Console (Maximum 30 characters if using a string).', 'reason': 'The reason for the kick. (Maximum 64 characters)'}, result="Returns ''true'' if the player was kicked succesfully, ''false'' if invalid arguments are specified."), oop=FunctionOOP(class_name='player', method_name='kick', field=None), url=FunctionUrl(url='/wiki/KickPlayer', name='kickPlayer', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setBanAdmin', return_types=['bool'], arguments=[FunctionArgument(name='theBan', argument_type='ban', default_value=None, optional=False), FunctionArgument(name='theAdmin', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets a new admin for a [[ban]].\n}}', arguments={'theBan': 'The ban you want to change the admin of.', 'theAdmin': 'The new admin.'}, result="Returns ''true'' if changed, ''false'' otherwise."), oop=FunctionOOP(class_name='ban', method_name='setAdmin', field='admin'), url=FunctionUrl(url='/wiki/SetBanAdmin', name='setBanAdmin', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setBanNick', return_types=['bool'], arguments=[FunctionArgument(name='theBan', argument_type='ban', default_value=None, optional=False), FunctionArgument(name='theNick', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theBan': 'The ban you want to change the nick of.', 'theNick': 'A string representing the nick you want to set the ban to.'}, result=''), oop=FunctionOOP(class_name='ban', method_name='setNick', field='nick'), url=FunctionUrl(url='/wiki/SetBanNick', name='setBanNick', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setBanReason', return_types=['bool'], arguments=[FunctionArgument(name='theBan', argument_type='ban', default_value=None, optional=False), FunctionArgument(name='theReason', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the reason for the specified [[ban]].\n}}', arguments={'theBan': 'The ban that you wish to set the reason of.', 'theReason': 'the new reason (max 60 characters).'}, result="Returns ''true'' if the new reason was set successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='ban', method_name='setReason', field='reason'), url=FunctionUrl(url='/wiki/SetBanReason', name='setBanReason', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setUnbanTime', return_types=['bool'], arguments=[FunctionArgument(name='theBan', argument_type='ban', default_value=None, optional=False), FunctionArgument(name='theTime', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets a new unban time of a given [[ban]] using unix timestamp (seconds since Jan 01 1970).\n}}', arguments={'theBan': 'The ban of which to change the unban time of', 'theTime': 'the new unban time'}, result="Returns ''true'' if changed successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='ban', method_name='setUnbanTime', field='unbanTime'), url=FunctionUrl(url='/wiki/SetUnbanTime', name='setUnbanTime', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='reloadBans', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function will reload the server ban list file.', arguments={}, result="Returns ''true'' if the ban list was reloaded successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ReloadBans', name='reloadBans', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removeBan', return_types=['bool'], arguments=[FunctionArgument(name='theBan', argument_type='ban', default_value=None, optional=False), FunctionArgument(name='responsibleElement', argument_type='player', default_value='nil', optional=True)]), docs=FunctionDoc(description='This function will remove a specific [[ban]].', arguments={'theBan': 'The ban to be removed.\n{{OptionalArg}} ', 'responsibleElement': 'The element that is responsible for removing the ban element. This can be a player or the root (getRootElement()).'}, result="Returns ''true'' if the [[ban]] was removed succesfully, ''false'' if invalid arguments are specified."), oop=None, url=FunctionUrl(url='/wiki/RemoveBan', name='removeBan', category='Admin functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getGameType', return_types=['string'], arguments=[]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function retrieves the current gametype as set by [[setGameType]]. The game type is displayed in the server browser next to the server's name.", arguments={}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns the gametype as a string. If no gametype is set it returns ''nil''."), oop=None, url=FunctionUrl(url='/wiki/GetGameType', name='getGameType', category='Announcement functions', function_type=ListType.SERVER)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getMapName', return_types=['string'], arguments=[]), docs=FunctionDoc(description='This function retrieves the current mapname as set by [[setMapName]].', arguments={}, result="Returns the mapname as a string. If no mapname is set it returns ''nil''."), oop=None, url=FunctionUrl(url='/wiki/GetMapName', name='getMapName', category='Announcement functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getRuleValue', return_types=['string'], arguments=[FunctionArgument(name='key', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets a rule value. A rule value is a string that can be viewed by server browsers and used for filtering the server list.', arguments={'key': 'The name of the rule'}, result="Returns a string containing the value set for the specified ''key'', ''false'' if invalid arguments were specified."), oop=None, url=FunctionUrl(url='/wiki/GetRuleValue', name='getRuleValue', category='Announcement functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removeRuleValue', return_types=['bool'], arguments=[FunctionArgument(name='key', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function removes a set rule value that can be viewed by server browsers.', arguments={'key': 'The name of the rule you wish to remove'}, result="Returns ''true'' if the rule value was removed, ''false'' if it failed."), oop=None, url=FunctionUrl(url='/wiki/RemoveRuleValue', name='removeRuleValue', category='Announcement functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setGameType', return_types=['bool'], arguments=[FunctionArgument(name='gameType', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets a string containing a name for the game type. This should be the game-mode that is active, for example "Capture The Flag" or "Deathmatch". This is then displayed in the server browser and external server browsers.\n\'\'\'It should be noted that [[mapmanager]] handles this automatically for gamemodes that utilise the map/gamemode system.\'\'\'', arguments={'gameType': 'A string containing a name for the game mode, or false to clear it.'}, result="Returns ''true'' if the game type was set, ''false'' if an invalid argument was passed to the function."), oop=None, url=FunctionUrl(url='/wiki/SetGameType', name='setGameType', category='Announcement functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setMapName', return_types=['bool'], arguments=[FunctionArgument(name='mapName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set a map name that will be visible in the server browser. In practice you should generally rely on the mapmanager to do this for you.', arguments={'mapName': 'The name you wish the server browser to show.'}, result="Returns ''true'' if map name was set successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetMapName', name='setMapName', category='Announcement functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setRuleValue', return_types=['bool'], arguments=[FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets a rule value that can be viewed by server browsers.', arguments={'key': 'The name of the rule', 'value': 'The value you wish to set for the rule'}, result="Returns ''true'' if the rule value was set, ''false'' if invalid arguments were specified."), oop=None, url=FunctionUrl(url='/wiki/SetRuleValue', name='setRuleValue', category='Announcement functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='addElementDataSubscriber', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used together with [[setElementData]] in \'\'"subscribe"\'\' mode.\n}}', arguments={'theElement': 'The element you wish to subscribe the player to.', 'key': 'The key you wish to subscribe the player to.', 'thePlayer': 'The player you wish to subscribe.'}, result="Returns ''true'' if the player was subscribed, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='addDataSubscriber', field=None), url=FunctionUrl(url='/wiki/AddElementDataSubscriber', name='addElementDataSubscriber', category='Element functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='clearElementVisibleTo', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="This function clears any settings added by setElementVisibleTo and restores an element to its default visibility.  This does not work with all entities - [[vehicle]]s, [[player]]s and [[object]]s are exempt. This is because these objects are required for accurate sync (they're physical objects). This function is particularily useful for changing the visibility of markers, radar blips and radar areas.", arguments={'theElement': 'The element in which you wish to restore to its default visibility'}, result="Returns ''true'' if the operation was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='clearVisibility', field=None), url=FunctionUrl(url='/wiki/ClearElementVisibleTo', name='clearElementVisibleTo', category='Element functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='cloneElement', return_types=['element'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='xPos', argument_type='float', default_value='0', optional=False), FunctionArgument(name='yPos', argument_type='float', default_value='0', optional=False), FunctionArgument(name='zPos', argument_type='float', default_value='0', optional=False), FunctionArgument(name='cloneChildren', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='This function clones (creates an exact copy of) an already existing element. The root node, and player elements, cannot be cloned. If a player element is a child of an element that is cloned, it will be skipped, along with the elements that exist as a child to the player element.\nPlayers are not the only elements that cannot be cloned. This list also includes remoteclients, and console elements.\nThe cloned element will be placed on the [[element tree]] as a child of the same parent as the cloned element.', arguments={'theElement': 'The element that you wish to clone.\n{{OptionalArg}}', 'xPos': ': A floating point number representing the X coordinate on the map.', 'yPos': ': A floating point number representing the Y coordinate on the map.', 'zPos': ': A floating point number representing the Z coordinate on the map.', 'cloneChildren': ": A boolean value representing whether or not the elements children will be cloned.\n'''Note: if 'cloneChildren' is true, the position floats will be offsets from the cloned element's position.'''"}, result="Returns the handle of the new cloned element of the parent, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='element', method_name='clone', field=None), url=FunctionUrl(url='/wiki/CloneElement', name='cloneElement', category='Element functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAllElementData', return_types=['table'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns a table of all element data of an element.', arguments={'theElement': 'the element you want to get the element data of.'}, result="If successful, returns a table with as keys the names of the element data and as values the corresponding element data values. Returns ''false'' in case of failure."), oop=FunctionOOP(class_name='element', method_name='getAllData', field=None), url=FunctionUrl(url='/wiki/GetAllElementData', name='getAllElementData', category='Element functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementByIndex', return_types=['element'], arguments=[FunctionArgument(name='theType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns an element of the specified type with the specified index. ', arguments={'theType': 'the type of the element to be returned. Examples include player, vehicle, or a custom type.', 'index': 'the elements index (0 for the first element, 1 for the second, etc).'}, result="Returns the requested [[element]], or ''false'' if it doesn't exist."), oop=FunctionOOP(class_name='Element', method_name='getByIndex', field=None), url=FunctionUrl(url='/wiki/GetElementByIndex', name='getElementByIndex', category='Element functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementSyncer', return_types=['element'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the syncer of an element. The syncer is the player who is in control of the element. ', arguments={'theElement': ': The element to get the syncer of.'}, result="Returns the [[element]] that is the syncer of ''theElement'' or ''false'' if the element does not have a syncer."), oop=FunctionOOP(class_name='element', method_name='getSyncer', field='syncer'), url=FunctionUrl(url='/wiki/GetElementSyncer', name='getElementSyncer', category='Element functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementZoneName', return_types=['string'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='citiesonly', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='This function allows you to retrieve the zone name of an element (eg. Verdant Bluffs or Ocean Docks)\nThe same can be achieved client side by getting element coordinates and using [[GetZoneName]].', arguments={'theElement': 'The element which youd like to retrieve the zone name from\n{{OptionalArg}}', 'citiesonly': ': An optional argument to choose if you want to return the city name (eg Las Venturas)'}, result='Returns the string of the elements zone name.'), oop=FunctionOOP(class_name='element', method_name='getZoneName', field=None), url=FunctionUrl(url='/wiki/GetElementZoneName', name='getElementZoneName', category='Element functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='hasElementDataSubscriber', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used together with [[setElementData]] in \'\'"subscribe"\'\' mode.\n}}', arguments={'theElement': 'The element you wish to check whether the player is subscribed to.', 'key': 'The key you wish to check whether the player is subscribed to.', 'thePlayer': 'The player you wish to check.'}, result="Returns ''true'' if the player is subscribed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/HasElementDataSubscriber', name='hasElementDataSubscriber', category='Element functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isElementCallPropagationEnabled', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This functions checks if certain element has call propagation enabled.', arguments={'theElement': 'The element to check'}, result="Returns ''true'' if the propagation is enabled, ''false'' if disabled or invalid arguments have been passed."), oop=FunctionOOP(class_name='element', method_name='isCallPropagationEnabled', field=None), url=FunctionUrl(url='/wiki/IsElementCallPropagationEnabled', name='isElementCallPropagationEnabled', category='Element functions', function_type=ListType.SERVER)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isElementVisibleTo', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='visibleTo', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This checks if an element is visible to a player. This does not check if the player can literally see the element, just that they are aware that it exists. Some so-called [[per-player elements]] are able to be visible only to some players, as such this checks if this is the case for a particular element/player combination.', arguments={'theElement': 'The element you want to check the visibility of', 'visibleTo': 'The player you want to check against'}, result="Returns ''true'' if element is visible to the specified player, ''false'' if not or an invalid argument was passed to the function."), oop=FunctionOOP(class_name='element', method_name='isVisibleTo', field=None), url=FunctionUrl(url='/wiki/IsElementVisibleTo', name='isElementVisibleTo', category='Element functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removeElementData', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function removes the [[element data]] with the given key for that element. The element data removal is synced with all the clients.', arguments={'theElement': 'The element you wish to remove the data from.', 'key': 'The key string you wish to remove.'}, result="Returns ''true'' if the data was removed succesfully, ''false'' if the given key does not exist in the element or the element is invalid."), oop=FunctionOOP(class_name='element', method_name='removeData', field=None), url=FunctionUrl(url='/wiki/RemoveElementData', name='removeElementData', category='Element functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removeElementDataSubscriber', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used together with [[setElementData]] in \'\'"subscribe"\'\' mode.\n}}', arguments={'theElement': 'The element you wish to unsubscribe the player from.', 'key': 'The key you wish to unsubscribe the player from.', 'thePlayer': 'The player you wish to unsubscribe.'}, result="Returns ''true'' if the player was unsubscribed, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='removeDataSubscriber', field=None), url=FunctionUrl(url='/wiki/RemoveElementDataSubscriber', name='removeElementDataSubscriber', category='Element functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setElementCallPropagationEnabled', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function enables/disables call propagation on a certain element. Look at the example for a practical application.', arguments={'theElement': 'The element whose propagation behaviour youd like to change', 'enabled': 'Whether propagation should be enabled or not'}, result="Returns ''true'', if the propagation behaviour has been changed successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setCallPropagationEnabled', field=None), url=FunctionUrl(url='/wiki/SetElementCallPropagationEnabled', name='setElementCallPropagationEnabled', category='Element functions', function_type=ListType.SERVER)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementSyncer', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="This function can be used to change the syncer ([[player]]) of an element. The syncer is the player who is responsible for informing the server about the state of that element - it's position, orientation and other state information. The function can be also used to remove an element's syncer.\nOnly [[vehicle]] and [[ped]] elements can have a syncer, other element types are not currently automatically synced by MTA.\nPlease note that using this function to change an element's syncer will only last as long as the element is within syncable range of the player. This is within 140 units for vehicles and 100 units for peds. As soon as it becomes impossible for your chosen player to sync the element, another player (or no player) will be automatically selected, and your setting will be lost. With vehicles, the last occupant to leave a vehicle will be selected as the syncer and override any setting you may have made.\nUsing this function to remove an element's syncer, means no player will be assigned to syncing the element. That will not be changed until setElementSyncer is called again.\nIt should also be noted that certain network changes to an element do not require a syncer. Actions such as destroying an element or explicitly setting the element's position (in a server side script), will still be updated on all clients regardless of this setting.", arguments={'theElement': 'The element whose syncer you wish to change.', 'thePlayer': 'The player who should be the new syncer of the element. If set to false, this element will not have a syncer. If set to true, MTA will pick automatically the nearest or most relevant player to that element.'}, result="Returns ''true'' if the syncer was changed successfully, ''false'' if the element passed was not a ped or vehicle."), oop=FunctionOOP(class_name='element', method_name='setSyncer', field='syncer'), url=FunctionUrl(url='/wiki/SetElementSyncer', name='setElementSyncer', category='Element functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementVisibleTo', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='visibleTo', argument_type='element', default_value=None, optional=False), FunctionArgument(name='visible', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="Does the order of setElementVisibleTo calls really not matter? [[visibility|Visibility]] seems to ''imply'' that the order does matter.\nIs this function particularly ''or only'' useful for changing the visibility of markers, radar blips and radar areas?|[[User:EAi|EAi]][[User:Iam2noob4u|Iam2noob4u]]\n}}\nThis function can change an [[element]]'s [[visibility]]. This does not work with all entities - [[vehicle]]s, [[player]]s and [[object]]s are exempt. This is because these objects are required for accurate sync (they're physical objects that contribute to the physics engine). This function is particularly useful for changing the visibility of markers, radar blips and radar areas.\nVisibility settings of lower elements in the element tree override higher ones - if visibility for root is set to false and for a player is set to true, it will be visible to the player.\nIf you want to clear all visibility settings of an object, try [[clearElementVisibleTo]]", arguments={'theElement': 'The element you want to control the visibility of.', 'visibleTo': 'The element you wish the element to be visible or invisible to. Any child elements that are players will also be able to see the element. See visibility.', 'visible': 'Whether you are making it visible or invisible to the player.'}, result="Returns ''true'' if the element's visibility was changed successfully, ''false'' otherwise, for example if you are trying to change the visibility of a vehicle, player or object."), oop=FunctionOOP(class_name='element', method_name='setVisibleTo', field=None), url=FunctionUrl(url='/wiki/SetElementVisibleTo', name='setElementVisibleTo', category='Element functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getCancelReason', return_types=['string'], arguments=[]), docs=FunctionDoc(description='Gets the reason for cancelling an event.', arguments={}, result='Returns the reason that was given with [[cancelEvent]]'), oop=None, url=FunctionUrl(url='/wiki/GetCancelReason', name='getCancelReason', category='Event functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='triggerClientEvent', return_types=['bool'], arguments=[FunctionArgument(name='element', argument_type='table', default_value=None, optional=False), FunctionArgument(name='name', argument_type='string', default_value=None, optional=False), FunctionArgument(name='sourceElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description="<!--{{Needs_Checking|Something needs to be said about the steps required to help keep an event inside a resource. i.e. Setting 'theElement' to resourceRoot here, and setting the matching event handler's 'attachedTo' also to resourceRoot.}}\n-->__NOTOC__\nThis function triggers an event previously registered on a client. This is the primary means of passing information between the server and the client. Clients have a similar [[triggerServerEvent]] function that can do the reverse. You can treat this function as if it was an asynchronous function call, using [[triggerServerEvent]] to pass back any returned information if necessary. \nAlmost any data types can be passed as expected, including [[element]]s and complex nested [[table]]s. Non-element MTA data types like xmlNodes or resource pointers will not be able to be passed as they do not necessarily have a valid representation on the client.\nEvents are sent reliably, so clients will receive them, but there may be (but shouldn't be) a significant delay before they are received. You should take this into account when using them.\nKeep in mind the bandwidth issues when using events - don't pass a large list of arguments unless you really need to. '''It is marginally more efficient to pass one large event than two smaller ones'''.", arguments={'name': 'The name of the event to trigger client side. You should register this event with addEvent and add at least one event handler using addEventHandler.', 'sourceElement': "The element that is the Event system#Event handlers|source of the event.\n{{Note|To save client CPU, you should avoid setting '''sourceElement''' to the [[root element]] where possible. Using [[GetThisResource|resourceRoot]] is usually sufficient if the event is handled by the same resource on the client.}}\n{{OptionalArg}} ", 'sendTo': 'The event will be sent to all players that are children of the specified element. By default this is the root element, and hence the event is sent to all players. If you specify a single player it will just be sent to that player. This argument can also be a table of player elements.', 'arguments...': 'A list of arguments to trigger with the event. You can pass any lua data type (except functions). You can also pass elements.'}, result="Returns ''true'' if the event trigger has been sent, ''false'' if invalid arguments were specified."), oop=FunctionOOP(class_name='player', method_name='triggerEvent', field=None), url=FunctionUrl(url='/wiki/TriggerClientEvent', name='triggerClientEvent', category='Event functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='triggerLatentClientEvent', return_types=['bool'], arguments=[FunctionArgument(name='element', argument_type='table', default_value=None, optional=False), FunctionArgument(name='name', argument_type='string', default_value=None, optional=False), FunctionArgument(name='bandwidth', argument_type='int', default_value='50000', optional=False), FunctionArgument(name='persist', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function is the same as [[triggerClientEvent ]] except the transmission rate of the data contained in the arguments can be limited\nand other network traffic is not blocked while the data is being transferred.', arguments={'name': 'The name of the event to trigger client side. You should register this event with addEvent and add at least one event handler using addEventHandler.', 'theElement': 'The element that is the Event system#Event handlers|source of the event. This could be another player, or if this isnt relevant, use the root element.', 'sendTo': 'The event will be sent to all players that are children of the specified element. By default this is the root element, and hence the event is sent to all players. If you specify a single player it will just be sent to that player. This argument can also be a table of player elements.', 'bandwidth': 'The bytes per second rate to send the data contained in the arguments.', 'persist': 'A bool indicating whether the transmission should be allowed to continue even after the resource that triggered it has since stopped.', 'arguments...': 'A list of arguments to trigger with the event. You can pass any Lua data type (except functions). You can also pass elements. The total amount of data should not exceed 100MB.'}, result="Returns ''true'' if the event trigger has been sent, ''false'' if invalid arguments were specified."), oop=None, url=FunctionUrl(url='/wiki/TriggerLatentClientEvent', name='triggerLatentClientEvent', category='Event functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getControlState', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='controlName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will check if a player is pressing a particular control. Controls are those that affect GTA. If you wish to get the state of another key, use [[bindKey]] and a command function.\nNote: Not all control states are sent to the server at all times, as such their state may be given incorrectly. As a rule, keys that move or affect the player or their vehicle are most likely to be accurate. For increased accuracy (and also increased bandwidth usage) use bindKey instead to bind a GTA control name to a function.', arguments={'thePlayer': 'The player you wish to get the control state of. Do not use this parameter when scripting for client.', 'controlName': "The control that you want to get the state of. See control names for a list of possible controls.\n'''Note:''' several controls are not synched with the server, therefore the function will always return ''false'' for these controls serverside. These controls are:\n*next_weapon\n*previous_weapon\n*jump\n*zoom_in\n*zoom_out\n*look_behind\n*change_camera\n*conversation_yes\n*conversation_no\n*group_control_forwards\n*group_control_back\n*sub_mission\n*radio_next\n*radio_previous\n*vehicle_look_left\n*vehicle_look_right\n*vehicle_look_behind\n*vehicle_mouse_look\n*special_control_*"}, result="Returns the state of the control, ''false'' if the control doesn't exist or if the player is dead."), oop=None, url=FunctionUrl(url='/wiki/GetControlState', name='getControlState', category='Input functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isKeyBound', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='keyState', argument_type='string', default_value=None, optional=False), FunctionArgument(name='handler', argument_type='function', default_value=None, optional=False)]), docs=FunctionDoc(description='This function can be used to find out if a key has already been bound. If you do not specify a keyState or handler, any instances of key being bound will cause isKeyBound to return true.', arguments={'thePlayer': 'The player youre checking.', 'key': 'The key youre checking. See Key names for a list of valid key names.', 'keyState': 'Is the state of the key when it calls the function, Can be either:', '"up"': 'when the key is released', '"down"': 'when the key is pressed', 'handler': 'The function youre checking against'}, result="Returns ''true'' if the key is bound, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsKeyBound', name='isKeyBound', category='Input functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setControlState', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='control', argument_type='string', default_value=None, optional=False), FunctionArgument(name='state', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="Sets a state of a specified player's control, as if they pressed or released it.", arguments={'thePlayer': 'The player you wish to set the control state of.', 'control': 'The control that you want to set the state of. See control names for a list of possible controls.', 'state': 'A boolean value representing whether or not the key will be set to pressed or not.'}, result="Returns ''true'' if the control state was successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetControlState', name='setControlState', category='Input functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='loadMapData', return_types=['element'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is intended to load data from a loaded XML file into the element tree. This could be used for loading an external map, or part of another map.', arguments={'node': 'The node that you wish to load into the element tree.', 'parent': 'The node you wish to be the parent of the new map data.'}, result="Returns an [[element]] object that corresponds to the root of the new data added, i.e. an element that represents the ''node'' xmlnode passed to the function. Returns ''false'' if the arguments are invalid."), oop=None, url=FunctionUrl(url='/wiki/LoadMapData', name='loadMapData', category='Map functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetMapInfo', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value='getRootElement(', optional=False)]), docs=FunctionDoc(description='This function is used to reset the state of a player.  It is intended to restore a player to his default state as if he had just joined the server, without any scripts affecting him.', arguments={'thePlayer': 'The specific player you wish to restore the state of.  Not specifying this will result in all players map info being reset.'}, result="Returns ''true'' if the map info was reset successfully, otherwise ''false''."), oop=None, url=FunctionUrl(url='/wiki/ResetMapInfo', name='resetMapInfo', category='Map functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='saveMapData', return_types=['bool'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='baseElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='childrenOnly', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This converts a set of elements in the element tree into XML. This is a format that can then be loaded as a map file. Each element represents a single XML node.', arguments={'node': ': An existing node that should contain the contents of baseElement', 'baseElement': ': The first element to output to the XML tree. This element and all its children (and their children, etc) will be output.\n{{OptionalArg}}', 'childrenOnly': ': Defines if you want to only save children of the specified element.'}, result=''), oop=None, url=FunctionUrl(url='/wiki/SaveMapData', name='saveMapData', category='Map functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getLoadedModules', return_types=['table'], arguments=[]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function returns all the currently loaded [[modules]] of the server.", arguments={}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns a table of all the currently loaded [[modules]]. If no modules are loaded, the table will be empty."), oop=None, url=FunctionUrl(url='/wiki/GetLoadedModules', name='getLoadedModules', category='Module functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getModuleInfo', return_types=['table'], arguments=[FunctionArgument(name='moduleName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns information about the specified [[Modules|module]].', arguments={'moduleName': 'A string containing the module you wish to get information of e.g. hashing.dll'}, result="Returns a [[table]] containing information about module. These keys are present in the table:\n*'''version''': Module version in format X.XX\n*'''name''': Module name\n*'''author''': Module author\nIf invalid name for module is passed, it will return ''false''."), oop=None, url=FunctionUrl(url='/wiki/GetModuleInfo', name='getModuleInfo', category='Module functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='outputServerLog', return_types=['bool'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This outputs a line of text to the server's log. This could be useful for debugging.", arguments={'text': 'The text to be output to the log.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/OutputServerLog', name='outputServerLog', category='Output functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedGravity', return_types=['float'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current gravity for the specified [[ped]]. The default gravity is 0.008.', arguments={'thePed': 'The ped whose gravity you want to check.'}, result="Returns a [[float]] indicating the ped's gravity, or ''false'' if the ped is invalid. Default value is 0.008."), oop=FunctionOOP(class_name='ped', method_name='getGravity', field='gravity'), url=FunctionUrl(url='/wiki/GetPedGravity', name='getPedGravity', category='Ped functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isPedDead', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if the specified [[ped]] is dead or not.', arguments={'thePed': ': the ped you want to check up on.'}, result="Returns ''true'' if the ped is dead, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='isDead', field="dead}}\n\n===Required Arguments===\n* '''thePed''': the [[ped]] you want to check up on.\n\n===Returns===\nReturns ''true'' if the ped is dead, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/IsPedDead', name='isPedDead', category='Ped functions', function_type=ListType.SERVER)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='reloadPedWeapon', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function makes a pedestrian reload their weapon.', arguments={'thePed': 'The ped who will reload their weapon.'}, result="Returns ''true'' if the pedestrian was made to reload, or ''false'' if invalid arguments were passed or that pedestrian has a weapon which cannot be reloaded.\n'''Note:''' this will fail but return true if\n1) the ped is crouched and moving\n2) the ped is using a weapon without clip ammo (or minigun/flamethrower/fire\nextinguisher)\n3) the ped is using his weapon (shooting/aiming)\n4) the ped moved while crouching recently\nDue to these circumstances causing problems with this function"), oop=None, url=FunctionUrl(url='/wiki/ReloadPedWeapon', name='reloadPedWeapon', category='Ped functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPedChoking', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='choking', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function can be used to force the ped to do the choking (coughing) animation until he respawns or toggled off using this function. The animation can not be cancelled by a player it's applied to, and he will not loose health.", arguments={'thePed': 'The ped whose choking status to toggle', 'choking': 'true to make the ped choke, false to no longer force his choking animation'}, result="Returns ''true'' if successful, ''false'' otherwise (e.g. player handle is invalid)"), oop=FunctionOOP(class_name='ped', method_name='setChoking', field='choking'), url=FunctionUrl(url='/wiki/SetPedChoking', name='setPedChoking', category='Ped functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPedGravity', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='gravity', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the gravity level of a ped.', arguments={'thePed': ': The ped whose gravity to change.', 'level': ': The level of gravity (default is 0.008).'}, result="Returns ''true'' if the gravity was successfully set, ''false'' otherwise"), oop=FunctionOOP(class_name='ped', method_name='setGravity', field='gravity'), url=FunctionUrl(url='/wiki/SetPedGravity', name='setPedGravity', category='Ped functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPedWearingJetpack', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='state', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to give or take a jetpack from a ped, it won't work if the ped is in a vehicle.\nAs such, you should either expect it to fail sometimes, or repeatedly try to give a jetpack every second or so until [[isPedWearingJetpack]] returns true. Alternatively, you can force the ped into a 'safe' position (e.g. standing on the ground) before giving the jetpack, or use a [[pickup]] to handle it.}}", arguments={'thePed': 'The ped you want to give a jetpack to.', 'state': 'A boolean representing whether to give or take the jetpack.'}, result="Returns ''true'' if a jetpack was successfully set for the ped, ''false'' if setting it failed."), oop=FunctionOOP(class_name='ped', method_name='setWearingJetpack', field="jetpack}}\n\n===Required Arguments===\n*'''thePed:''' The [[ped]] you want to give a jetpack to.\n*'''state:''' A [[boolean]] representing whether to give or take the jetpack.\n\n===Returns===\nReturns ''true'' if a jetpack was successfully set for the ped, ''false'' if setting it failed.\n\n"), url=FunctionUrl(url='/wiki/SetPedWearingJetpack', name='setPedWearingJetpack', category='Ped functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPickupRespawnInterval', return_types=['int'], arguments=[FunctionArgument(name='thePickup', argument_type='pickup', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the time it takes before a pickup respawns after a player picked it up. The time is specified in milliseconds.', arguments={'thePickup': 'the pickup you want the respawn time of'}, result="Returns the respawn time of the pickup if successful, ''false'' in case of failure."), oop=None, url=FunctionUrl(url='/wiki/GetPickupRespawnInterval', name='getPickupRespawnInterval', category='Pickup functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isPickupSpawned', return_types=['bool'], arguments=[FunctionArgument(name='thePickup', argument_type='pickup', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if a pickup is currently spawned (is visible and can be picked up) or not (a player picked it up recently).', arguments={'thePickup': 'the pickup you want to check.'}, result="Returns ''true'' if the pickup is spawned, ''false'' if it's not spawned or an invalid pickup was specified."), oop=None, url=FunctionUrl(url='/wiki/IsPickupSpawned', name='isPickupSpawned', category='Pickup functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPickupRespawnInterval', return_types=['bool'], arguments=[FunctionArgument(name='thePickup', argument_type='pickup', default_value=None, optional=False), FunctionArgument(name='ms', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the time it takes for a pickup to respawn after a player picked it up.', arguments={'thePickup': 'the pickup to set the respawn time of', 'ms': 'the new respawn time in ms'}, result="Returns ''true'' if the new respawn time was set successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetPickupRespawnInterval', name='setPickupRespawnInterval', category='Pickup functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAlivePlayers', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function returns a table of all the alive players on the server. Opposite function of [[getDeadPlayers]].', arguments={}, result='Returns a table of all the alive players.'), oop=FunctionOOP(class_name='Player', method_name='getAllAlive', field=None), url=FunctionUrl(url='/wiki/GetAlivePlayers', name='getAlivePlayers', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getDeadPlayers', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function returns a table of all currently dead players on the server.', arguments={}, result='Returns a table of all the dead players.'), oop=FunctionOOP(class_name='Player', method_name='getAllDead', field=None), url=FunctionUrl(url='/wiki/GetDeadPlayers', name='getDeadPlayers', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerACInfo', return_types=['table'], arguments=[FunctionArgument(name='thePlayer', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns anti-cheat info for a player. The info returned by this function can change over time, so use the server event [[onPlayerACInfo]] instead.', arguments={'thePlayer': 'The player whose anti-cheat info you want to check.'}, result="Returns a table with the following entries:\n* '''DetectedAC:''' A string containing a comma separated list of [[Anti-cheat_guide|anti-cheat]] codes the player has triggered.\n*'''d3d9Size:''' A number representing the file size of any custom d3d9.dll the player may have installed.\n*'''d3d9MD5:''' A string containing the MD5 of any custom d3d9.dll the player may have installed.\n*'''d3d9SHA256:''' A string containing the SHA256 of any custom d3d9.dll the player may have installed.\n<!--"), oop=FunctionOOP(class_name='player', method_name='getACInfo', field='ACInfo'), url=FunctionUrl(url='/wiki/GetPlayerACInfo', name='getPlayerACInfo', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerAnnounceValue', return_types=['string'], arguments=[FunctionArgument(name='thePlayer', argument_type='element', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'thePlayer': 'This is the Player whos value you want to retrieve.', 'key': 'The name of the key.'}, result="This function returns a ''string'' containing the requested value if a valid key was specified or ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='getAnnounceValue', field=None), url=FunctionUrl(url='/wiki/GetPlayerAnnounceValue', name='getPlayerAnnounceValue', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerCount', return_types=['int'], arguments=[]), docs=FunctionDoc(description='This function returns the number of players currently connected to the server.', arguments={}, result='Returns the number of players connected to the server as an [[int]].'), oop=FunctionOOP(class_name='Player', method_name='getCount', field=None), url=FunctionUrl(url='/wiki/GetPlayerCount', name='getPlayerCount', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerIdleTime', return_types=['int'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the amount of time in milliseconds that a players position has not changed.', arguments={'thePlayer': ': The player you wish to get the idle time of.'}, result="Returns the amount of '''time in milliseconds''' that a player has been idle, '''false''' otherwise."), oop=FunctionOOP(class_name='player', method_name='getIdleTime', field='idleTime'), url=FunctionUrl(url='/wiki/GetPlayerIdleTime', name='getPlayerIdleTime', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerIP', return_types=['string'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a [[string]] containing the IP address of the [[player]].', arguments={'thePlayer': 'The player element you want to get the IP of.'}, result="Returns a [[string]] containing the requested players's IP, or ''false'' if the player passed to the function is invalid."), oop=FunctionOOP(class_name='player', method_name='getIP', field='ip'), url=FunctionUrl(url='/wiki/GetPlayerIP', name='getPlayerIP', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerScriptDebugLevel', return_types=['int'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis will allow you to retrieve the player current debug script level.\n}}", arguments={'thePlayer': 'The person whose debug script level you want'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns an ''int'' with the player debug script level, ''false'' if the player is invalid."), oop=FunctionOOP(class_name='player', method_name='getScriptDebugLevel', field='scriptDebugLevel'), url=FunctionUrl(url='/wiki/GetPlayerScriptDebugLevel', name='getPlayerScriptDebugLevel', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerSerial', return_types=['string'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the [[serial]] for a specified [[player]].', arguments={'thePlayer': 'A player object referencing the specified player.'}, result="Returns the serial as a ''string'' if it was found, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='getSerial', field='serial'), url=FunctionUrl(url='/wiki/GetPlayerSerial', name='getPlayerSerial', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerVersion', return_types=['string'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets the client version of the specified [[player]] as a sortable string. The string is always 15 characters long and is formatted as follows:\n* 1 character representing the major version\n* 1 dot character\n* 1 character representing the minor version\n* 1 dot character\n* 1 character representing the maintenance version\n* 1 dash character\n* 1 character representing the build type\n* 1 dot character\n* 5 characters representing the build number\n* 1 dot character\n* 1 character representing the build revision\nAn example of a version string would be: 1.0.4-9.01746.0\nWhere the first three numbers represent the major/minor/maintenance version, i.e. 1.0.4<br>\nThe fourth number is 9, which means it's a release build, (Development and beta builds have lower numbers here)<br>\nAnd the fifth and sixth numbers represent the build number.", arguments={'thePlayer': 'The player whose client version you wish to get.'}, result='Returns a string containing the client version, or false if the [[player]] is invalid.'), oop=FunctionOOP(class_name='player', method_name='getVersion', field='version'), url=FunctionUrl(url='/wiki/GetPlayerVersion', name='getPlayerVersion', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getRandomPlayer', return_types=['player'], arguments=[]), docs=FunctionDoc(description='This function returns a random [[player]].', arguments={}, result="Returns a random [[player]], ''false'' if the server is empty."), oop=None, url=FunctionUrl(url='/wiki/GetRandomPlayer', name='getRandomPlayer', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isPlayerMuted', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='Use this function to check if a player has been muted.', arguments={'thePlayer': 'The player you are checking.'}, result="Returns ''true'' if the player is muted and ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='isMuted', field='muted'), url=FunctionUrl(url='/wiki/IsPlayerMuted', name='isPlayerMuted', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='redirectPlayer', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='serverIP', argument_type='string', default_value='""', optional=False), FunctionArgument(name='serverPort', argument_type='int', default_value='0 [', optional=False), FunctionArgument(name='serverPassword', argument_type='string', default_value='""', optional=True)]), docs=FunctionDoc(description='This function redirects the player to a specified server.', arguments={'thePlayer': 'The player you want to redirect', 'serverIP': 'The IP address (or domain name that resolves to the IP address) of the server you want to redirect the player to. Use an empty string to reconnect to the same server.', 'serverPort': 'The game port of the server you want to redirect the player to, this is usually 22003. Set to zero to use the same port as the current server.', 'serverPassword': 'The password for the server if its protected'}, result="Returns ''true'' if the player was redirected successfully, ''false'' if bad arguments were passed."), oop=FunctionOOP(class_name='player', method_name='redirect', field=None), url=FunctionUrl(url='/wiki/RedirectPlayer', name='redirectPlayer', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resendPlayerACInfo', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will force the specified player to resend their AC info, triggering the [[onPlayerACInfo]] event again.\n}}', arguments={'thePlayer': ': A player object referencing the specified player'}, result="Returns ''true'' if the AC info will be resent, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResendPlayerACInfo', name='resendPlayerACInfo', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resendPlayerModInfo', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will force the specified player to resend their mod info, triggering the [[onPlayerModInfo]] event again.', arguments={'thePlayer': ': A player object referencing the specified player'}, result="Returns ''true'' if the mod info will be resent, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='resendModInfo', field=None), url=FunctionUrl(url='/wiki/ResendPlayerModInfo', name='resendPlayerModInfo', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerAnnounceValue', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='element', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to change ASE announce values for any player using a specified key.\nAs an example this can be used to change the "score" value which will be shown at [https://www.game-state.com/ game-state.com]\'s server list.\nFor server-wide changes you can use [[setRuleValue]]!', arguments={'thePlayer': 'The player whos announce value you wish to change.', 'key': 'The key which the value will be stored at.', 'value': 'The value you wish to store.'}, result="Returns ''true'' if the value was set succesfully, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='setAnnounceValue', field=None), url=FunctionUrl(url='/wiki/SetPlayerAnnounceValue', name='setPlayerAnnounceValue', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerMuted', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='state', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='Use this function to mute or unmute the player.', arguments={'thePlayer': 'The player you are muting or unmuting.', 'state': 'Use true to mute and false to unmute the player.'}, result="Returns ''true'' if the player was successfully muted or unmuted, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='setMuted', field='muted'), url=FunctionUrl(url='/wiki/SetPlayerMuted', name='setPlayerMuted', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerName', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='newName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function changes the specified [[player]]'s name. Note that any change made to a players name with this function is not saved in their settings so the name change only lasts till they disconnect.", arguments={'thePlayer': 'the player that will have its name set.', 'newName': 'the new name to set for the player.'}, result="Returns ''true'' if the player name was changed succesfully, ''false'' if invalid arguments are specified."), oop=FunctionOOP(class_name='player', method_name='setName', field='name'), url=FunctionUrl(url='/wiki/SetPlayerName', name='setPlayerName', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerScriptDebugLevel', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='level', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis will set player's debug level, equivalent to [[Debugging|debugscript <level>]].\n}}", arguments={'thePlayer': 'The player whose debug level you wish to change', 'level': '0: close debug console, 1: only errors, 2: errors and warnings, 3: errors, warnings and info messages'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='setScriptDebugLevel', field='scriptDebugLevel'), url=FunctionUrl(url='/wiki/SetPlayerScriptDebugLevel', name='setPlayerScriptDebugLevel', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerTeam', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False)]), docs=FunctionDoc(description="This function adds a [[player]] to an existing [[team]]. The player will automatically be removed from his current team if he's on one.", arguments={'thePlayer': 'The player you wish to add to a team.', 'theTeam': 'The team you want to add the player to, or nil if you wish to unassign a player from his team.'}, result="Returns ''true'' if the player was successfully added to the specified team or removed from his previous one, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='setTeam', field='team'), url=FunctionUrl(url='/wiki/SetPlayerTeam', name='setPlayerTeam', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerVoiceBroadcastTo', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='element', default_value=None, optional=False), FunctionArgument(name='broadcastTo', argument_type='mixed', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to change who can hear the voice of a player.', arguments={'thePlayer': 'The player you wish to change', 'broadcastTo ': 'Element or table of elements who should hear the voice from this player'}, result="Returns ''true'' if the value was set successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='setVoiceBroadcastTo', field='voiceBroadcastTo'), url=FunctionUrl(url='/wiki/SetPlayerVoiceBroadcastTo', name='setPlayerVoiceBroadcastTo', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerVoiceIgnoreFrom', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='element', default_value=None, optional=False), FunctionArgument(name='ignoreFrom', argument_type='mixed', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to mute voices for a player.', arguments={'thePlayer': 'The player you wish to change', 'ignoreFrom': 'Element or table of elements which the player should not hear voices from. Use nil if no one should be ignored.'}, result="Returns ''true'' if the value was set successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='setVoiceIgnoreFrom', field='voiceIgnoreFrom'), url=FunctionUrl(url='/wiki/SetPlayerVoiceIgnoreFrom', name='setPlayerVoiceIgnoreFrom', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerWantedLevel', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='stars', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to set a player's wanted level. The wanted level is indicated by the amount of stars a player has on the GTA HUD.", arguments={'thePlayer': 'The player whose wanted level is to be set', 'stars': 'An integer from 0 to 6 representing the wanted level'}, result="Returns ''true'' if the wanted level was set successfully, ''false'' if any of the arguments were invalid."), oop=FunctionOOP(class_name='player', method_name='setWantedLevel', field='wantedLevel'), url=FunctionUrl(url='/wiki/SetPlayerWantedLevel', name='setPlayerWantedLevel', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='spawnPlayer', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rotation', argument_type='int', default_value='0', optional=False), FunctionArgument(name='skinID', argument_type='int', default_value='0', optional=False), FunctionArgument(name='interior', argument_type='int', default_value='0', optional=False), FunctionArgument(name='dimension', argument_type='int', default_value='0', optional=False), FunctionArgument(name='theTeam', argument_type='team', default_value='getPlayerTeam(thePlayer', optional=False)]), docs=FunctionDoc(description='This function spawns the player at an arbitary point on the map.<br>', arguments={'thePlayer': 'The player you want to spawn.', 'x': 'The x co-ordinate to spawn the player at.', 'y': 'The y co-ordinate to spawn the player at.', 'z': 'The z co-ordinate to spawn the player at.', 'rotation': 'rotation of the player on spawn.', 'skinID': 'players skin on spawn. Character Skins', 'interior': 'interior the player will spawn into. Interior IDs', 'dimension': 'The ID of the dimension that the player should be in.', 'theTeam': 'the team the player will join.'}, result="Returns ''true'' if the player was spawned successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='spawn', field=None), url=FunctionUrl(url='/wiki/SpawnPlayer', name='spawnPlayer', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='takePlayerScreenShot', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='width', argument_type='int', default_value=None, optional=False), FunctionArgument(name='height', argument_type='int', default_value=None, optional=False), FunctionArgument(name='tag', argument_type='string', default_value='""', optional=True), FunctionArgument(name='quality', argument_type='int', default_value='30', optional=True), FunctionArgument(name='maxBandwith', argument_type='int', default_value='5000', optional=True), FunctionArgument(name='maxPacketSize', argument_type='int', default_value='500', optional=True)]), docs=FunctionDoc(description="This function forces a client to capture the current screen output and send it back to the server. The image will contain the GTA HUD and the output of any dxDraw functions that are not flagged as 'post GUI'. The image specifically excludes the chat box and all GUI (including the client console). The result is received with the event [[onPlayerScreenShot]].", arguments={'thePlayer': 'the player to get the screen capture from.', 'width': 'the width of the capture image.', 'height': 'the height of the capture image.', 'tag': 'A string to help identify the screen capture. The string is passed to the matching onPlayerScreenShot event for your personal convenience.', 'quality': 'Quality of the final JPEG image from 0 to 100. A lower value can reduce the memory used by the image considerably which will result in faster and less intrusive uploads.', 'maxBandwith': "The amount of client upload bandwidth to use (in bytes per second) when sending the image.\n*'''maxPacketSize: ''' The maximum size of one packet."}, result="Returns ''true'' if the function was successfully, ''false'' if invalid arguments are specified."), oop=FunctionOOP(class_name='player', method_name='takeScreenShot', field=None), url=FunctionUrl(url='/wiki/TakePlayerScreenShot', name='takePlayerScreenShot', category='Player functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='addResourceConfig', return_types=['xmlnode'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='filetype', argument_type='string', default_value='"server"', optional=False)]), docs=FunctionDoc(description='This function adds a new empty config file to an existing resource.', arguments={'filePath': 'The filepath of the file to be created in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file.\n:For example, if you want to create a config named \'settings.xml\' in the resource \'ctf\', it can be created from another resource this way: \'\'addResourceConfig(":ctf/settings.xml", "server")\'\'.\n:If you want to create the file in the current resource, only the file path is necessary, e.g. \'\'addResourceConfig("settings.xml", "server")\'\'.\n{{OptionalArg}} ', 'filetype': 'a string indicating whether the file is serverside (server) or clientside (client).'}, result="Returns the new config's root [[xmlnode]] if the config was added successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/AddResourceConfig', name='addResourceConfig', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='addResourceMap', return_types=['xmlnode'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='dimension', argument_type='int', default_value='0', optional=False)]), docs=FunctionDoc(description='This function adds a new empty mapfile to an existing resource.', arguments={'filePath': 'The filepath of the resource map in the following format: :resourceName/path. resourceName is the name of the resource the map file will be in, and path is the path from the root directory of the resource to the file.\n:For example, if you want to create a map file named \'manycars.map\' in the resource \'cdm\', it can be created from another resource this way: \'\'addResourceMap(":cdm/manycars.map")\'\'.\n:If you want to create the map file in the current resource, only the file path is necessary, e.g. \'\'addResourceMap("manycars.map")\'\'.\n{{OptionalArg}} ', 'dimension': 'the dimension in which the maps objects will be placed.'}, result="Returns the new map's root [[xmlnode]] if the map was added successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/AddResourceMap', name='addResourceMap', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='callRemote', return_types=['bool'], arguments=[FunctionArgument(name='host', argument_type='string', default_value=None, optional=False), FunctionArgument(name='queueName', argument_type='string', default_value='"default"', optional=True), FunctionArgument(name='connectionAttempts', argument_type='int', default_value='10', optional=True), FunctionArgument(name='connectTimeout', argument_type='int', default_value='10000', optional=True), FunctionArgument(name='resourceName', argument_type='string', default_value=None, optional=True), FunctionArgument(name='functionName', argument_type='string', default_value=None, optional=True), FunctionArgument(name='callbackFunction', argument_type='callback', default_value=None, optional=True), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function allows you to call functions that have been exported with HTTP access by other MTA servers. The calls are asynchronous so you do not get an immediate result from the call, instead a callback function you specify is called when the call returns.\nYou can also use this function to access a standard web page on a server you own by specifying the URL. The arguments you specify to callRemote are passed to the web page using HTTP POST as a [[JSON]] array. This will always have an array as the root element. The page must return a JSON formated *array* in the page\'s body with the results of the call (or an empty array if there are no results).\nYou can use the [[PHP SDK]] to create PHP pages that can be called by this function. See the PHP SDK page for an example.\nIn addition, it is possible to use this function to get information about a resource in the MTA community, besides other things. Check out the [[Community Resources]] article.\nIn the case when the call fails, a string containing "ERROR" followed by an integer containing the error reason will be passed to the callback function. The reason for failure will be similar to errors found with websites - file not found, server not found and timeouts.', arguments={'host': 'This is a host name - including the HTTP port - of the server you wish to connect to.', 'resourceName': 'This is a name of the resource that contains the exported function you want to call.', 'functionName': 'This is a string with the name of the function which you want to call.', 'URL': 'A full URL in the format <nowiki>http://hostname/path/file.ext</nowiki>. A port can be specified with a colon followed by a port number appended to the hostname.', 'callbackFunction': 'This is the function that should receive the data returned from the remote function call. The argument list should match the format of the data returned. The callback function will be passed a string containing ERROR followed by an integer indicating the error code when an error occurs calling the function. A list of error codes Template:Error_codes_for_callRemote_and_fetchRemote |can be found here.\n{{OptionalArg}} \n{{New items|4.0153|1.5.3-9.11270|', 'queueName': 'Name of the queue to use. Any name can be used. If not set, the queue name is default. Requests in the same queue are processed in order, one at a time.\n}}\n{{New_feature|3.0139|1.3.1|', 'connectionAttempts': 'Number of times to retry if the remote host does not respond. In the case of a non-responding remote server, each connection attempt will timeout after 6 seconds. Therefore, the default setting of 10 connection attempts means it will be 60 seconds before your script gets a callback about the error. Reducing this value to 2 for example, will decrease that period to 12 seconds', 'connectTimeout': 'Number of milliseconds each connection attempt will take before timing out\n}}', 'arguments': 'Any arguments you may want to pass to the function when it is called. Any number of arguments of can be specified, each being passed to the designated function. Most data types can be passed, including tables. The only values that cannot be passed are userdata values such as xmlnodes - elements and resources can be passed though may be misinterpreted on other game servers (or cause warnings).'}, result="Returns ''true'' if the function has been called, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/CallRemote', name='callRemote', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='copyResource', return_types=['resource'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False), FunctionArgument(name='newResourceName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='organizationalDir', argument_type='string', default_value=None, optional=True)]), docs=FunctionDoc(description='This function copies a specified [[resource]] with a new name.', arguments={'theResource': 'the resource which is going to be copied', 'newResourceName': 'the name that the copied resource will receive\n{{OptionalArg}}', 'organizationalDir': ': A string containing the path where the resource should be copied to (e.g. gamemodes/amx).'}, result="Returns the [[resource]] element of the copy. Returns ''false'' if the arguments are incorrect."), oop=None, url=FunctionUrl(url='/wiki/CopyResource', name='copyResource', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createResource', return_types=['resource'], arguments=[FunctionArgument(name='resourceName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='organizationalDir', argument_type='string', default_value=None, optional=True)]), docs=FunctionDoc(description='This function creates an new, empty resource. This creates a directory matching the name you specify on disk, then creates an empty meta.xml file with a <meta> element in it. ', arguments={'resourceName': 'The name of the new resource. This should be a valid file name. Its recommended that you do not have spaces or non-ASCII characters in resource names.\n{{OptionalArg}}', 'organizationalDir': ': A string containing the path where the resource should be created (e.g. gamemodes/amx).'}, result="Returns the [[resource]] element of the new resource if successful, ''false'' otherwise. This could fail if the resource name already is in use, if a directory already exists with the name you've specified (but this isn't a valid resource) or if the name you specify isn't valid. It could also fail if the disk was full or for other similar reasons."), oop=None, url=FunctionUrl(url='/wiki/CreateResource', name='createResource', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='deleteResource', return_types=['bool'], arguments=[FunctionArgument(name='resourceName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function deletes a resource from the MTA memory and moves it to the '''/resources-cache/trash/''' directory.", arguments={'resourceName': 'The name of resource to delete.'}, result="Returns ''true'' if the resource has been deleted successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DeleteResource', name='deleteResource', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResourceACLRequests', return_types=['table'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the ACL request section from the meta.xml file of the given resource.', arguments={'theResource': 'the resource to get the ACL requests for.'}, result="Returns a ''table'' with the ACL requests for the given resource, or ''false'' if the resource is not valid. A valid resource with no ACL requests will return an empty table."), oop=None, url=FunctionUrl(url='/wiki/GetResourceACLRequests', name='getResourceACLRequests', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResourceInfo', return_types=['string'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False), FunctionArgument(name='attribute', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the value of any attribute in a resource info tag.', arguments={'theResource': 'the resource we are getting the info from.', 'attribute': 'the name of the attribute we want info about.'}, result="Returns a ''string'' with the attribute value if it exists, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetResourceInfo', name='getResourceInfo', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResourceLastStartTime', return_types=['int'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description='Used to check the last starting time and date of a resource', arguments={'theResource': 'The resource of which youd like to check the last starting time.'}, result='{{New feature/item|3|1.0|840|\nIf successful, returns the UNIX timestamp when the resource was last started, or the string "never" if the resource has not been started yet, otherwise false. Use in conjunction with [[getRealTime]] in order to retrieve detailed information. \n}}\n{{Deprecated_feature|3|1.0|\nReturns a string with the time and date, or false if the resource does not exist.\n}}'), oop=None, url=FunctionUrl(url='/wiki/GetResourceLastStartTime', name='getResourceLastStartTime', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResourceLoadFailureReason', return_types=['string'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the reason why a resource failed to start.', arguments={'theResource': 'The resource you wish to check.'}, result="If the resource failed to load, returns a string with the failure reason in it. If it loaded successfully, returns an empty string. Returns ''false'' if the resource doesn't exist."), oop=None, url=FunctionUrl(url='/wiki/GetResourceLoadFailureReason', name='getResourceLoadFailureReason', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResourceLoadTime', return_types=['int'], arguments=[FunctionArgument(name='res', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the date and time at which a resource was last loaded in the server.', arguments={'res': 'the resource you want to know the load time of.'}, result='{{New feature|3|1.0 r840|\nIf successful, returns the UNIX timestamp when the resource was loaded, otherwise false. Use in conjunction with [[getRealTime]] in order to retrieve detailed information. \n}}\n{{Deprecated_feature|3|1.0|\nIf successful, returns a string with the date and time that the resource was last loaded into memory (for example when the server started, or when the resource was changed and reloaded). Returns \'\'false\'\' on failure.\nAn example string is "Fri Mar 28 13:51:04 2008".\n}}'), oop=None, url=FunctionUrl(url='/wiki/GetResourceLoadTime', name='getResourceLoadTime', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResourceMapRootElement', return_types=['element'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False), FunctionArgument(name='mapName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the root element of a certain [[map]] in a specified [[resource]].', arguments={'theResource': 'the resource where the map is located', 'mapName': 'name of the maps which root element we want to retrieve, file extension is required'}, result="Returns an the resource's map root [[element]] if the map exists and resource specified was valid and active (currently running), ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetResourceMapRootElement', name='getResourceMapRootElement', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResourceOrganizationalPath', return_types=['string'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description="This function returns the organizational file path (e.g. ''[admin]'') of a resource.", arguments={'theResource': 'the resource of which you want to know the organizational path'}, result="Returns the organizational folder name of the [[resource]]. It returns empty string if the resource is on root ''resources'' folder. It returns '''false''' if the resource could not be found."), oop=None, url=FunctionUrl(url='/wiki/GetResourceOrganizationalPath', name='getResourceOrganizationalPath', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResources', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function retrieves a table of all the resources that exist on the server.', arguments={}, result='Returns a table of resources.'), oop=None, url=FunctionUrl(url='/wiki/GetResources', name='getResources', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isResourceArchived', return_types=['bool'], arguments=[FunctionArgument(name='resourceElement', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description='Checks whether a resource is currently archived (running from within a ZIP file).\n}}', arguments={'resource': 'the resource to check'}, result="Returns ''true'' if a resource is archived, ''false'' if it is not archived, or ''nil'' if there is problem with resource."), oop=FunctionOOP(class_name='resource', method_name='isArchived', field='archived'), url=FunctionUrl(url='/wiki/IsResourceArchived', name='isResourceArchived', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isResourceProtected', return_types=['bool'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis will check if a resource is currently protected, as defined in [[Server_mtaserver.conf#resource|mtaserver.conf]].\n}}", arguments={'theResource': 'the resource to check'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the resource is 'protected', ''false'' otherwise."), oop=FunctionOOP(class_name='resource', method_name='isProtected', field="protected}}\n===Required Arguments=== \n<!-- List each argument one per line. This should be the argument's name as in the argument list above, NOT the argument's data type -->\n*'''theResource:''' the resource to check\n\n===Returns===\n<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the resource is 'protected', ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/IsResourceProtected', name='isResourceProtected', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='refreshResources', return_types=['bool'], arguments=[FunctionArgument(name='refreshAll', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='targetResource', argument_type='resource', default_value='nil', optional=False)]), docs=FunctionDoc(description='This function finds new resources and checks for changes to the current ones.', arguments={'refreshAll': ': If true MTA will check for changes in all resources. If false, MTA will only check for new resources and try to reload resources with errors\n{{New items|5.0155|1.5.5-9.11718|', 'targetResource': ": If set, the refresh is restricted to the supplied resource only\n}}\n'''Note:''' Checking for changes in all resources can result in lag for a short period of time. It should generally be avoided to set refreshAll to ''true''."}, result='Returns true if refresh was successful, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/RefreshResources', name='refreshResources', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removeResourceFile', return_types=['bool'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False), FunctionArgument(name='fileName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function removes a file from the resource.', arguments={'theResource': 'The resource element.', 'fileName': 'The filename what you want to delete.'}, result="Returns ''true'' if file was deleted, otherwise ''false'' if the resource is in use or the file doesn't exist."), oop=None, url=FunctionUrl(url='/wiki/RemoveResourceFile', name='removeResourceFile', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='renameResource', return_types=['bool'], arguments=[FunctionArgument(name='resource', argument_type='string', default_value=None, optional=False), FunctionArgument(name='newResourceName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='organizationalPath', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function renames a resource.', arguments={'theResource': 'The name of resource or the resource you want to rename.', 'newResourceName': 'The name of what the resource should be renamed to.', 'organizationalPath': 'If you want to store the new resource inside a category.'}, result="Returns ''true'' if the resource has been renamed successfully, ''false'' otherwise. This could fail if the resource name already is in use, if a directory already exists with the name you've specified (but this isn't a valid resource) or if the name you specify isn't valid. It could also fail if the disk was full or for other similar reasons. Won't work on a started resource or if the resource is not loaded (not known by MTA (use /refresh))"), oop=None, url=FunctionUrl(url='/wiki/RenameResource', name='renameResource', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='restartResource', return_types=['bool'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False), FunctionArgument(name='persistent', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='configs', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='maps', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='scripts', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='html', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='clientConfigs', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='clientScripts', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='clientFiles', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description="This function restarts a running resource. Restarting will destroy all the elements that the resource has created (as stopping the resource does).\n*Don't forget to give admin rights to the resource, in which you are using restartResource function or it won't work.\n*This function does not restart the resource immediately. Restarts are queued up until the end of the server's frame to ensure that they occur in the correct order (and that dependent resources can start and stop correctly). The resource being restarted will have an [[onResourceStop]] event triggered and the restarted instance will receive an [[onResourceStart]] event. Remember that the element and resource variables will be invalidated during the restart, though of course, the resource's name will not.}}", arguments={'theResource': 'the resource you want to restart.', 'persistent': 'Unused', 'configs': 'Reload configs?', 'maps': 'Reload maps?', 'scripts': 'Reload (server) scripts?', 'html': 'Reload html files (for resource web access)?', 'clientConfigs': 'Reload client configs?', 'clientScripts': 'Reload client scripts?', 'clientFiles': 'Reload files?'}, result="Returns ''true'' if the resource was restarted, ''false'' if the resource wasn't running, or an invalid resource was passed."), oop=None, url=FunctionUrl(url='/wiki/RestartResource', name='restartResource', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setResourceInfo', return_types=['bool'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False), FunctionArgument(name='attribute', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the value of any attribute in a resource info tag.', arguments={'theResource': 'the resource we are setting info to.', 'attribute': 'the name of the attribute that is to be set.', 'value': 'the value of this attribute'}, result="Returns ''true'' if the info was successfully set, ''false'' otherwise"), oop=None, url=FunctionUrl(url='/wiki/SetResourceInfo', name='setResourceInfo', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='startResource', return_types=['bool'], arguments=[FunctionArgument(name='resourceToStart', argument_type='resource', default_value=None, optional=False), FunctionArgument(name='persistent', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='startIncludedResources', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='loadServerConfigs', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='loadMaps', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='loadServerScripts', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='loadHTML', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='loadClientConfigs', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='loadClientScripts', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='loadFiles', argument_type='bool', default_value='true', optional=False)]), docs=FunctionDoc(description="This function starts a resource either persistently or as a dependency of the current resource. If you start the resource persistently, the resource will run until stopped either using [[stopResource]] or by the server admin. A resource started as a dependency will stop when your resource stops, if no other resources have it as a depdendency. This is the same effect as using an ''include'' in your [[meta.xml]] file.\nThe function also allows you to specify a number of boolean options. These allow you to disable the loading of various aspects of the resource. This is generally useful for editors rather than for actual gamemodes. It could also be used as a way to preview a resource before enabling the scripting aspects, though this could produce unreliable results. There is no way for a resource to tell if it is being run with any of these booleans set.", arguments={'resourceToStart': 'The resource that should be started.\n{{OptionalArg}} ', 'persistent': 'A boolean specifying if the resource should continue to run even after the current resource has been stopped or not. If this is true then the resource will run until another resource or user terminates it or the server shuts down. If this is false then resourceToStart will stop when thisResource stops.', 'startIncludedResources': 'A boolean specifying if the resources included/dependant resources will be started.', 'loadServerConfigs': 'A boolean specifying if server side config (XML) files should be loaded with the resource.', 'loadMaps': 'A boolean specifying if any .map files will be started with the resource.', 'loadServerScripts': 'A boolean specifying if server side script files should be started alongside the resource.', 'loadHTML': 'A boolean specifying if HTML files should be started alongside the resource.', 'loadClientConfigs': 'A boolean specifying if client configs should be loaded alongside the resource.', 'loadClientScripts': 'A boolean specifying if client scripts should be loaded and started alongside the resource.', 'loadFiles': 'A boolean specifying if client-side files should be loaded alongside the resource.'}, result="Returns ''true'' if the resource has been started successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/StartResource', name='startResource', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='stopResource', return_types=['bool'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description='This function stops a running resource.<br>', arguments={'theResource': 'the resource that should be stopped.'}, result="Returns ''true'' if the resource was stopped, ''false'' if the stopping failed, or an invalid resource was passed."), oop=None, url=FunctionUrl(url='/wiki/StopResource', name='stopResource', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='updateResourceACLRequest', return_types=['bool'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False), FunctionArgument(name='rightName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='access', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='byWho', argument_type='string', default_value='""', optional=True)]), docs=FunctionDoc(description='This function changes the access for one ACL request of the given resource.', arguments={'theResource': 'the resource to set the ACL request for.', 'rightName': 'a string with the name of the right to set the access for. This has to match an existing ACL request.', 'access': 'a boolean value setting the access. True is for allow, and false for deny.', 'byWho': 'a string value to identity who is changing the setting.'}, result="Returns true if the setting was changed, or ''false'' if no change was required or there was a problem with the arguments."), oop=None, url=FunctionUrl(url='/wiki/UpdateResourceACLRequest', name='updateResourceACLRequest', category='Resource functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getMaxPlayers', return_types=['int'], arguments=[]), docs=FunctionDoc(description='This function returns the maximum number of player slots on the server.', arguments={}, result='Returns the maximum number of players allowed on the server.'), oop=None, url=FunctionUrl(url='/wiki/GetMaxPlayers', name='getMaxPlayers', category='Server functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getServerHttpPort', return_types=['int'], arguments=[]), docs=FunctionDoc(description="This function retrieves the server's HTTP port.", arguments={}, result="An integer corresponding to the server's HTTP port."), oop=None, url=FunctionUrl(url='/wiki/GetServerHttpPort', name='getServerHttpPort', category='Server functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getServerName', return_types=['string'], arguments=[]), docs=FunctionDoc(description="This function retrieves the server's name.", arguments={}, result="A string containing the server's name."), oop=None, url=FunctionUrl(url='/wiki/GetServerName', name='getServerName', category='Server functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getServerPassword', return_types=['string'], arguments=[]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function returns the current password required to join the server.", arguments={}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns the current server password as a string if it has a password, if not it returns ''nil''."), oop=None, url=FunctionUrl(url='/wiki/GetServerPassword', name='getServerPassword', category='Server functions', function_type=ListType.SERVER)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getServerPort', return_types=['int'], arguments=[]), docs=FunctionDoc(description="This function retrieves the server's port.", arguments={}, result="An integer corresponding to the server's port."), oop=None, url=FunctionUrl(url='/wiki/GetServerPort', name='getServerPort', category='Server functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isGlitchEnabled', return_types=['bool'], arguments=[FunctionArgument(name='glitchName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves whether San Andreas game glitches are enabled or not, set by using [[setGlitchEnabled]]', arguments={'glitchName': 'the name of the property to set. Possible values are:\n{{Glitches}}'}, result="Returns ''true'' if if the glitch was enabled, or ''false'' if it is disabled."), oop=None, url=FunctionUrl(url='/wiki/IsGlitchEnabled', name='isGlitchEnabled', category='Server functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setGlitchEnabled', return_types=['bool'], arguments=[FunctionArgument(name='glitchName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='enable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function enables or disables glitches that are found in the original Single Player game that can be used to gain an advantage in multiplayer. \nUsers of the '''fastmove''' glitch may additionally want to install [https://community.mtasa.com/index.php?p=resources&s=details&id=13368 this resource to disable crouchsliding]. ", arguments={'glitchName': 'the name of the property to set. Possible values are:\n{{Glitches}}', 'enable': 'whether or not to enable the glitch.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetGlitchEnabled', name='setGlitchEnabled', category='Server functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setMaxPlayers', return_types=['bool'], arguments=[FunctionArgument(name='slots', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the maximum number of player slots on the server.', arguments={'slots': 'Maximum number of player slots on the server.'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if number of player slots was successfully changed, ''false'' or ''nil'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetMaxPlayers', name='setMaxPlayers', category='Server functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setServerPassword', return_types=['bool'], arguments=[FunctionArgument(name='thePassword', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function changes the password required to join the server to the given string.", arguments={'thePassword': 'The new server password you want. Pass nil or an empty string to remove the password.'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the password was successfully changed or removed, ''false'' or ''nil'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetServerPassword', name='setServerPassword', category='Server functions', function_type=ListType.SERVER)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='shutdown', return_types=['bool'], arguments=[FunctionArgument(name='reason', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function shuts down the server. \nMake sure your server ACL setup has function.shutdown object protected.', arguments={'reason': 'the reason why the server has been shut down.'}, result="Returns ''false'' if it was not possible to shut down the server."), oop=None, url=FunctionUrl(url='/wiki/Shutdown', name='shutdown', category='Server functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='get', return_types=['var'], arguments=[FunctionArgument(name='settingName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets a setting's value, or a group of settings' values, from the [[settings system|settings registry]].", arguments={}, result='Returns the value of the setting if a single setting was specified and found, or a \'\'table\'\' (in associative-array form) containing:\n*the list of global setting name/value pairs if "." is passed as a setting name,\n*the list of resource settings if a resource name followed by a "." is passed,\n*the list of the script\'s resource settings if an empty string is passed.\nIt returns \'\'false\'\' if the specified setting or settings group doesn\'t exist, or if the settings group you are trying to retrieve doesn\'t have any public or protected settings.'), oop=None, url=FunctionUrl(url='/wiki/Get', name='get', category='Settings registry functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='set', return_types=['bool'], arguments=[FunctionArgument(name='settingName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='var', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to save arbitrary data under a certain name on the [[settings system|settings registry]].\nIt's important to note that set ''always'' writes to the settings.xml file, even if [[get]] read the value from a resource's meta.xml. This means that the admin can specify settings in the settings.xml that override the resource's defaults, but that the defaults can still be retrieved if need be. As a general principle, resources should not be designed so that the admin is required to modify them, they should be 'black boxes'.", arguments={'settingName': 'The name of the setting you want to set. See settings system#Setting names|setting names for information on settings names.', 'value': 'The value to set the setting to. This can be any Lua data type, except for functions, most userdata (only resources cant be stored) and threads.'}, result="Returns ''true'' if the setting has been set, ''false'' if you do not have access to the setting or invalid arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/Set', name='set', category='Settings registry functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='executeSQLQuery', return_types=['table'], arguments=[FunctionArgument(name='query', argument_type='string', default_value=None, optional=False), FunctionArgument(name='param1', argument_type='var', default_value=None, optional=True), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function executes an arbitrary SQL query and returns the result rows if there are any. It allows parameter binding for security (SQL injection is rendered impossible).', arguments={'query': 'An SQL query. Positions where parameter values will be inserted are marked with a ?.', 'paramX': "A variable number of parameters. These must be strings or numbers - it is important to make sure they are of the correct type. Also, the number of parameters passed must be equal to the number of ? characters in the query string.\nString parameters are automatically escaped by adding a backslash (\\) before ' and \\ characters."}, result='Returns a table with the result of the query if it was a SELECT query, or \'\'false\'\' if otherwise. In case of a SELECT query the result table may be empty (if there are no result rows). The table is of the form:\n<syntaxhighlight lang="lua">\n{\n    { colname1=value1, colname2=value2, ... },\n    { colname1=value3, colname2=value4, ... },\n    ...\n}\n</syntaxhighlight>\nA subsequent table represents the next row.'), oop=None, url=FunctionUrl(url='/wiki/ExecuteSQLQuery', name='executeSQLQuery', category='SQL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='dbConnect', return_types=['element'], arguments=[FunctionArgument(name='databaseType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='host', argument_type='string', default_value=None, optional=False), FunctionArgument(name='username', argument_type='string', default_value='""', optional=True), FunctionArgument(name='password', argument_type='string', default_value='""', optional=True), FunctionArgument(name='options', argument_type='string', default_value='""', optional=True)]), docs=FunctionDoc(description='This function opens a connection to a database and returns an element that can be used with [[dbQuery]]. To disconnect use [[destroyElement]].', arguments={'databaseType': 'The type of database. This can be either sqlite or mysql', 'host': ': Host address e.g. host=127.0.0.1', 'dbname': ': Name of the database to use e.g. dbname=test', 'port': ': Host port e.g. port=1234 (optional, defaults to standard MySQL port if not used)', 'unix_socket': ': Unix socket or named pipe to use (optional)', 'charset': ': Communicate with the server using a character which is different from the default e.g. charset<nowiki>=</nowiki>utf8 (optional)', 'username': 'Usually required for MySQL, ignored by SQLite', 'password': 'Usually required for MySQL, ignored by SQLite', 'options ': 'List of key=value pairs separated by semicolons. Supported keys are:', 'share': 'which can be set to 0 or 1. (Default value for SQLite is share=1, for MySQL is share=0). When set to 1, the connection is shared and will be used by other calls to dbConnect with the same host string. This is usually a good thing for SQLite connections, but not so good for MySQL unless care is taken.', 'batch': 'which can be set to 0 or 1. (Default is batch=1). When set to 1, queries called in the same frame are automatically batched together which can significantly speed up inserts/updates. The downside is you lose control of the feature that is used to achieve batching (For SQLite it is transactions, for MySQL it is autocommit mode). Therefore, if you use transactions, lock tables or control autocommit yourself, you may want to disable this feature.', 'autoreconnect': 'which can be set to 0 or 1. (Default value autoreconnect=1). When set to 1, dropped connections will automatically be reconnected. Note that session variables (incl. SET NAMES), user variables, table locks and temporary tables will be reset because of the reconnection. So if you use these fancy features, you will need to turn autoreconnect off and cope with dropped connections some other way.', 'log': 'which can be set to 0 or 1. (Default value log<nowiki>=</nowiki>1). When set to 0, activity from this connection will not be recorded in the Server_Commands#debugdb|database debug log file.', 'tag': '(Default value tag<nowiki>=</nowiki>script). A string which helps identify activity from this connection in the Server_Commands#debugdb|database debug log file.', 'suppress': 'A comma separated list of error codes to ignore. (eg. suppress<nowiki>=</nowiki>1062,1169).', 'multi_statements': 'Enable multiple statements (separated by a semi-colon) in one query. Use dbPrepareString when building a multiple statement query to reduce SQL injection risks.', 'queue': 'Name of the queue to use. (Default value for SQLite is sqlite, for MySQL default is the host string from the host argument). Asynchronous database queries in the same queue are processed in order, one at a time. Any name can be used.'}, result="Returns a database connection element unless there are problems, in which case it return ''false''."), oop=None, url=FunctionUrl(url='/wiki/DbConnect', name='dbConnect', category='SQL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='dbExec', return_types=['bool'], arguments=[FunctionArgument(name='databaseConnection', argument_type='element', default_value=None, optional=False), FunctionArgument(name='query', argument_type='string', default_value=None, optional=False), FunctionArgument(name='param1', argument_type='var', default_value=None, optional=True), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function executes a database query using the supplied connection. No result is returned.', arguments={'databaseConnection': 'A database connection element previously returned from dbConnect', 'query': 'An SQL query. Positions where parameter values will be inserted are marked with a ?', 'paramX': "A variable number of parameters. These must be strings or numbers - it is important to make sure they are of the correct type. Also, the number of parameters passed must be equal to the number of ? characters in the query string.\nString parameters are automatically quoted and escaped as required. (If you do not want a string quoted, use '''??''') Make sure that numbers are in number format as a string number is treated differently."}, result="Returns ''true'' unless the connection is incorrect, in which case it returns ''false''."), oop=None, url=FunctionUrl(url='/wiki/DbExec', name='dbExec', category='SQL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='dbFree', return_types=['bool'], arguments=[FunctionArgument(name='queryHandle', argument_type='handle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function frees a database query handle. dbFree only needs to be used if a result has not been obtained with [[dbPoll]]', arguments={'queryHandle': 'A query handle previously returned from dbQuery'}, result="Returns ''true'' if the handle was successfully freed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DbFree', name='dbFree', category='SQL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='dbPoll', return_types=['table'], arguments=[FunctionArgument(name='queryHandle', argument_type='handle', default_value=None, optional=False), FunctionArgument(name='timeout', argument_type='int', default_value=None, optional=False), FunctionArgument(name='multipleResults', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function checks the progress of a database query.', arguments={'queryHandle': 'A query handle previously returned from dbQuery', 'timeout': 'How many milliseconds to wait for a result. Use 0 for an instant response (which may return nil). Use -1 to wait until a result is ready. Note: A wait here will freeze the entire server just like executeSQLQuery\n{{Important Note|It is strongly recommended to use this function in callback, as presented in "This example shows how to obtain data without server freeze."}}\n{{New items|3.0152|1.5.2|', 'multipleResults': 'Set to true to enable the return values from multiple queries\n|7972}}'}, result='*\'\'nil:\'\' Returns nil if the query results are not yet ready. You should try again in a little while. (If you give up waiting for a result, be sure to call [[dbFree]])\n*\'\'false:\'\' Returns false if the query string contained an error, the connection has been lost or the query handle is incorrect. This automatically frees the query handle, so you do not have to call [[dbFree]].\n** This also returns two extra values: (See the example on how the retrieve them)\n***\'\'int:\'\' error code\n***\'\'string\'\' error message\n*\'\'table:\'\' Returns a table with the result of the query when the query has successfully completed. This automatically frees the query handle, so you do not have to call [[dbFree]]. If multipleResults is set to true, it will first return a table pertaining to one query, followed by the results for that query and so on for the next queries.\n** This also returns extra values (only when multipleResults is set to true):\n***\'\'int:\'\' number of affected rows\n***\'\'int:\'\' last insert id\nThe table is of the format:\n<syntaxhighlight lang="lua">\n{\n    { colname1=value1, colname2=value2, ... },\n    { colname1=value3, colname2=value4, ... },\n    ...\n}\n</syntaxhighlight>\nA subsequent table represents the next row.\n{{Note|If a column contained a number it is returned as a number, this includes things which were stored as string but are numbers such as "1" would be returned as 1.}}'), oop=None, url=FunctionUrl(url='/wiki/DbPoll', name='dbPoll', category='SQL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='dbPrepareString', return_types=['string'], arguments=[FunctionArgument(name='databaseConnection', argument_type='element', default_value=None, optional=False), FunctionArgument(name='query', argument_type='string', default_value=None, optional=False), FunctionArgument(name='param1', argument_type='var', default_value=None, optional=True), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function escapes arguments in the same way as [[dbQuery]], except dbPrepareString returns the query string instead of processing the query. This allows you to safely build complex query strings from component parts and help prevent (one class of) SQL injection.}}', arguments={'databaseConnection': 'A database connection element previously returned from dbConnect', 'query': 'An SQL query. Positions where parameter values will be inserted are marked with a ?', 'paramX': "A variable number of parameters. These must be strings or numbers - it is important to make sure they are of the correct type. Also, the number of parameters passed must be equal to the number of ? characters in the query string.\nString parameters are automatically quoted and escaped as required. (If you do not want a string quoted, use '''??''')"}, result="Returns a prepare SQL query string, or ''false'' if an error occurred."), oop=None, url=FunctionUrl(url='/wiki/DbPrepareString', name='dbPrepareString', category='SQL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='dbQuery', return_types=['handle'], arguments=[FunctionArgument(name='callbackFunction', argument_type='function', default_value=None, optional=False), FunctionArgument(name='callbackArguments', argument_type='table', default_value=None, optional=False), FunctionArgument(name='databaseConnection', argument_type='element', default_value=None, optional=False), FunctionArgument(name='query', argument_type='string', default_value=None, optional=False), FunctionArgument(name='param1', argument_type='var', default_value=None, optional=True), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description="This function starts a database query using the supplied connection. Use the returned query handle with [[dbPoll]] to get the result, or [[dbFree]] if you don't want the result.", arguments={'databaseConnection': 'A database connection element previously returned from dbConnect', 'query': 'An SQL query. Positions where parameter values will be inserted are marked with a ?', 'callbackFunction': 'An optional function to be called when a result is ready. The function will only be called if the result has not already been read with dbPoll. The function is called with the query handle as the first argument.', 'callbackArguments': 'An optional table containing extra arguments to be sent to the callback function.', 'paramX': "A variable number of parameters. These must be strings or numbers - it is important to make sure they are of the correct type. Also, the number of parameters passed must be equal to the number of ? characters in the query string.\nString parameters are automatically quoted and escaped as required. (If you do not want a string quoted, use '''??''')"}, result="Returns a query handle unless the connection is incorrect, in which case it return ''false''."), oop=None, url=FunctionUrl(url='/wiki/DbQuery', name='dbQuery', category='SQL functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createTeam', return_types=['team'], arguments=[FunctionArgument(name='teamName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='colorR', argument_type='int', default_value='255', optional=True), FunctionArgument(name='colorG', argument_type='int', default_value='255', optional=True), FunctionArgument(name='colorB', argument_type='int', default_value='255', optional=True)]), docs=FunctionDoc(description='This function is for creating a new [[team]], which can be used to group players. Players will not join the team until they are respawned.', arguments={'teamName': 'A string representing the teams name.', 'colorR': 'An integer representing the red color value.', 'colorG': 'An integer representing the green color value.', 'colorB': 'An integer representing the blue color value.'}, result="Returns a team element if it was successfully created, ''false'' if invalid arguments are passed or a team with that name already exists."), oop=None, url=FunctionUrl(url='/wiki/CreateTeam', name='createTeam', category='Team functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerTeam', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False)]), docs=FunctionDoc(description="This function adds a [[player]] to an existing [[team]]. The player will automatically be removed from his current team if he's on one.", arguments={'thePlayer': 'The player you wish to add to a team.', 'theTeam': 'The team you want to add the player to, or nil if you wish to unassign a player from his team.'}, result="Returns ''true'' if the player was successfully added to the specified team or removed from his previous one, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='setTeam', field='team'), url=FunctionUrl(url='/wiki/SetPlayerTeam', name='setPlayerTeam', category='Team functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setTeamColor', return_types=['bool'], arguments=[FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False), FunctionArgument(name='colorR', argument_type='int', default_value=None, optional=False), FunctionArgument(name='colorG', argument_type='int', default_value=None, optional=False), FunctionArgument(name='colorB', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is for setting the color of a specified team. This color is shown, for example, in the team players' nametags.", arguments={'theTeam': 'The team you want to change the color of.', 'colorR': 'An integer representing the red color value, from 0 to 255.', 'colorG': 'An integer representing the green color value, from 0 to 255.', 'colorB': 'An integer representing the blue color value, from 0 to 255.'}, result="Returns ''true'' if the team is valid and the color is different, otherwise ''false''."), oop=FunctionOOP(class_name='team', method_name='setColor', field=None), url=FunctionUrl(url='/wiki/SetTeamColor', name='setTeamColor', category='Team functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setTeamFriendlyFire', return_types=['bool'], arguments=[FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False), FunctionArgument(name='friendlyFire', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the friendly fire value for the specified team.', arguments={'theTeam': 'The  team that will have friendly fire set', 'friendlyFire': 'A boolean denoting whether the players from the same team can kill each other (true) or whether the players cant kill each other (false).'}, result="Returns ''true'' if the friendly fire value is set for the specified team, ''false'' if the friendly fire value can't be set for the specified team or if invalid arguments are specified."), oop=FunctionOOP(class_name='team', method_name='setFriendlyFire', field='friendlyFire'), url=FunctionUrl(url='/wiki/SetTeamFriendlyFire', name='setTeamFriendlyFire', category='Team functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setTeamName', return_types=['bool'], arguments=[FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False), FunctionArgument(name='newName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to set a team's name.", arguments={'theTeam': 'The team you want to change the name of.', 'newName': 'A string representing the name you want the team to be called.'}, result="Returns ''true'' if the team was valid and the name was changed, ''false'' otherwise."), oop=FunctionOOP(class_name='team', method_name='setName', field='name'), url=FunctionUrl(url='/wiki/SetTeamName', name='setTeamName', category='Team functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textCreateDisplay', return_types=['textdisplay'], arguments=[]), docs=FunctionDoc(description='A [[textdisplay|text display]] is like a canvas that can contain many [[textitem|items of text]]. Each display can be seen by multiple observers (players) and each player can see multiple displays.', arguments={}, result=''), oop=None, url=FunctionUrl(url='/wiki/TextCreateDisplay', name='textCreateDisplay', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textCreateTextItem', return_types=['textitem'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='priority', argument_type='string', default_value=None, optional=False), FunctionArgument(name='red', argument_type='int', default_value='255', optional=False), FunctionArgument(name='green', argument_type='int', default_value='255', optional=False), FunctionArgument(name='blue', argument_type='int', default_value='255', optional=False), FunctionArgument(name='alpha', argument_type='int', default_value='255', optional=False), FunctionArgument(name='scale', argument_type='float', default_value='1', optional=False), FunctionArgument(name='alignX', argument_type='string', default_value='"left"', optional=False), FunctionArgument(name='alignY', argument_type='string', default_value='"top"', optional=False), FunctionArgument(name='shadowAlpha', argument_type='int', default_value='0', optional=False)]), docs=FunctionDoc(description='This function creates a text item. A text item represents a single area of text, much like a label does in standard GUI programming. A text item can only be seen by players if it is added to a [[textdisplay]] using [[textDisplayAddText]]. Each text item can be added to multiple displays, if need be.', arguments={'text': ': A string of text you want to display', 'x': ': A floating point number between 0.0 and 1.0 indicating how far across the screen the text should be shown, as a percentage of the width, from the left hand side.', 'y': ': A floating point number between 0.0 and 1.0 indicating how far down the screen the text should be shown, as a percentage of the height, from the top.\n{{OptionalArg}}', 'priority': ': How important it is that this text should be up to date on clients screens. Valid values are: low, medium, high which are aliases for 0, 1 and 2 respectively.', 'red': ': A value between 0 and 255 indicating how red the text should be.', 'green': ': A value between 0 and 255 indicating how green the text should be.', 'blue': ': A value between 0 and 255 indicating how blue the text should be.', 'alpha': ': A value between 0 and 255 indicating how transparent the text should be, with 0 being fully transparent, and 255 being opaque.', 'scale': ': A floating point value indicating the scale of the text. The default is 1.0, which is around 12pt.', 'alignX': ': A string representing the X-alignment of the text. (left, center, right)', 'alignY': ': A string representing the Y-alignment of the text. (top, center, bottom)', 'shadowAlpha': ': A value between 0 and 255 indicating how dark the drop shadow should be.'}, result='Returns a [[textitem]] object.'), oop=None, url=FunctionUrl(url='/wiki/TextCreateTextItem', name='textCreateTextItem', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textDestroyDisplay', return_types=['bool'], arguments=[FunctionArgument(name='display', argument_type='textdisplay', default_value=None, optional=False)]), docs=FunctionDoc(description='This function destroys a text display and will unlink all the [[textitem]]s on it. This does not stop the textitems existing, but anyone who was observing the textitems through this display will stop seeing them.', arguments={'display': 'This is the textdisplay that you wish to have destroyed.'}, result=''), oop=None, url=FunctionUrl(url='/wiki/TextDestroyDisplay', name='textDestroyDisplay', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textDestroyTextItem', return_types=['void'], arguments=[FunctionArgument(name='theTextitem', argument_type='textitem', default_value=None, optional=False)]), docs=FunctionDoc(description='This function destroys a [[textitem]] object.', arguments={'theTextitem': 'The text item you wish to destroy.'}, result=''), oop=None, url=FunctionUrl(url='/wiki/TextDestroyTextItem', name='textDestroyTextItem', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textDisplayAddObserver', return_types=['void'], arguments=[FunctionArgument(name='display', argument_type='textdisplay', default_value=None, optional=False), FunctionArgument(name='playerToAdd', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function adds a [[player]] as an observer of a [[textdisplay]]. This allows the [[player]] to see any [[textitem]]s that the [[textdisplay]] contains.', arguments={'display': ': The textdisplay to add the player to as an observer.', 'playerToAdd': ': The player that should observe the textdisplay.'}, result=''), oop=None, url=FunctionUrl(url='/wiki/TextDisplayAddObserver', name='textDisplayAddObserver', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textDisplayAddText', return_types=['void'], arguments=[FunctionArgument(name='displayToAddTo', argument_type='textdisplay', default_value=None, optional=False), FunctionArgument(name='itemToAdd', argument_type='textitem', default_value=None, optional=False)]), docs=FunctionDoc(description='This function adds a [[textitem]] to a [[textdisplay]]. This allows any observers of the [[textdisplay]] to see the [[textitem]].', arguments={'displayToAddTo': ': The textdisplay to add the textitem to.', 'itemToAdd': ': The textitem to add to the display.'}, result=''), oop=None, url=FunctionUrl(url='/wiki/TextDisplayAddText', name='textDisplayAddText', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textDisplayGetObservers', return_types=['table'], arguments=[FunctionArgument(name='theDisplay', argument_type='textdisplay', default_value=None, optional=False)]), docs=FunctionDoc(description='This function can be used to retrieve all the [[player]]s  currently observing a specified [[textdisplay]].', arguments={'theDisplay': ': The textdisplay of which observers you want to get.'}, result="Returns a [[table]] of players that are observers of the display or ''false'' if invalid textdisplay is passed."), oop=None, url=FunctionUrl(url='/wiki/TextDisplayGetObservers', name='textDisplayGetObservers', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textDisplayIsObserver', return_types=['bool'], arguments=[FunctionArgument(name='display', argument_type='textdisplay', default_value=None, optional=False), FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if a player can see the specified [[textdisplay]].', arguments={'display': ': The textdisplay.', 'thePlayer': ': The player.'}, result='Return true if [[textdisplay]] is showing, or false if not.'), oop=None, url=FunctionUrl(url='/wiki/TextDisplayIsObserver', name='textDisplayIsObserver', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textDisplayRemoveObserver', return_types=['bool'], arguments=[FunctionArgument(name='display', argument_type='textdisplay', default_value=None, optional=False), FunctionArgument(name='playerToRemove', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function removes a [[player]] observer of a [[textdisplay]]. This stops the [[player]] from being able to see [[textitem]]s that the [[textdisplay]] contains.', arguments={'display': ': The textdisplay to remove the player from as an observer.', 'playerToRemove': ': The player that should be removed from the textdisplay.'}, result=''), oop=None, url=FunctionUrl(url='/wiki/TextDisplayRemoveObserver', name='textDisplayRemoveObserver', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textDisplayRemoveText', return_types=['void'], arguments=[FunctionArgument(name='displayToRemoveFrom', argument_type='textdisplay', default_value=None, optional=False), FunctionArgument(name='itemToRemove', argument_type='textitem', default_value=None, optional=False)]), docs=FunctionDoc(description='This function removes a [[textitem]] from a [[textdisplay]]. This stops any observers of the [[textdisplay]] from being able to see the [[textitem]].', arguments={'displayToRemoveFrom': ': The textdisplay to remove the textitem from.', 'itemToRemove': ': The textitem to remove from the display.'}, result=''), oop=None, url=FunctionUrl(url='/wiki/TextDisplayRemoveText', name='textDisplayRemoveText', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textItemGetColor', return_types=['int', 'int', 'int', 'int'], arguments=[FunctionArgument(name='theTextItem', argument_type='textitem', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to retrieve the color of a text item.', arguments={'theTextItem': 'The text item you wish to retrieve the color of.'}, result="Returns four integers in RGBA format, with a maximum value of 255 for each. The values are, in order, ''red'', ''green'', ''blue'', and ''alpha''. Alpha decides transparency where 255 is opaque and 0 is transparent. ''false'' is returned if the text item is invalid."), oop=None, url=FunctionUrl(url='/wiki/TextItemGetColor', name='textItemGetColor', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textItemGetPosition', return_types=['float', 'float'], arguments=[FunctionArgument(name='theTextItem', argument_type='textitem', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows retrieval of the position of a text item.', arguments={'theTextItem': 'The textitem you wish to retrieve the position of'}, result="Returns two floats of the ''x'' and ''y'' position on the screen, where the maximum value is 1.0."), oop=None, url=FunctionUrl(url='/wiki/TextItemGetPosition', name='textItemGetPosition', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textItemGetPriority', return_types=['int'], arguments=[FunctionArgument(name='textitemToCheck', argument_type='textitem', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the priority of a text item.  Priority defines the rate at whihc a text item is updated', arguments={'textitemToCheck': 'The text item you wish to retrieve the priority of.'}, result='Returns a integer of the priority of a text item, 0 = low, 1 = medium, 2 = high.'), oop=None, url=FunctionUrl(url='/wiki/TextItemGetPriority', name='textItemGetPriority', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textItemGetScale', return_types=['float'], arguments=[FunctionArgument(name='theTextitem', argument_type='textitem', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows retrieval of the scale or size of a text item.', arguments={'theTextitem': 'The text item you wish to retrieve the scale of'}, result='Returns a floating point of the scale of the text. 1.0 is around 12pt.'), oop=None, url=FunctionUrl(url='/wiki/TextItemGetScale', name='textItemGetScale', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textItemGetText', return_types=['string'], arguments=[FunctionArgument(name='theTextitem', argument_type='textitem', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current text of the specified [[textitem]].', arguments={'theTextitem': 'A valid textitem.'}, result="Returns a [[string]] containing the text if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/TextItemGetText', name='textItemGetText', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textItemSetColor', return_types=['bool'], arguments=[FunctionArgument(name='theTextItem', argument_type='textitem', default_value=None, optional=False), FunctionArgument(name='r', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b', argument_type='int', default_value=None, optional=False), FunctionArgument(name='a', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the color of a text item.', arguments={'theTextItem': 'The textitem you wish to set the color of.', 'red': 'The amount of red in the text items color (0 - 255).', 'green': 'The amount of green in the text items color (0 - 255).', 'blue': 'The amount of blue in the text items color (0 - 255).', 'alpha': 'The amount of alpha in the text items color (0 - 255). Alpha decides transparency where 255 is opaque and 0 is transparent.'}, result="Returns ''true'' if the color was successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/TextItemSetColor', name='textItemSetColor', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textItemSetPosition', return_types=['bool'], arguments=[FunctionArgument(name='theTextItem', argument_type='textitem', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows the setting of the position of a text item.', arguments={'theTextItem': 'The text item that you want to move', 'x': 'A floating point number between 0.0 and 1.0 indicating how far across the screen the text should be shown, as a percentage of the width, from the left hand side.', 'y': 'A floating point number between 0.0 and 1.0 indicating how far down the screen the text should be shown, as a percentage of the height, from the top.'}, result="Returns ''true'' if the position was successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/TextItemSetPosition', name='textItemSetPosition', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textItemSetPriority', return_types=['void'], arguments=[FunctionArgument(name='theTextItem', argument_type='textitem', default_value=None, optional=False), FunctionArgument(name='priority', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the priority for a text item.  Priority is the importance of sending updated text to the client. The system is implemented as 3 queues, with the ''high'' queue being emptied before the ''medium'' queue is processed, and with one update sent per server frame. Hence, if you set all your text items to ''medium'' priority it has the same effect as if you set them all to ''high'' or ''low''.", arguments={'theTextItem': 'The text item you wish to set priority to.', 'priority': 'The priority you wish to set to the item, which can be high, medium, or low respective of their priority.'}, result=''), oop=None, url=FunctionUrl(url='/wiki/TextItemSetPriority', name='textItemSetPriority', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textItemSetScale', return_types=['bool'], arguments=[FunctionArgument(name='theTextitem', argument_type='textitem', default_value=None, optional=False), FunctionArgument(name='scale', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows the setting of the scale of a text item.', arguments={'theTextitem': 'The text item you wish to set the scale of.', 'scale': 'A floating point value indicating the scale of the text you wish to set to. 1.0 is around 12pt.'}, result="Returns ''true'' if the scale was successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/TextItemSetScale', name='textItemSetScale', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='textItemSetText', return_types=['void'], arguments=[FunctionArgument(name='theTextitem', argument_type='textitem', default_value=None, optional=False), FunctionArgument(name='text', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Overwrites a previously created text item with the specified text.', arguments={'theTextitem': 'An existing text item that was previously created with textCreateTextItem', 'text': 'The new text for the text item'}, result=''), oop=None, url=FunctionUrl(url='/wiki/TextItemSetText', name='textItemSetText', category='Text functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getServerConfigSetting', return_types=['string'], arguments=[FunctionArgument(name='name', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function retrieves server settings which are usually stored in the '''mtaserver.conf''' file.\nAvailable in 1.1 and onwards\n}}", arguments={'name ': 'The name of the setting (setting names can be found Server_mtaserver.conf|here)'}, result='Returns a string containing the current value for the named setting, or \'\'false\'\' if the setting does not exist.<br>\nIf the setting name is \'\'serverip\'\', may return the string \'\'"auto"\'\' on local servers.'), oop=None, url=FunctionUrl(url='/wiki/GetServerConfigSetting', name='getServerConfigSetting', category='Utility functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setServerConfigSetting', return_types=['bool'], arguments=[FunctionArgument(name='name', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='string', default_value=None, optional=False), FunctionArgument(name='bSave', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function sets server settings which are stored in the [[Server mtaserver.conf|mtaserver.conf]] file.', arguments={'name ': 'The name of the setting. Only certain settings from Server mtaserver.conf|mtaserver.conf can be changed with this function. These are:\n** minclientversion\n** recommendedclientversion\n** password\n** fpslimit - (0-100)\n** networkencryption - 0 for off, 1 for on\n** bandwidth_reduction - "none", "medium", "maximum" Set to maximum for less bandwidth usage (medium is recommended for race servers)\n** player_sync_interval - See [[Sync_interval_settings]] for all *_sync_interval settings\n** lightweight_sync_interval\n** camera_sync_interval\n** ped_sync_interval\n** unoccupied_vehicle_sync_interval\n** keysync_mouse_sync_interval\n** keysync_analog_sync_interval\n** bullet_sync', 'value': 'The value of the setting', 'bSave': 'Set to true to make the setting permanent, or false for use only until the next server restart.'}, result="Returns ''true'' if the setting was successfully set, or ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetServerConfigSetting', name='setServerConfigSetting', category='Utility functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='teaDecode', return_types=['string'], arguments=[FunctionArgument(name='data', argument_type='string', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function decrypts given [https://en.wikipedia.org/wiki/Base64 base64] representation of encrypted data using the [https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm Tiny Encryption Algorithm].\n}}', arguments={'data': 'The block of data you want to decrypt', 'key': 'The key that should be used for decryption (Only first 16 characters are used)'}, result="Returns string containing the decrypted data if the decryption process was successfully completed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/TeaDecode', name='teaDecode', category='Utility functions', function_type=ListType.SERVER)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='teaEncode', return_types=['string'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This functions performs the [https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm Tiny Encryption Algorithm] on the given string and returns the [https://en.wikipedia.org/wiki/Base64 base64] representation of the encrypted string.\n}}', arguments={'text': 'The string you want to encrypt. (See second example if you want to encode binary data)', 'key': 'The key that should be used for encryption (Only first 16 characters are used)'}, result="Returns the [https://en.wikipedia.org/wiki/Base64 base64] representation of the encrypted string if the encryption process was successfully completed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/TeaEncode', name='teaEncode', category='Utility functions', function_type=ListType.SERVER)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='addVehicleSirens', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='sirenCount', argument_type='int', default_value=None, optional=False), FunctionArgument(name='sirenType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='360flag', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='checkLosFlag', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='useRandomiser', argument_type='bool', default_value=None, optional=True), FunctionArgument(name='silentFlag', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function adds sirens to a vehicle.\n}}', arguments={'theVehicle': 'The vehicle to add sirens', 'sirenCount': 'The amount of siren points on the vehicle (8 maximum)', 'sirenType': 'An integer between 1 and 6 (1: invisible, 2: single, 3+: dual)', '360flag': 'Visible from all directions (applies to single type only)', 'checkLosFlag': 'Check line of sight between camera and light so it wont draw if blocked', 'useRandomiser': 'Randomise the light order, false for sequential', 'silentFlag': 'If you want the siren to be silent set this to true'}, result="Returns ''true'' if sirens were successfully added to the vehicle, ''false'' otherwise. "), oop=None, url=FunctionUrl(url='/wiki/AddVehicleSirens', name='addVehicleSirens', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getModelHandling', return_types=['table'], arguments=[FunctionArgument(name='modelId', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a table containing the handling data of the specified vehicle model.\nNote: the data returned may not reflect the actual handling of a particular vehicle, since this may be overriden by the [[setVehicleHandling]] function.', arguments={'modelId': 'the vehicle model you wish to get the handling data of.'}, result="Returns a ''table'' containing all the handling data, ''false'' if an invalid vehicle model is specified. Here is a list of valid table properties and what they return:\n{{Handling Properties}}"), oop=None, url=FunctionUrl(url='/wiki/GetModelHandling', name='getModelHandling', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleRespawnPosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theVehicle', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theVehicle': 'The vehicle which youd like to retrieve the respawn coordinates of.'}, result="Returns three [[float|floats]] indicating the respawn coordinates of the [[vehicle]], ''x'', ''y'' and ''z'' respectively."), oop=FunctionOOP(class_name='vehicle', method_name='getRespawnPosition', field='respawnPosition'), url=FunctionUrl(url='/wiki/GetVehicleRespawnPosition', name='getVehicleRespawnPosition', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleRespawnRotation', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theVehicle', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theVehicle': 'The vehicle which youd like to retrieve the respawn rotation of.'}, result="Returns three [[float|floats]] indicating the respawn rotation of the [[vehicle]], ''x'', ''y'' and ''z'' respectively."), oop=FunctionOOP(class_name='vehicle', method_name='getRespawnRotation', field="respawnRotation}}\n\n===Required Arguments===\n*'''theVehicle:''' The [[vehicle]] which you'd like to retrieve the respawn rotation of.\n\n===Returns===\nReturns three [[float"), url=FunctionUrl(url='/wiki/GetVehicleRespawnRotation', name='getVehicleRespawnRotation', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehiclesOfType', return_types=['table'], arguments=[FunctionArgument(name='model', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function scans through all the current vehicles and returns the ones matching the given model.', arguments={'model': ': The model of vehicles you want.'}, result='Returns a table of existing vehicles matching the specified model.'), oop=None, url=FunctionUrl(url='/wiki/GetVehiclesOfType', name='getVehiclesOfType', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removeVehicleSirens', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function removes sirens from a vehicle.\n}}', arguments={'theVehicle': 'The vehicle to remove the sirens of'}, result="Returns ''true'' if sirens were successfully removed from the vehicle, ''false'' otherwise. "), oop=None, url=FunctionUrl(url='/wiki/RemoveVehicleSirens', name='removeVehicleSirens', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetVehicleExplosionTime', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="Resets the vehicle explosion time. This is the point in time at which the vehicle last exploded: at this time plus the vehicle's respawn delay, the vehicle is respawned. You can use this function to prevent the vehicle from respawning.", arguments={'theVehicle': 'The vehicle you wish to reset the explosion time from.'}, result="Returns ''true'' if the vehicle explosion time has been reset, ''false'' if it failed to reset the explosion time."), oop=None, url=FunctionUrl(url='/wiki/ResetVehicleExplosionTime', name='resetVehicleExplosionTime', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetVehicleIdleTime', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='Resets the vehicle idle time', arguments={'theVehicle': 'The vehicle you wish to reset the idle time from.'}, result="Returns ''true'' if the vehicle idle time has been reset, ''false'' if it failed to reset the idle time."), oop=None, url=FunctionUrl(url='/wiki/ResetVehicleIdleTime', name='resetVehicleIdleTime', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='respawnVehicle', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function respawns a vehicle according to its set respawn position, set by [[setVehicleRespawnPosition]] or the position and rotation it was created on. To spawn a vehicle to a specific location just once, [[spawnVehicle]] can be used.', arguments={'theVehicle': 'The vehicle you wish to respawn'}, result="Returns ''true'' if the vehicle respawned successfully, ''false'' if the passed argument does not exist or is not a vehicle."), oop=None, url=FunctionUrl(url='/wiki/RespawnVehicle', name='respawnVehicle', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setModelHandling', return_types=['bool'], arguments=[FunctionArgument(name='modelId', argument_type='int', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='var', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to change the handling data of all vehicles of a specified model.', arguments={'modelId': 'The Vehicle_IDs|vehicle model you wish to set the handling of.', 'property': 'The property you wish to set the handling of the vehicle to, or nil if you want to reset the all the handling properties.', 'value': 'The value of the modelss handling property you wish to set, or nil if you want to reset the handling property to its default value.'}, result="Returns ''true'' if the handling was set successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetModelHandling', name='setModelHandling', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleIdleRespawnDelay', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='timeDelay', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the time delay (in milliseconds) the vehicle will remain at its position while empty.', arguments={'theVehicle': ': The vehicle you wish to change the respawn delay of.', 'timeDelay': ': The number of milliseconds the vehicle will be allowed to remain unused until it respawns.'}, result="Returns ''true'' if the vehicle was found and edited."), oop=FunctionOOP(class_name='vehicle', method_name='setIdleRespawnDelay', field="idleRespawnDelay}}\n===Required Arguments===\n*'''theVehicle''': The [[vehicle]] you wish to change the respawn delay of.\n*'''timeDelay''': The number of milliseconds the vehicle will be allowed to remain unused until it respawns.\n\n==Returns==\nReturns ''true'' if the vehicle was found and edited.\n\n"), url=FunctionUrl(url='/wiki/SetVehicleIdleRespawnDelay', name='setVehicleIdleRespawnDelay', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleRespawnDelay', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='timeDelay', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the time delay (in milliseconds) the vehicle will remain wrecked before respawning.', arguments={'theVehicle': ': The vehicle you wish to change the respawn delay of.', 'timeDelay': ': The amount of milliseconds to delay.'}, result="Returns ''true'' if the vehicle was found and edited."), oop=FunctionOOP(class_name='vehicle', method_name='setRespawnDelay', field="respawnDelay}}\n===Required Arguments===\n*'''theVehicle''': The [[vehicle]] you wish to change the respawn delay of.\n*'''timeDelay''': The amount of milliseconds to delay.\n\n==Returns==\nReturns ''true'' if the vehicle was found and edited.\n\n"), url=FunctionUrl(url='/wiki/SetVehicleRespawnDelay', name='setVehicleRespawnDelay', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleRespawnPosition', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rx', argument_type='float', default_value=None, optional=True), FunctionArgument(name='ry', argument_type='float', default_value=None, optional=True), FunctionArgument(name='rz', argument_type='float', default_value=None, optional=True)]), docs=FunctionDoc(description='This function sets the position (and rotation) the vehicle will respawn to.', arguments={'theVehicle': ': The vehicle you wish to change the respawn position of.', 'x': ': A floating point number representing the X coordinate on the map.', 'y': ': A floating point number representing the Y coordinate on the map.', 'z': ': A floating point number representing the Z coordinate on the map.\n{{OptionalArg}}', 'rx': ': A floating point number representing the rotation about the X axis in Degrees.', 'ry': ': A floating point number representing the rotation about the Y axis in Degrees.', 'rz': ': A floating point number representing the rotation about the Z axis in Degrees.'}, result="Returns ''true'' if the vehicle was found and edited, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setRespawnPosition', field="respawnPosition}}\n===Required Arguments===\n*'''theVehicle''': The [[vehicle]] you wish to change the respawn position of.\n* '''x''': A floating point number representing the X coordinate on the map.\n* '''y''': A floating point number representing the Y coordinate on the map.\n* '''z''': A floating point number representing the Z coordinate on the map.\n\n===Optional Arguments===\n{{OptionalArg}}\n* '''rx''': A floating point number representing the rotation about the X axis in Degrees.\n* '''ry''': A floating point number representing the rotation about the Y axis in Degrees.\n* '''rz''': A floating point number representing the rotation about the Z axis in Degrees.\n\n==Returns==\nReturns ''true'' if the vehicle was found and edited, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/SetVehicleRespawnPosition', name='setVehicleRespawnPosition', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleRespawnRotation', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='rx', argument_type='float', default_value=None, optional=False), FunctionArgument(name='ry', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rz', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the rotation the vehicle will respawn to.\n}}', arguments={'theVehicle': ': The vehicle you wish to change the respawn position of.', 'rx': ': A float representing the rotation about the X axis in degrees.', 'ry': ': A float representing the rotation about the Y axis in degrees.', 'rz': ': A float representing the rotation about the Z axis in degrees.'}, result="Returns ''true'' if the [[vehicle]] respawn rotation was set successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setRespawnRotation', field="respawnRotation}}\n===Required Arguments===\n*'''theVehicle''': The [[vehicle]] you wish to change the respawn position of.\n* '''rx''': A [[float]] representing the rotation about the X axis in degrees.\n* '''ry''': A [[float]] representing the rotation about the Y axis in degrees.\n* '''rz''': A [[float]] representing the rotation about the Z axis in degrees.\n\n==Returns==\nReturns ''true'' if the [[vehicle]] respawn rotation was set successfully, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/SetVehicleRespawnRotation', name='setVehicleRespawnRotation', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='spawnVehicle', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rx', argument_type='float', default_value=None, optional=True), FunctionArgument(name='ry', argument_type='float', default_value=None, optional=True), FunctionArgument(name='rz', argument_type='float', default_value=None, optional=True)]), docs=FunctionDoc(description='Spawns a vehicle at any given position and rotation', arguments={'theVehicle': 'The vehicle you wish to spawn', 'x': 'The x position you wish to spawn the vehicle at', 'y': 'The x position you wish to spawn the vehicle at', 'z': 'The x position you wish to spawn the vehicle at\n{{OptionalArg}} ', 'rx': 'The x rotation you wish to spawn the vehicle at', 'ry': 'The y rotation you wish to spawn the vehicle at', 'rz': 'The z rotation you wish to spawn the vehicle at'}, result="Returns ''true'' if the vehicle spawned successfully, ''false'' if the passed argument does not exist or is not a vehicle."), oop=None, url=FunctionUrl(url='/wiki/SpawnVehicle', name='spawnVehicle', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='toggleVehicleRespawn', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='Respawn', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function toggles whether or not the vehicle will be respawned after blown or idle.', arguments={'theVehicle': ': The vehicle you wish to toggle the respawning of.', 'Respawn': ': A boolean determining if the vehicle will respawn or not.'}, result="Returns ''true'' if the vehicle was found and edited."), oop=None, url=FunctionUrl(url='/wiki/ToggleVehicleRespawn', name='toggleVehicleRespawn', category='Vehicle functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='giveWeapon', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='weapon', argument_type='int', default_value=None, optional=False), FunctionArgument(name='ammo', argument_type='int', default_value='30', optional=True), FunctionArgument(name='setAsCurrent', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="giveWeapon gives a specified weapon to a certain player or ped. There is an optional argument to specify ammunition. For example, a melee weapon doesn't need an ammo argument.\n*When setting ammo for [[Weapon|weapons in slot]] 0,1,10,11 or 12, the ammo max is 1\n*When setting ammo for [[Weapon|weapons in slot]] 3,4,5, the ammo is added\n*When setting ammo for [[Weapon|weapons in slot]] 2,6,7,8,9 and the slot weapon is changing, the ammo is replaced\n}}", arguments={'thePlayer': 'A player or ped object referencing the specified player (or ped)', 'weapon': 'A whole number integer that refers to a Weapon ID. Click Weapon|here for a list of possible weapon IDs.\n{{OptionalArg}} ', 'ammo': 'A whole number integer serving as the ammo amount for the given weapon.  For weapons that do not require ammo, such as melee, this should be at least 1.', 'setAsCurrent': 'A boolean value determining whether or not the weapon will be set as the players current.'}, result="Returns ''true'' if weapon was successfully acquired, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GiveWeapon', name='giveWeapon', category='Weapon functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='takeAllWeapons', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function removes every weapons from a specified [[ped]], rendering it unarmed.', arguments={'thePed': ': A ped element referencing the specified ped'}, result="Returns ''true'' if the function succeeded, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/TakeAllWeapons', name='takeAllWeapons', category='Weapon functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='takeWeapon', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='weaponId', argument_type='int', default_value=None, optional=False), FunctionArgument(name='ammo', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description="This function removes a specified weapon or ammo from a certain player's inventory.", arguments={'thePlayer': ': A player object referencing the specified player.', 'weaponId': ': An integer that refers to a weapon that you wish to remove.', 'ammo': ': If used, this amount of ammo will be taken instead and the weapon will not be removed.'}, result="Returns a ''true'' if the weapon/ammo was removed successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/TakeWeapon', name='takeWeapon', category='Weapon functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getJetpackWeaponEnabled', return_types=['bool'], arguments=[FunctionArgument(name='weapon', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if a weapon is usable while on a Jetpack.', arguments={'weapon': 'The weapon thats being checked if its usable on a Jetpack.'}, result="Returns true if the weapon is enabled, else false if the weapon isn't or invalid arguments are passed."), oop=None, url=FunctionUrl(url='/wiki/GetJetpackWeaponEnabled', name='getJetpackWeaponEnabled', category='World functions', function_type=ListType.SERVER)), client=None)
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setJetpackWeaponEnabled', return_types=['bool'], arguments=[FunctionArgument(name='weapon', argument_type='string', default_value=None, optional=False), FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets a weapon usable while using the Jetpack.', arguments={'weapon': 'The weapon thats being set usable on a Jetpack. Names can be: (Case is ignored)\n{{All Weapon Types}}', 'enabled': 'A bool representing whether the weapon is enabled or disabled.'}, result='Returns true, else false if invalid arguments are passed.'), oop=None, url=FunctionUrl(url='/wiki/SetJetpackWeaponEnabled', name='setJetpackWeaponEnabled', category='World functions', function_type=ListType.SERVER)), client=None)
