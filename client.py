from src.fetch.function import CompoundFunctionData, FunctionData, FunctionArgument, ListType, FunctionUrl, \
 FunctionType, FunctionDoc, FunctionOOP

CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getRadioChannel', return_types=['int'], arguments=[]), docs=FunctionDoc(description='The function is used to retrieve the ID of the current radio channel.', arguments={}, result='Returns the ID of the radio channel.\n{{SoundID}}'), oop=None, url=FunctionUrl(url='/wiki/GetRadioChannel', name='getRadioChannel', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getRadioChannelName', return_types=['string'], arguments=[FunctionArgument(name='id', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the given radio channel name.', arguments={'id': 'The ID of the radio station you want to get the name of. It is a number from 0 to 12.\n{{SoundID}}'}, result="Returns a string containing the station name if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetRadioChannelName', name='getRadioChannelName', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSFXStatus', return_types=['bool'], arguments=[FunctionArgument(name='audioContainer', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function checks if a big sound container is available to use or not.\n}}\nIn case of these invalid audio files, this function returns ''false''.|true}}", arguments={'audioContainer': 'The container name. Possible values are: feet, genrl, pain_a, script, spc_ea, spc_fa, spc_ga, spc_na, spc_pa'}, result="Returns ''true'' if the sound container is available, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetSFXStatus', name='getSFXStatus', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundBPM', return_types=['int'], arguments=[FunctionArgument(name='sound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the beats per minute of a specific [[sound]] element.\n[[setTimer]] to do this.}}\n}}', arguments={'sound': 'a sound element that is created using playSound or playSound3D'}, result='Returns the beats per minute of the given sound.'), oop=None, url=FunctionUrl(url='/wiki/GetSoundBPM', name='getSoundBPM', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundBufferLength', return_types=['float'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theSound': 'the sound element which buffer length you want to get.'}, result="* A [[float]] value indicating the buffer playback length of the [[sound]] in seconds.\n* ''false'' if the sound is not a stream.\n* ''nil'' if the sound is invalid."), oop=FunctionOOP(class_name='sound', method_name='getBufferLength', field="bufferLength}}\n===Required Arguments=== \n*'''theSound:''' the [[sound]] element which buffer length you want to get.\n\n===Returns===\n* A [[float]] value indicating the buffer playback length of the [[sound]] in seconds.\n* ''false'' if the sound is not a stream.\n* ''nil'' if the sound is invalid.\n\n"), url=FunctionUrl(url='/wiki/GetSoundBufferLength', name='getSoundBufferLength', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundEffects', return_types=['table'], arguments=[FunctionArgument(name='sound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the states of all effects of a sound.', arguments={'sound': 'a sound element.'}, result="Returns a [[table]] with the effect names as the keys, and their states as the values if successful. Otherwise, it returns ''false''.\n'''Sound effect names:'''\n{{Sound_Effects}}"), oop=None, url=FunctionUrl(url='/wiki/GetSoundEffects', name='getSoundEffects', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundFFTData', return_types=['table'], arguments=[FunctionArgument(name='sound', argument_type='element', default_value=None, optional=False), FunctionArgument(name='iSamples', argument_type='int', default_value=None, optional=False), FunctionArgument(name='iBands', argument_type='int', default_value='0', optional=True)]), docs=FunctionDoc(description='This function gets the fast fourier transform data for an audio stream which is a table of floats representing the current audio frame. This allows things like visualisations.\nA fast fourier transform generates a table of all the frequencies of the current audio frame which starts at the bass end of the spectrum to mids to highs in that order\nShould you have any problems there is an example resource located on the resource svn here:\n[https://github.com/multitheftauto/mtasa-resources/tree/master/%5Bgameplay%5D/visualiser Visualiser]\njust type "startmusic mystreamurl" in your console and it will play on the cinema billboard near A51 If the element is a player, this function will use the players voice.', arguments={'sound': 'a sound element that is created using playSound or playSound3D. Streams are also supported', 'iSamples': 'allowed samples are 256, 512, 1024, 2048, 4096, 8192 and 16384.', 'iBands': 'post processing option allows you to split the samples into the desired amount of bands or bars so if you only need 5 bars this saves a lot of cpu power compared to trying to do it in Lua.'}, result="Returns a table of '''iSamples'''/2 (or '''iBands''' if '''iBands''' is used) ''floats'' representing the current audio frame.\nReturns ''false'' if the sound is not playing yet or hasn't buffered in the\ncase of streams."), oop=None, url=FunctionUrl(url='/wiki/GetSoundFFTData', name='getSoundFFTData', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundLength', return_types=['float'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to return the playback length of the specified [[sound]] element.\nIf the element is a player, this function will use the players voice.\n}}', arguments={'theSound': 'the sound element which length you want to return.'}, result='Returns an [[float]] value indicating the playback length of the [[sound]] element in seconds.'), oop=FunctionOOP(class_name='sound', method_name='getLength', field="length}}\n===Required Arguments=== \n*'''theSound:''' the [[sound]] element which length you want to return.\n\n===Returns===\nReturns an [[float]] value indicating the playback length of the [[sound]] element in seconds.\n\n"), url=FunctionUrl(url='/wiki/GetSoundLength', name='getSoundLength', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundLevelData', return_types=['int,', 'int'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the left/right level from a [[sound]] [[element]].\nIf the element is a player, this function will use the players voice.\n}}', arguments={'theSound': 'the sound element which level data you want to return.'}, result="Returns a two ''integers'' in range from 0 to 32768."), oop=None, url=FunctionUrl(url='/wiki/GetSoundLevelData', name='getSoundLevelData', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundMaxDistance', return_types=['int'], arguments=[FunctionArgument(name='sound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets a custom [[sound]] max distance at which the sound stops.', arguments={'sound': 'a sound element.'}, result="Returns an ''integer'' of the max distance, ''false'' if invalid arguments where passed."), oop=FunctionOOP(class_name='sound', method_name='getMaxDistance', field='maxDistance'), url=FunctionUrl(url='/wiki/GetSoundMaxDistance', name='getSoundMaxDistance', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundMetaTags', return_types=['table'], arguments=[FunctionArgument(name='sound', argument_type='element', default_value=None, optional=False), FunctionArgument(name='format', argument_type='string', default_value='""', optional=True)]), docs=FunctionDoc(description='Used to get the meta tags attached to a sound. These provide information about the sound, for instance the title or the artist.\n*This function does not work on remote WAV files\n}}', arguments={'sound': 'a sound element.\n{{OptionalArg}} ', 'format': 'a filter string to get a specific meta tag.'}, result="Returns a [[table]], but only a [[string]] if '''format''' is given, with all data available (keys are listed below) for the sound if successful, ''false'' otherwise. If any data is unavailable then the associated key is not written to the table.\n{{Sound_Meta_Tags}}"), oop=None, url=FunctionUrl(url='/wiki/GetSoundMetaTags', name='getSoundMetaTags', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundMinDistance', return_types=['int'], arguments=[FunctionArgument(name='sound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets a custom [[sound]] Minimum distance at which the sound stops getting louder.', arguments={'sound': 'a sound element.'}, result="Returns an ''integer'' of the minimum distance, ''false'' if invalid arguements where passed."), oop=FunctionOOP(class_name='sound', method_name='getMinDistance', field='minDistance'), url=FunctionUrl(url='/wiki/GetSoundMinDistance', name='getSoundMinDistance', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundPan', return_types=['float'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the pan level of the specified [[sound]] element.', arguments={'theSound': 'the sound element which pan you want to get.'}, result="Returns ''float'' value with range from ''-1.0 (left)'' to ''1.0 (right)'', ''false'' otherwise."), oop=FunctionOOP(class_name='sound', method_name='getPan', field='pan'), url=FunctionUrl(url='/wiki/GetSoundPan', name='getSoundPan', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundPosition', return_types=['float'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to return the current seek position of the specified [[sound]] element.\nIf the element is a player, this function will use the players voice.', arguments={'theSound': 'The sound element which seek position you want to return.'}, result='Returns a [[float]] value indicating the seek position of the [[sound]] element in seconds.'), oop=FunctionOOP(class_name='sound', method_name='getPlaybackPosition', field='playbackPosition'), url=FunctionUrl(url='/wiki/GetSoundPosition', name='getSoundPosition', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundProperties', return_types=['float,', 'float,', 'float,', 'bool'], arguments=[FunctionArgument(name='sound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the properties of a specific [[sound]].\n}}', arguments={'sound': 'a sound element that is created using playSound or playSound3D'}, result="This function returns 3 [[float|floats]] and a [[boolean]] value:\nThe first float is the sound's [http://en.wikipedia.org/wiki/Sampling_rate sample rate], the second one the sound's [http://en.wikipedia.org/wiki/Tempo tempo], and the third one the [http://en.wikipedia.org/wiki/Pitch_%28music%29 pitch] of the sound. The boolean representing whether the sound is reversed or not."), oop=FunctionOOP(class_name='sound', method_name='getProperties', field=None), url=FunctionUrl(url='/wiki/GetSoundProperties', name='getSoundProperties', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundSpeed', return_types=['float'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to return the playback speed of the specified [[sound]] [[element]].', arguments={'theSound': 'the sound element which playback speed you want to return.'}, result="Returns an [[float]] value indicating the playback speed of the [[sound]] [[element]]. Default sound playback speed is '''1.0'''."), oop=FunctionOOP(class_name='sound', method_name='getSpeed', field='speed'), url=FunctionUrl(url='/wiki/GetSoundSpeed', name='getSoundSpeed', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundVolume', return_types=['float'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to return the volume level of the specified [[sound]] [[element]].\nIf the element is a [[player]], this function will use the players voice.\n}}', arguments={'theSound': 'the sound element which volume you want to return.'}, result="Returns a [[float]] representing the volume level of the [[sound]] [[element]], ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='sound', method_name='getVolume', field='volume'), url=FunctionUrl(url='/wiki/GetSoundVolume', name='getSoundVolume', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSoundWaveData', return_types=['table'], arguments=[FunctionArgument(name='sound', argument_type='element', default_value=None, optional=False), FunctionArgument(name='iSamples', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the wave form data for an audio stream which is a table of floats representing the current audio frame as a wave.\nThis allows things like visualisations.\nIf the element is a player, this function will use the players voice.\n}}', arguments={'sound': 'a sound element that is created using playSound or playSound3D. Streams are also supported', 'iSamples': 'allowed samples are 256, 512, 1024, 2048, 4096, 8192 and 16384.'}, result="Returns a [[table]] of '''iSamples''' ''floats'' representing the current audio frame waveform.\nReturns ''false'' if the sound is not playing yet or hasn't buffered in the\ncase of streams."), oop=None, url=FunctionUrl(url='/wiki/GetSoundWaveData', name='getSoundWaveData', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isSoundLooped', return_types=['bool'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theSound': 'The sound element which you want to get the loop state.'}, result="Returns ''true'' if the [[sound]] [[element]] is seted to loop, ''false'' otherwise."), oop=FunctionOOP(class_name='sound', method_name='isLooped', field=None), url=FunctionUrl(url='/wiki/IsSoundLooped', name='isSoundLooped', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isSoundPanningEnabled', return_types=['bool'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks whether panning is enabled in a [[sound]] [[element]] or not.\n}}', arguments={'theSound ': 'A valid sound element.'}, result="Returns ''true'' if the sound is valid and it has panning enabled, ''false'' if it does not or is not valid."), oop=FunctionOOP(class_name='sound', method_name='isPanningEnabled', field='panningEnabled'), url=FunctionUrl(url='/wiki/IsSoundPanningEnabled', name='isSoundPanningEnabled', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isSoundPaused', return_types=['bool'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to return the current pause state of the specified [[sound]] [[element]].\nIf the element is a [[player]], this function will use the players voice.\n}}', arguments={'theSound': 'the sound element which pause state you want to return.'}, result="Returns ''true'' if the [[sound]] [[element]] is paused, ''false'' if unpaused or invalid arguments were passed."), oop=FunctionOOP(class_name='sound', method_name='isPaused', field='paused'), url=FunctionUrl(url='/wiki/IsSoundPaused', name='isSoundPaused', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='playSFX', return_types=['element'], arguments=[FunctionArgument(name='containerName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='bankId', argument_type='int', default_value=None, optional=False), FunctionArgument(name='soundId', argument_type='int', default_value=None, optional=False), FunctionArgument(name='looped', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="This function plays a sound from GTA's big sound containers.\n}}\nIn case of these invalid audio files, this function returns ''false''.\nIt also returns ''false'' when trying to play a track deleted in the recent GTA: SA Steam patches (and if the client is using a Steam GTA: SA copy).|true}}", arguments={'containerName': 'The name of the audio container. Possible values are: feet, genrl, pain_a, script, spc_ea, spc_fa, spc_ga, spc_na, spc_pa', 'bankId': 'The audio bank id', 'soundId': 'The sound id within the audio bank', 'looped': 'A boolean representing whether the sound will be looped'}, result="Returns a [[sound]] element if the sound was successfully created, ''false'' otherwise.\n{{New feature/item|3.0140|1.4|6443|"), oop=None, url=FunctionUrl(url='/wiki/PlaySFX', name='playSFX', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='playSFX3D', return_types=['element'], arguments=[FunctionArgument(name='containerName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='bankId', argument_type='int', default_value=None, optional=False), FunctionArgument(name='soundId', argument_type='int', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='looped', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="This function plays a sound in the GTA world from GTA's big sound containers.\n}}\nIn case of these invalid audio files, this function returns ''false''.\nIt also returns ''false'' when trying to play a track deleted in the recent GTA: SA Steam patches (and if the client is using a Steam GTA: SA copy).|true}}", arguments={'containerName': 'The name of the audio container. Possible values are: feet, genrl, pain_a, script, spc_ea, spc_fa, spc_ga, spc_na, spc_pa', 'bankId': 'The audio bank id', 'soundId': 'The sound id within the audio bank', 'x': 'A floating point number representing the X coordinate on the map.', 'y': 'A floating point number representing the Y coordinate on the map.', 'z': 'A floating point number representing the Z coordinate on the map.', 'looped': 'A boolean representing whether the sound will be looped'}, result="Returns a [[sound]] element if the sound was successfully created, ''false'' otherwise.\n{{New feature/item|3.0140|1.4|6443|"), oop=None, url=FunctionUrl(url='/wiki/PlaySFX3D', name='playSFX3D', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='playSound', return_types=['element'], arguments=[FunctionArgument(name='soundPath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='looped', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='throttled', argument_type='bool', default_value='true', optional=False)]), docs=FunctionDoc(description='Creates a [[sound]] [[element]] and plays it immediately after creation for the local player.<br />\n<br />\n*The only supported audio formats are MP3, WAV, OGG, RIFF, MOD, XM, IT, S3M and PLS (e.g. Webstream).\n*For performance reasons, when using playSound for effects that will be played lots (i.e. weapon fire), it is recommend that you convert your audio file to a one channel (mono) WAV with sample rate of 22050 Hz or less. Also consider adding a limit on how often the effect can be played e.g. once every 50ms.}}', arguments={'soundPath': 'Can also be raw sound data.\n|20460}}\n{{OptionalArg}} ', 'looped': 'a boolean representing whether the sound will be looped. To loop the sound, use true. Loop is not available for streaming sounds, only for sound files.\n{{New feature/item|3.0150|1.5||', 'throttled': 'a boolean representing whether the sound will be throttled (i.e. given reduced download bandwidth). To throttle the sound, use true. Sounds will be throttled per default and only for URLs.\n}}'}, result="Returns a [[sound]] [[element]] if the sound was successfully created, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/PlaySound', name='playSound', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='playSound3D', return_types=['element'], arguments=[FunctionArgument(name='soundPath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='looped', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='Creates a [[sound]] [[element]] in the GTA world and plays it immediately after creation for the local player. [[setElementPosition]] can be used to move the [[sound]] element around after it has been created. Remember to use [[setElementDimension]] after creating the sound to play it outside of dimension 0.<br />\n<br />\n*The only supported audio formats are MP3, WAV, OGG, RIFF, MOD, XM, IT and S3M.\n*For performance reasons, when using playSound3D for effects that will be played lots (i.e. weapon fire), it is recommend that you convert your audio file to a one channel (mono) WAV with sample rate of 22050 Hz or less. Also consider adding a limit on how often the effect can be played e.g. once every 50ms.}}', arguments={'soundPath': 'Can also be raw sound data.\n|20460}}', 'soundURL': 'the URL (http://, https:// or ftp://) of the sound file you want to play. (In this version the file does not have to be predefined in the meta.xml)', 'x': 'a floating point number representing the X coordinate on the map.', 'y': 'a floating point number representing the Y coordinate on the map.', 'z': 'a floating point number representing the Z coordinate on the map.\n{{OptionalArg}} ', 'looped': 'a boolean representing whether the sound will be looped. To loop the sound, use true.\n{{New feature/item|3.0150|1.5||', 'throttled': 'a boolean representing whether the sound will be throttled (i.e. given reduced download bandwidth). To throttle the sound, use true.\n}}'}, result="Returns a [[sound]] [[element]] if the sound was successfully created, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/PlaySound3D', name='playSound3D', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='playSoundFrontEnd', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='sound', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function plays a frontend sound for the specified player.', arguments={'thePlayer': 'the player you want the sound to play for.', 'sound': 'a whole int specifying the sound id to play. Valid values are:\n{{Sounds}}'}, result="Returns ''true'' if the sound was successfully played, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/PlaySoundFrontEnd', name='playSoundFrontEnd', category='Audio functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='playSoundFrontEnd', return_types=['bool'], arguments=[FunctionArgument(name='sound', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function plays a frontend sound for the specified player.', arguments={'sound': 'a whole int specifying the sound id to play. Valid values are:\n{{Sounds}}'}, result="Returns ''true'' if the sound was successfully played, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/PlaySoundFrontEnd', name='playSoundFrontEnd', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setRadioChannel', return_types=['bool'], arguments=[FunctionArgument(name='ID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the heard radio channel, even while not in a vehicle.', arguments={'ID': 'The ID of the radio station you want to play.\n{{SoundID}}'}, result="Returns ''true'' if channel was set successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetRadioChannel', name='setRadioChannel', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSoundEffectEnabled', return_types=['bool'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False), FunctionArgument(name='effectName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='bEnable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='Used to enable or disable specific [[sound]] effects.\nUse a [[player]] element to control a players voice with this function.\n}}', arguments={'sound': 'a sound element or a player element which will affect the Resource:Voice|voice broadcast.', 'effectName': 'the effect you want to enable or disable\n{{Sound_Effects}}', 'bEnable': 'true if you want to enable the effect, false if you want to disable it.'}, result="Returns ''true'' if the effect was set successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='sound', method_name="setEffectEnabled}}\n===Required Arguments=== \n*'''sound:''' a [[sound]] element or a [[player]] element which will affect the [[Resource:Voice", field="voice]] broadcast.\n*'''effectName:''' the effect you want to enable or disable\n{{Sound_Effects}}\n*'''bEnable:''' ''true'' if you want to enable the effect, ''false'' if you want to disable it.\n\n===Returns===\nReturns ''true'' if the effect was set successfully, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/SetSoundEffectEnabled', name='setSoundEffectEnabled', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSoundLooped', return_types=['bool'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False), FunctionArgument(name='loop', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theSound': 'The sound element to set the loop.', 'bool': 'A boolean representing whether the sound will be looped.'}, result='Returns \'\'true\'\' if the [[sound]] [[element]] loop was successfully changed, \'\'false\'\' otherwise.\n<syntaxhighlight lang="lua">\naddEventHandler(\'onClientResourceStart\', resourceRoot, function()\n    local mySound = playSound(\'sound.mp3\')\n    setSoundLooped(mySound, true)\nend)\n</syntaxhighlight>'), oop=FunctionOOP(class_name='sound', method_name='setLooped', field=None), url=FunctionUrl(url='/wiki/SetSoundLooped', name='setSoundLooped', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSoundMaxDistance', return_types=['bool'], arguments=[FunctionArgument(name='sound', argument_type='element', default_value=None, optional=False), FunctionArgument(name='distance', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets a custom [[sound]] max distance at which the sound stops.', arguments={'sound': 'a sound element.', 'distance': 'the default value for this is 20'}, result="Returns a ''true'' if the max distance was set, ''false'' otherwise."), oop=FunctionOOP(class_name='sound', method_name='setMaxDistance', field='maxDistance'), url=FunctionUrl(url='/wiki/SetSoundMaxDistance', name='setSoundMaxDistance', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSoundMinDistance', return_types=['bool'], arguments=[FunctionArgument(name='sound', argument_type='element', default_value=None, optional=False), FunctionArgument(name='distance', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets a custom [[sound]] Minimum distance at which the sound stops getting louder.', arguments={'sound': 'a sound element.', 'distance': 'an integer representing the distance the sound stops getting louder. the default value for this is 5'}, result="Returns a ''true'' if the minimum distance was set, ''false'' otherwise."), oop=FunctionOOP(class_name='sound', method_name='setMinDistance', field='minDistance'), url=FunctionUrl(url='/wiki/SetSoundMinDistance', name='setSoundMinDistance', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSoundPan', return_types=['bool'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False), FunctionArgument(name='pan', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to change the pan level of the specified [[sound]] element.', arguments={'theSound': 'The sound element which pan you want to modify.', 'pan': 'A float|floating point number representing the desired pan level. Range is from -1.0 (left) to 1.0 (right)'}, result="Returns ''true'' if the [[sound]] element pan was successfully changed, ''false'' otherwise."), oop=FunctionOOP(class_name='sound', method_name='setPan', field='pan'), url=FunctionUrl(url='/wiki/SetSoundPan', name='setSoundPan', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSoundPanningEnabled', return_types=['bool'], arguments=[FunctionArgument(name='sound', argument_type='element', default_value=None, optional=False), FunctionArgument(name='enable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function toggles the panning of a sound (hearing it closer to the left or right side of the speakers due to the camera position). By default a sound has its panning enabled.', arguments={'sound': 'a sound element to change the panning of.', 'enable': 'true to enable the panning, false otherwise.'}, result="Returns ''true'' if the sound is valid and good arguments were passed, ''false'' if not.\nIf the sound is not 3D, this function will return ''true'' as well, but [[isSoundPanningEnabled]] will always return ''true'' after this (so it has no effect)."), oop=None, url=FunctionUrl(url='/wiki/SetSoundPanningEnabled', name='setSoundPanningEnabled', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSoundPaused', return_types=['bool'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False), FunctionArgument(name='paused', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to either pause or unpause the playback of the specified [[sound]] [[element]].\nUse a player element to control a players voice with this function.\n}}', arguments={'theSound': 'the sound element which you want to pause/unpause.', 'paused': 'a boolean value representing whether the sound should be paused or not. To pause the sound, use true.'}, result="Returns ''true'' if the [[sound]] [[element]] was successfully paused, ''false'' otherwise."), oop=FunctionOOP(class_name='sound', method_name='setPaused', field='paused'), url=FunctionUrl(url='/wiki/SetSoundPaused', name='setSoundPaused', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSoundPosition', return_types=['bool'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False), FunctionArgument(name='pos', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to change the seek position of the specified [[sound]] element.\nUse a player element to control a players voice with this function.\n*To set position of a remote audio file you have to pause it first, then set the position and then unpause it.}}', arguments={'theSound': 'the sound element which seek position you want to modify.', 'pos': 'a float value representing the new seek position of the sound element in seconds.'}, result="Returns ''true'' if the [[sound]] element's seek position was successfully changed, ''false'' otherwise."), oop=FunctionOOP(class_name='sound', method_name='setPlaybackPosition', field='playbackPosition'), url=FunctionUrl(url='/wiki/SetSoundPosition', name='setSoundPosition', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSoundProperties', return_types=['bool'], arguments=[FunctionArgument(name='sound', argument_type='element', default_value=None, optional=False), FunctionArgument(name='fSampleRate', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fTempo', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fPitch', argument_type='float', default_value=None, optional=False), FunctionArgument(name='bReverse', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function edits the properties of a specific [[sound]].\n}}', arguments={'sound': 'a sound element that is created using playSound or playSound3D', 'fSampleRate': 'a float that defines the new sounds http://en.wikipedia.org/wiki/Sampling_rate sample rate', 'fTempo': 'a float that defines the new sound http://en.wikipedia.org/wiki/Tempo tempo', 'fPitch': 'a float that defines the new sound http://en.wikipedia.org/wiki/Pitch_%28music%29 pitch\n{{OptionalArg}} ', 'bReverse': 'a boolean representing whether the sound will be reversed or not.'}, result="Returns ''true'' if the properties sucessfully set, ''false'' otherwise."), oop=FunctionOOP(class_name='sound', method_name='setProperties', field=None), url=FunctionUrl(url='/wiki/SetSoundProperties', name='setSoundProperties', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSoundSpeed', return_types=['bool'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False), FunctionArgument(name='speed', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function can be used to change the playback speed of the specified [[sound]] [[element]].', arguments={'theSound': 'the sound element which volume you want to modify.', 'speed': 'a floating point number representing the desired sound playback speed.'}, result="Returns ''true'' if the [[sound]] element playback speed was successfully changed, ''false'' otherwise."), oop=FunctionOOP(class_name='sound', method_name='setSpeed', field='speed'), url=FunctionUrl(url='/wiki/SetSoundSpeed', name='setSoundSpeed', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSoundVolume', return_types=['bool'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False), FunctionArgument(name='volume', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to change the volume level of the specified [[sound]] [[element]].\nUse a player element to control a players voice with this function.', arguments={'theSound': 'The sound element which volume you want to modify or a player element which voice volume you want to modify.', 'volume': 'A floating point number representing the desired volume level. Range is from 0.0 to 1.0. This can go above 1.0 for amplification.'}, result="Returns ''true'' if the [[sound]] [[element]] volume was successfully changed, ''false'' otherwise."), oop=FunctionOOP(class_name='sound', method_name='setVolume', field='volume'), url=FunctionUrl(url='/wiki/SetSoundVolume', name='setSoundVolume', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='stopSound', return_types=['bool'], arguments=[FunctionArgument(name='theSound', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='Stops the sound playback for specified [[sound]] [[element]]. The sound element is also destroyed.', arguments={'theSound': 'the sound element you want to stop playing.'}, result="Returns ''true'' if the sound was successfully stopped, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/StopSound', name='stopSound', category='Audio functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createBlip', return_types=['blip'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='icon', argument_type='int', default_value='0', optional=True), FunctionArgument(name='size', argument_type='int', default_value='2', optional=True), FunctionArgument(name='r', argument_type='int', default_value='255', optional=True), FunctionArgument(name='g', argument_type='int', default_value='0', optional=True), FunctionArgument(name='b', argument_type='int', default_value='0', optional=True), FunctionArgument(name='a', argument_type='int', default_value='255', optional=True), FunctionArgument(name='ordering', argument_type='int', default_value='0', optional=True), FunctionArgument(name='visibleDistance', argument_type='float', default_value='16383.0', optional=True), FunctionArgument(name='visibleTo', argument_type='element', default_value='getRootElement(', optional=True)]), docs=FunctionDoc(description="This function creates a [[blip]] [[element]], which is displayed as an icon on the client's radar.", arguments={}, result="Returns an [[element]] of the [[blip]] if it was created successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/CreateBlip', name='createBlip', category='Blip functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createBlip', return_types=['blip'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='icon', argument_type='int', default_value='0', optional=True), FunctionArgument(name='size', argument_type='int', default_value='2', optional=True), FunctionArgument(name='r', argument_type='int', default_value='255', optional=True), FunctionArgument(name='g', argument_type='int', default_value='0', optional=True), FunctionArgument(name='b', argument_type='int', default_value='0', optional=True), FunctionArgument(name='a', argument_type='int', default_value='255', optional=True), FunctionArgument(name='ordering', argument_type='int', default_value='0', optional=True), FunctionArgument(name='visibleDistance', argument_type='float', default_value='16383.0', optional=True)]), docs=FunctionDoc(description="This function creates a [[blip]] [[element]], which is displayed as an icon on the client's radar.", arguments={}, result="Returns an [[element]] of the [[blip]] if it was created successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/CreateBlip', name='createBlip', category='Blip functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createBlipAttachedTo', return_types=['blip'], arguments=[FunctionArgument(name='elementToAttachTo', argument_type='element', default_value=None, optional=False), FunctionArgument(name='icon', argument_type='int', default_value='0', optional=True), FunctionArgument(name='size', argument_type='int', default_value='2', optional=True), FunctionArgument(name='r', argument_type='int', default_value='255', optional=True), FunctionArgument(name='g', argument_type='int', default_value='0', optional=True), FunctionArgument(name='b', argument_type='int', default_value='0', optional=True), FunctionArgument(name='a', argument_type='int', default_value='255', optional=True), FunctionArgument(name='ordering', argument_type='int', default_value='0', optional=True), FunctionArgument(name='visibleDistance', argument_type='float', default_value='16383.0', optional=True), FunctionArgument(name='visibleTo', argument_type='element', default_value='getRootElement(', optional=True)]), docs=FunctionDoc(description="This function creates a [[blip]] that is attached to an [[element]]. This blip is displayed as an icon on the client's radar and will 'follow' the element that it is attached to around.", arguments={}, result="Returns a [[blip]] if the blip was created succesfully, or ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/CreateBlipAttachedTo', name='createBlipAttachedTo', category='Blip functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createBlipAttachedTo', return_types=['blip'], arguments=[FunctionArgument(name='elementToAttachTo', argument_type='element', default_value=None, optional=False), FunctionArgument(name='icon', argument_type='int', default_value='0', optional=True), FunctionArgument(name='size', argument_type='int', default_value='2', optional=True), FunctionArgument(name='r', argument_type='int', default_value='255', optional=True), FunctionArgument(name='g', argument_type='int', default_value='0', optional=True), FunctionArgument(name='b', argument_type='int', default_value='0', optional=True), FunctionArgument(name='a', argument_type='int', default_value='255', optional=True), FunctionArgument(name='ordering', argument_type='int', default_value='0', optional=True), FunctionArgument(name='visibleDistance', argument_type='float', default_value='16383.0', optional=True)]), docs=FunctionDoc(description="This function creates a [[blip]] that is attached to an [[element]]. This blip is displayed as an icon on the client's radar and will 'follow' the element that it is attached to around.", arguments={}, result="Returns a [[blip]] if the blip was created succesfully, or ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/CreateBlipAttachedTo', name='createBlipAttachedTo', category='Blip functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getBlipColor', return_types=['int', 'int', 'int', 'int'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will tell you what color a blip is. This color is only applicable to the default blip icon ([[Image:Blipid0s.png|12px]], [[Image:Blipid0u.png|12px]] or [[Image:Blipid0d.png|12px]]). All other icons will ignore this.', arguments={'theBlip': 'The blip whose color you wish to get.'}, result="Returns four integers in RGBA format, with a maximum value of 255 for each. The values are, in order, ''red'', ''green'', ''blue'', and ''alpha''.  Alpha decides the transparancy where 255 is opaque and 0 is fully transparent. ''false'' is returned if the blip is invalid."), oop=FunctionOOP(class_name='blip', method_name='getColor', field=None), url=FunctionUrl(url='/wiki/GetBlipColor', name='getBlipColor', category='Blip functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getBlipColor', return_types=['int', 'int', 'int', 'int'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will tell you what color a blip is. This color is only applicable to the default blip icon ([[Image:Blipid0s.png|12px]], [[Image:Blipid0u.png|12px]] or [[Image:Blipid0d.png|12px]]). All other icons will ignore this.', arguments={'theBlip': 'The blip whose color you wish to get.'}, result="Returns four integers in RGBA format, with a maximum value of 255 for each. The values are, in order, ''red'', ''green'', ''blue'', and ''alpha''.  Alpha decides the transparancy where 255 is opaque and 0 is fully transparent. ''false'' is returned if the blip is invalid."), oop=FunctionOOP(class_name='blip', method_name='getColor', field=None), url=FunctionUrl(url='/wiki/GetBlipColor', name='getBlipColor', category='Blip functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getBlipIcon', return_types=['int'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the icon a [[blip]] currently has.', arguments={'theBlip': ': the blip were getting the icon number of.'}, result='Returns an [[int]] indicating which icon the blip has. Valid values are listed on the [[Radar Blips]] page.'), oop=FunctionOOP(class_name='blip', method_name='getIcon', field='icon'), url=FunctionUrl(url='/wiki/GetBlipIcon', name='getBlipIcon', category='Blip functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getBlipIcon', return_types=['int'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the icon a [[blip]] currently has.', arguments={'theBlip': ': the blip were getting the icon number of.'}, result='Returns an [[int]] indicating which icon the blip has. Valid values are listed on the [[Radar Blips]] page.'), oop=FunctionOOP(class_name='blip', method_name='getIcon', field='icon'), url=FunctionUrl(url='/wiki/GetBlipIcon', name='getBlipIcon', category='Blip functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getBlipOrdering', return_types=['int'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the Z ordering value of a blip. The Z ordering determines if a blip appears on top of or below other blips. Blips with a higher Z ordering value appear on top of blips with a lower value. The default value for all blips is 0.', arguments={'theBlip': 'the blip to retrieve the Z ordering value of.'}, result="Returns the Z ordering value of the blip if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='blip', method_name='getOrdering', field='ordering'), url=FunctionUrl(url='/wiki/GetBlipOrdering', name='getBlipOrdering', category='Blip functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getBlipOrdering', return_types=['int'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the Z ordering value of a blip. The Z ordering determines if a blip appears on top of or below other blips. Blips with a higher Z ordering value appear on top of blips with a lower value. The default value for all blips is 0.', arguments={'theBlip': 'the blip to retrieve the Z ordering value of.'}, result="Returns the Z ordering value of the blip if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='blip', method_name='getOrdering', field='ordering'), url=FunctionUrl(url='/wiki/GetBlipOrdering', name='getBlipOrdering', category='Blip functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getBlipSize', return_types=['int'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the size of a blip..', arguments={'theBlip': 'The blip you wish to get the size of.'}, result='Returns an [[int]] indicating the size of the blip. The default value is 2. The maximum value is 25.'), oop=FunctionOOP(class_name='blip', method_name='getSize', field='size'), url=FunctionUrl(url='/wiki/GetBlipSize', name='getBlipSize', category='Blip functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getBlipSize', return_types=['int'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the size of a blip..', arguments={'theBlip': 'The blip you wish to get the size of.'}, result='Returns an [[int]] indicating the size of the blip. The default value is 2. The maximum value is 25.'), oop=FunctionOOP(class_name='blip', method_name='getSize', field='size'), url=FunctionUrl(url='/wiki/GetBlipSize', name='getBlipSize', category='Blip functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getBlipVisibleDistance', return_types=['float'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will tell you what visible distance a blip has. ', arguments={'theBlip': 'The blip whose visible distance you wish to get.'}, result='Returns one float with the blips visible distance, false if the blip is invalid.'), oop=FunctionOOP(class_name='blip', method_name='getVisibleDistance', field='visibleDistance'), url=FunctionUrl(url='/wiki/GetBlipVisibleDistance', name='getBlipVisibleDistance', category='Blip functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getBlipVisibleDistance', return_types=['float'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will tell you what visible distance a blip has. ', arguments={'theBlip': 'The blip whose visible distance you wish to get.'}, result='Returns one float with the blips visible distance, false if the blip is invalid.'), oop=FunctionOOP(class_name='blip', method_name='getVisibleDistance', field='visibleDistance'), url=FunctionUrl(url='/wiki/GetBlipVisibleDistance', name='getBlipVisibleDistance', category='Blip functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setBlipColor', return_types=['bool'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False), FunctionArgument(name='red', argument_type='int', default_value=None, optional=False), FunctionArgument(name='green', argument_type='int', default_value=None, optional=False), FunctionArgument(name='blue', argument_type='int', default_value=None, optional=False), FunctionArgument(name='alpha', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will let you change the color of a blip. This color is only applicable to the default blip icon ([[Image:Blipid0s.png|12px]], [[Image:Blipid0u.png|12px]] or [[Image:Blipid0d.png|12px]]). All other icons will ignore this.', arguments={'theBlip': 'The blip whos color you wish to set.', 'red': 'The amount of red in the blips color (0 - 255).', 'green': 'The amount of green in the blips color (0 - 255).', 'blue': 'The amount of blue in the blips color (0 - 255).', 'alpha': 'The amount of alpha in the blips color (0 - 255).  Alpha decides transparancy where 255 is opaque and 0 is transparent.'}, result="Returns ''true'' if the blip's color was set successfully. Returns ''false'' if the blip passed to the function is invalid, or any of the colors are out of the valid range."), oop=FunctionOOP(class_name='blip', method_name='setColor', field=None), url=FunctionUrl(url='/wiki/SetBlipColor', name='setBlipColor', category='Blip functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setBlipColor', return_types=['bool'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False), FunctionArgument(name='red', argument_type='int', default_value=None, optional=False), FunctionArgument(name='green', argument_type='int', default_value=None, optional=False), FunctionArgument(name='blue', argument_type='int', default_value=None, optional=False), FunctionArgument(name='alpha', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will let you change the color of a blip. This color is only applicable to the default blip icon ([[Image:Blipid0s.png|12px]], [[Image:Blipid0u.png|12px]] or [[Image:Blipid0d.png|12px]]). All other icons will ignore this.', arguments={'theBlip': 'The blip whos color you wish to set.', 'red': 'The amount of red in the blips color (0 - 255).', 'green': 'The amount of green in the blips color (0 - 255).', 'blue': 'The amount of blue in the blips color (0 - 255).', 'alpha': 'The amount of alpha in the blips color (0 - 255).  Alpha decides transparancy where 255 is opaque and 0 is transparent.'}, result="Returns ''true'' if the blip's color was set successfully. Returns ''false'' if the blip passed to the function is invalid, or any of the colors are out of the valid range."), oop=FunctionOOP(class_name='blip', method_name='setColor', field=None), url=FunctionUrl(url='/wiki/SetBlipColor', name='setBlipColor', category='Blip functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setBlipIcon', return_types=['bool'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False), FunctionArgument(name='icon', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the icon for an existing blip element.', arguments={'theBlip': 'The blip you wish to set the icon of.', 'icon': 'A number indicating the icon you wish to change it do. Valid values are listed on the Radar Blips page.'}, result="Returns ''true'' if the icon was successfully set, ''false'' if the element passed was not a valid blip or the icon value was not a valid icon number."), oop=FunctionOOP(class_name='blip', method_name='setIcon', field='icon'), url=FunctionUrl(url='/wiki/SetBlipIcon', name='setBlipIcon', category='Blip functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setBlipIcon', return_types=['bool'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False), FunctionArgument(name='icon', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the icon for an existing blip element.', arguments={'theBlip': 'The blip you wish to set the icon of.', 'icon': 'A number indicating the icon you wish to change it do. Valid values are listed on the Radar Blips page.'}, result="Returns ''true'' if the icon was successfully set, ''false'' if the element passed was not a valid blip or the icon value was not a valid icon number."), oop=FunctionOOP(class_name='blip', method_name='setIcon', field='icon'), url=FunctionUrl(url='/wiki/SetBlipIcon', name='setBlipIcon', category='Blip functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setBlipOrdering', return_types=['bool'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False), FunctionArgument(name='ordering', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the Z ordering of a blip. It allows you to make a blip appear on top of or below other blips.', arguments={'theBlip': 'the blip whose Z ordering to change.', 'ordering': 'the new Z ordering value. Blips with higher values will appear on top of blips with lower values. Possible range: -32767 to 32767. Default: 0.'}, result="Returns ''true'' if the blip ordering was changed successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='blip', method_name='setOrdering', field='ordering'), url=FunctionUrl(url='/wiki/SetBlipOrdering', name='setBlipOrdering', category='Blip functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setBlipOrdering', return_types=['bool'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False), FunctionArgument(name='ordering', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the Z ordering of a blip. It allows you to make a blip appear on top of or below other blips.', arguments={'theBlip': 'the blip whose Z ordering to change.', 'ordering': 'the new Z ordering value. Blips with higher values will appear on top of blips with lower values. Possible range: -32767 to 32767. Default: 0.'}, result="Returns ''true'' if the blip ordering was changed successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='blip', method_name='setOrdering', field='ordering'), url=FunctionUrl(url='/wiki/SetBlipOrdering', name='setBlipOrdering', category='Blip functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setBlipSize', return_types=['bool'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False), FunctionArgument(name='iconSize', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the size of a blip's icon.", arguments={'theBlip': 'The blip you wish to get the size of.', 'iconSize': 'The size you wish the icon to be. 2 is the default value. 25 is the maximum value. Value gets clamped between 0 and 25.'}, result="Returns an ''true'' if the blip's size was set successfully. Returns ''false'' if the [[element]] passed was not a [[blip]] or if the icon size passed was invalid."), oop=FunctionOOP(class_name='blip', method_name='setSize', field='size'), url=FunctionUrl(url='/wiki/SetBlipSize', name='setBlipSize', category='Blip functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setBlipSize', return_types=['bool'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False), FunctionArgument(name='iconSize', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the size of a blip's icon.", arguments={'theBlip': 'The blip you wish to get the size of.', 'iconSize': 'The size you wish the icon to be. 2 is the default value. 25 is the maximum value. Value gets clamped between 0 and 25.'}, result="Returns an ''true'' if the blip's size was set successfully. Returns ''false'' if the [[element]] passed was not a [[blip]] or if the icon size passed was invalid."), oop=FunctionOOP(class_name='blip', method_name='setSize', field='size'), url=FunctionUrl(url='/wiki/SetBlipSize', name='setBlipSize', category='Blip functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setBlipVisibleDistance', return_types=['bool'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False), FunctionArgument(name='theDistance', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will set the visible distance of a blip.', arguments={'theBlip': 'The blip whose visible distance you wish to get.', 'theDistance': 'The distance you want the blip to be visible for. Value gets clamped between 0 and 65535.'}, result='Returns true if successful, false otherwise.'), oop=FunctionOOP(class_name='blip', method_name='setVisibleDistance', field='visibleDistance'), url=FunctionUrl(url='/wiki/SetBlipVisibleDistance', name='setBlipVisibleDistance', category='Blip functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setBlipVisibleDistance', return_types=['bool'], arguments=[FunctionArgument(name='theBlip', argument_type='blip', default_value=None, optional=False), FunctionArgument(name='theDistance', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will set the visible distance of a blip.', arguments={'theBlip': 'The blip whose visible distance you wish to get.', 'theDistance': 'The distance you want the blip to be visible for. Value gets clamped between 0 and 65535.'}, result='Returns true if successful, false otherwise.'), oop=FunctionOOP(class_name='blip', method_name='setVisibleDistance', field='visibleDistance'), url=FunctionUrl(url='/wiki/SetBlipVisibleDistance', name='setBlipVisibleDistance', category='Blip functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='canBrowserNavigateBack', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if the browser can return to the previous page.\n}}', arguments={'webBrowser': 'The browser you want to check for a previous page.'}, result="Returns ''true'' if the browser can navigate back, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/CanBrowserNavigateBack', name='canBrowserNavigateBack', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='canBrowserNavigateForward', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if the browser can go to the next page.\n}}', arguments={'webBrowser': 'The browser you want check for a next page.'}, result="Returns ''true'' if the browser can go to the next page, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/CanBrowserNavigateForward', name='canBrowserNavigateForward', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='createBrowser', return_types=['element'], arguments=[FunctionArgument(name='width', argument_type='int', default_value=None, optional=False), FunctionArgument(name='height', argument_type='int', default_value=None, optional=False), FunctionArgument(name='isLocal', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='transparent', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function creates a new web [[Element/Browser|browser]] element.\n}}', arguments={'width': 'The browsers native width. This should be greater than or equal to 1.', 'height': 'The browsers native height. This should be greater than or equal to 1.', 'isLocal': 'Sets whether the browser can only show local content or content from the internet (see examples for more information)\n{{New feature/item|3.0160|1.6||Invalid sizes will be a hard error.}}', 'transparent': 'true if you want the browser transparent, false for opaque.'}, result="Returns a [[texture]] of the [[browser]] if it was created successfully, ''false'' otherwise. Returns also ''false'', if the user disabled remote pages and ''isLocal'' was set to ''false''."), oop=None, url=FunctionUrl(url='/wiki/CreateBrowser', name='createBrowser', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='executeBrowserJavascript', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False), FunctionArgument(name='jsCode', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function executes a Javascript string to the specified [[Element/Browser|browser]]. Works only with local browsers.\n}}', arguments={'webBrowser': 'The web browser which will execute the Javascript code', 'jsCode': 'The Javascript code string'}, result="Returns ''true'' if executing Javascript is allowed in the current context, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ExecuteBrowserJavascript', name='executeBrowserJavascript', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='focusBrowser', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will attempt to focus the [[Element/Browser|browser]] or unfocus all browsers. The browser that is focused will retrieve keyboard input.\n}}', arguments={'webBrowser': 'The web browser to be focused - if this is nil, it will unfocus all browsers.'}, result="Returns ''true'' if the browser was focused or if nil was passed, ''false'' if it failed to focus or the browser does not exist."), oop=None, url=FunctionUrl(url='/wiki/FocusBrowser', name='focusBrowser', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getBrowserProperty', return_types=['bool'], arguments=[FunctionArgument(name='theBrowser', argument_type='browser', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets a given property of a specified browser.\n}}', arguments={'theBrowser': 'browser element to get the property value of', 'key': 'The browser property key. It can be:', 'mobile': 'Surfing the web as mobile'}, result="Returns the value if the property was successfully found, ''false'' otherwise."), oop=FunctionOOP(class_name='browser', method_name='getProperty', field=None), url=FunctionUrl(url='/wiki/GetBrowserProperty', name='getBrowserProperty', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getBrowserSettings', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function returns a table containing the browser settings.\n}}', arguments={}, result="A table having the following keys:\n* '''RemoteEnabled''': ''true'' if remote websites are enabled, ''false'' otherwise\n* '''RemoteJavascript''': ''true'' if Javascript is enabled on remote websites, ''false'' otherwise\n* '''PluginsEnabled''': ''true'' if plugins such as Flash, Silverlight (but not Java) are enabled, ''false'' otherwise. This setting is ''false'' by default."), oop=None, url=FunctionUrl(url='/wiki/GetBrowserSettings', name='getBrowserSettings', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getBrowserSource', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False), FunctionArgument(name='callback', argument_type='function', default_value=None, optional=False)]), docs=FunctionDoc(description='This function can be used to retrieve the source code of a website (asynchronously). The size of the source code is limited to 2 MiB (remaining bytes are cut).\n}}', arguments={'webBrowser': 'The browser element you want to get the source of', 'callback': 'a callback function with syntax as described below'}, result="Returns ''true'' if valid arguments have been passed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetBrowserSource', name='getBrowserSource', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getBrowserTitle', return_types=['string'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the title of the passed [[Element/Browser|browser]].\n}}', arguments={'webBrowser': 'The browser'}, result='Returns the title as a [[string]]. Returns false if invalid arguments were passed.'), oop=FunctionOOP(class_name='browser', method_name='getTitle', field="title}}\n\n===Required arguments===\n*'''webBrowser:''' The browser\n\n===Returns===\nReturns the title as a [[string]]. Returns false if invalid arguments were passed.\n\n"), url=FunctionUrl(url='/wiki/GetBrowserTitle', name='getBrowserTitle', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getBrowserURL', return_types=['string'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the URL of the specified [[Element/Browser|browser]].\n}}', arguments={'webBrowser': 'The browser'}, result='Returns the web browser URL.'), oop=FunctionOOP(class_name='browser', method_name='getURL', field='url'), url=FunctionUrl(url='/wiki/GetBrowserURL', name='getBrowserURL', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='injectBrowserMouseDown', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False), FunctionArgument(name='mouseButton', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function injects a mouse click (state: down).\n}}', arguments={'webBrowser': 'The web browser', 'mouseButton': 'The mouse button (Possible values: left, middle, right)'}, result="Returns ''true'' if the click was successfully injected, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/InjectBrowserMouseDown', name='injectBrowserMouseDown', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='injectBrowserMouseMove', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False), FunctionArgument(name='posX', argument_type='int', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function injects a mouse movement.\n}}', arguments={'webBrowser': 'The browser which will retrieve the mouse movement', 'posX': 'Absolute X screen coordinate', 'posY': 'Absolute Y screen coordinate'}, result="Returns ''true'' if the movement was injected successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/InjectBrowserMouseMove', name='injectBrowserMouseMove', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='injectBrowserMouseUp', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False), FunctionArgument(name='mouseButton', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function injects a mouse click (state: up). \n}}', arguments={'webBrowser': 'The web browser', 'mouseButton': 'The mouse button (Possible values: left, middle, right)'}, result="Returns ''true'' if the click was successfully injected, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/InjectBrowserMouseUp', name='injectBrowserMouseUp', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='injectBrowserMouseWheel', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False), FunctionArgument(name='verticalScroll', argument_type='int', default_value=None, optional=False), FunctionArgument(name='horizontalScroll', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function injects mouse wheel events. \n}}', arguments={'webBrowser': 'The web browser', 'verticalScroll': ': Amount of units you want the browser to scroll along the Y-axe.', 'horizontalScroll': ': Amount of units you want the browser to scroll along the X-axe.'}, result="Returns ''true'' if the mouse action was successfully injected, ''false'' otherwise."), oop=FunctionOOP(class_name='browser', method_name='injectMouseWheel', field=None), url=FunctionUrl(url='/wiki/InjectBrowserMouseWheel', name='injectBrowserMouseWheel', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isBrowserDomainBlocked', return_types=['bool'], arguments=[FunctionArgument(name='address', argument_type='string', default_value=None, optional=False), FunctionArgument(name='isURL', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function checks if the specified URL is blocked from being loaded.\n}}', arguments={'address': 'A website URL', 'isURL': 'true if address should be parsed as URL, false otherwise.'}, result="Returns ''false'' if the URL is able to be loaded, ''true'' if it is blocked and ''nil'' if an invalid domain/URL was passed."), oop=None, url=FunctionUrl(url='/wiki/IsBrowserDomainBlocked', name='isBrowserDomainBlocked', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isBrowserFocused', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if a browser is focused.', arguments={'webBrowser': 'The browser'}, result="Returns ''true'' if the browser is focused, ''false'' otherwise and ''nil'' if invalid arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/IsBrowserFocused', name='isBrowserFocused', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isBrowserLoading', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if a browser is currently loading a website.\n}}', arguments={'webBrowser': 'The browser'}, result="Returns ''true'' if the browser is loading a website, ''false'' otherwise and ''nil'' if invalid arguments were passed."), oop=FunctionOOP(class_name='browser', method_name='isLoading', field="loading}}\n\n===Required arguments===\n*'''webBrowser:''' The browser\n\n===Returns===\nReturns ''true'' if the browser is loading a website, ''false'' otherwise and ''nil'' if invalid arguments were passed.\n\n"), url=FunctionUrl(url='/wiki/IsBrowserLoading', name='isBrowserLoading', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='loadBrowserURL', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False), FunctionArgument(name='url', argument_type='string', default_value=None, optional=False), FunctionArgument(name='postData', argument_type='string', default_value='""', optional=True), FunctionArgument(name='urlEncoded', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description='This function loads the specified URL.\n}}', arguments={'webBrowser': 'The Element/Browser|browser element which will load the URL', 'url': 'The url you want to load. It can either contain a remote website (http:// prefix) or a website stored within a local resource (http://mta/local/gui.html for example, see Local_Scheme_Handler|Local Scheme Handler for details).', 'postData': 'The post data passed to the website. Its content type can be any type (e.g. JSON) if urlEncoded is set to false', 'urlEncoded': 'If set to true, it will be available f.e. in PHPs $_POST variable (the content type is: application/x-www-form-urlencoded)'}, result="Returns ''true'' if the URL was successfully loaded."), oop=FunctionOOP(class_name='browser', method_name='loadURL', field='url'), url=FunctionUrl(url='/wiki/LoadBrowserURL', name='loadBrowserURL', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='navigateBrowserBack', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the browser to the previous page.\n}}', arguments={'webBrowser': 'The browser that you want return to the previous page.'}, result="Returns ''true'' if the browser has returned to the previous page, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/NavigateBrowserBack', name='navigateBrowserBack', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='navigateBrowserForward', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False)]), docs=FunctionDoc(description='This function takes the browser to the next page.\n}}', arguments={'webBrowser': 'The browser that you want to take to the next page.'}, result="Returns ''true'' if the browser has gone to the next page, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/NavigateBrowserForward', name='navigateBrowserForward', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='reloadBrowserPage', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False)]), docs=FunctionDoc(description="This function reloads the current browser's page.\n}}", arguments={'webBrowser': 'The browser that you want to reload.'}, result="Returns ''true'' if the browser has reloaded, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ReloadBrowserPage', name='reloadBrowserPage', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='requestBrowserDomains', return_types=['bool'], arguments=[FunctionArgument(name='pages', argument_type='table', default_value=None, optional=False), FunctionArgument(name='parseAsURL', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='callback', argument_type='function', default_value=None, optional=True)]), docs=FunctionDoc(description='This function opens a request window in order to accept the requested remote URLs.\n}}', arguments={'pages': 'A table containing all domains', 'parseAsURL': 'true if the passed addresses should be converted from URLs, false otherwise.', 'callback': 'A callback function that is called as soon as the result is available\nSyntax:\n<syntaxhighlight lang="lua">function(bool wasAccepted, table new_domains)</syntaxhighlight>'}, result="Returns '''true''', if the string was successfully read, '''false''' otherwise."), oop=None, url=FunctionUrl(url='/wiki/RequestBrowserDomains', name='requestBrowserDomains', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='resizeBrowser', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='Allows resizing of CEF browsers at runtime.\n}}', arguments={'webBrowser': 'The browser you want to resize.', 'width': 'The new width of the browser.', 'height': 'The new height of the browser.'}, result="Returns ''true'' if the browser is resized successfully, ''false'' if there's something wrong."), oop=None, url=FunctionUrl(url='/wiki/ResizeBrowser', name='resizeBrowser', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setBrowserAjaxHandler', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False), FunctionArgument(name='url', argument_type='string', default_value=None, optional=False), FunctionArgument(name='handler', argument_type='function', default_value=None, optional=True)]), docs=FunctionDoc(description='This function provides a requestable ajax resource for Lua/Javascript communication for a [[Element/Browser|browser]].\n}}', arguments={'webBrowser': 'The web browser which will execute the Javascript code', 'url': 'The URL endpoint to handle\n{{Warning|Do not use the same path as an existing file as url parameter. Ajax handlers have a higher priority than regular files, which will lead to inaccesibility of the original file if an ajax handler is attached to the same path. }}', 'handler': 'The function to call if the webBrowser attempts to open the ajax endpoint. If this parameter is nil or omitted, the ajax handler for the url will be deleted.'}, result=''), oop=FunctionOOP(class_name='browser', method_name="setAjaxHandler}}\n\n===Required Arguments===\n*'''webBrowser:''' The web browser which will execute the Javascript code\n*'''url:''' The URL endpoint to handle\n{{Warning", field="Do not use the same path as an existing file as url parameter. Ajax handlers have a higher priority than regular files, which will lead to inaccesibility of the original file if an ajax handler is attached to the same path. }}\n\n\n===Optional Arguments===\n*'''handler:''' The function to call if the webBrowser attempts to open the ajax endpoint. If this parameter is nil or omitted, the ajax handler for the url will be deleted.\n\n===Additional Information===\nThe handling function (if given), will be called with two tables, representing GET and POST parameters. The handling function may return a string which will be provided to the browser as file content.\n\n"), url=FunctionUrl(url='/wiki/SetBrowserAjaxHandler', name='setBrowserAjaxHandler', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setBrowserProperty', return_types=['bool'], arguments=[FunctionArgument(name='theBrowser', argument_type='browser', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets a given property of a specified browser.\n}}', arguments={'theBrowser': 'The browser element you want to set a property of', 'key': 'The browser property key. It can be:', 'mobile': 'Surfing the web as mobile', 'value': 'A value indicating whether to enable (1) the property or not (0)'}, result="Returns ''true'' if the property was successfully set, ''false'' otherwise."), oop=FunctionOOP(class_name='browser', method_name='setProperty', field=None), url=FunctionUrl(url='/wiki/SetBrowserProperty', name='setBrowserProperty', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setBrowserRenderingPaused', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False), FunctionArgument(name='paused', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the rendering state of a browser.\n}}', arguments={'webBrowser': 'The browser', 'paused': 'true to pause rendering, false to continue'}, result="Returns ''true'' if the state was successfully changed"), oop=None, url=FunctionUrl(url='/wiki/SetBrowserRenderingPaused', name='setBrowserRenderingPaused', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setBrowserVolume', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False), FunctionArgument(name='volume', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets either a specific [[Element/Browser|browser]]'s volume, or the overall volume for browsers.\n}}", arguments={'volume': 'A float|floating point number representing the desired volume level. Range is from 0.0 to 1.0', 'webBrowser': 'A browser element'}, result=''), oop=FunctionOOP(class_name='browser', method_name='setVolume', field='volume'), url=FunctionUrl(url='/wiki/SetBrowserVolume', name='setBrowserVolume', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='toggleBrowserDevTools', return_types=['bool'], arguments=[FunctionArgument(name='webBrowser', argument_type='browser', default_value=None, optional=False), FunctionArgument(name='visible', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function toggles the visibility of the developer tools pane.\n}}', arguments={'webBrowser': 'The browser', 'visible': 'true to show the tools, false to hide'}, result="Returns ''true'' if the visibility was successfully toggled, ''false'' if an error occurred"), oop=FunctionOOP(class_name='browser', method_name='toggleDevTools', field="devTools}}\n\n===Required Arguments===\n*'''webBrowser:''' The browser\n*'''visible:''' ''true'' to show the tools, ''false'' to hide\n\n===Returns===\nReturns ''true'' if the visibility was successfully toggled, ''false'' if an error occurred\n\n"), url=FunctionUrl(url='/wiki/ToggleBrowserDevTools', name='toggleBrowserDevTools', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateBrowser', return_types=['gui-browser'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='isLocal', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='isTransparent', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='isRelative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value='nil', optional=True)]), docs=FunctionDoc(description='This function creates a new CEGUI web [[Element/Browser|browser]] element.\nThe difference between this, and createBrowser is that, this handles inputs internally, and it can be attached to GUI windows. So this one is more suitable for custom dx based interfaces.\nYou can learn more about the differences [https://forum.mtasa.com/topic/80422-dx-browser-vs-gui-browser/?do=findComment&comment=737334 here].\n}}', arguments={'x': 'A float of the 2D x position of the browser on a players screen.  This is affected by the relative argument.', 'y': 'A float of the 2D y position of the browser on a players screen. This is affected by the relative argument.', 'width': 'The browsers native width. This should be greater than or equal to 1.', 'height': 'The browsers native height. This should be greater than or equal to 1.', 'isLocal': 'Sets whether the browser can only show local content or content from the internet (see examples over CreateBrowser|here for more information)', 'isTransparent': 'true if you want the browser to support transparency, false otherwise', 'isRelative': 'This is whether sizes and positioning are relative.  If this is true, then all x,y,width,height floats must be between 0 and 1, representing sizes/positions as a fraction of the screen size. If false, then the size and co-ordinates are based on clients resolution, accessible using guiGetScreenSize.\n{{New feature/item|3.0160|1.6||Providing a size of (0,0) will be a hard error.}}', 'parent': 'This is the parent that the radio button is attached to. If the relative argument is true, sizes and positioning will be made relative to this parent. If the relative argument is false, positioning will be the number of offset pixels from the parents origin. If no parent is passed, the parent will become the screen - causing positioning and sizing according to screen positioning.'}, result="Returns a [[gui-browser]] element if it was created successfully, ''false'' otherwise. Returns also ''false'', if the user disabled remote pages and ''isLocal'' was set to ''false''."), oop=None, url=FunctionUrl(url='/wiki/GuiCreateBrowser', name='guiCreateBrowser', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetBrowser', return_types=['browser'], arguments=[FunctionArgument(name='browser', argument_type='gui', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the browser element behind a gui-browser (a browser that has been created via [[guiCreateBrowser]]).\n}}', arguments={'theBrowser': 'The gui-browser'}, result="Returns the [[Element/Browser|Browser]] element if a correct [[Element/gui-browser|gui-browser]] has been passed, ''false'' otherwise."), oop=FunctionOOP(class_name='guiBrowser', method_name='getBrowser', field='browser'), url=FunctionUrl(url='/wiki/GuiGetBrowser', name='guiGetBrowser', category='Browser functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fadeCamera', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='fadeIn', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='timeToFade', argument_type='float', default_value='1.0', optional=False), FunctionArgument(name='red', argument_type='int', default_value='0', optional=False), FunctionArgument(name='green', argument_type='int', default_value='0', optional=False), FunctionArgument(name='blue', argument_type='int', default_value='0', optional=False)]), docs=FunctionDoc(description="This function will fade a player's camera to a color or back to normal over a specified time period. This will also affect the sound volume for the player (50% faded = 50% volume, full fade = no sound). For clientside scripts you can perform 2 fade ins or fade outs in a row, but for serverside scripts you must use one then the other.", arguments={'thePlayer': 'The player whose camera you wish to fade.', 'fadeIn': 'Should the camera be faded in or out? Pass true to fade the camera in, false to fade it out to a color.', 'timeToFade': 'The number of seconds it should take to fade.', 'red': 'The amount of red in the color that the camera fades out to (0 - 255). Not required for fading in.', 'green': 'The amount of green in the color that the camera fades out to (0 - 255). Not required for fading in.', 'blue': 'The amount of blue in the color that the camera fades out to (0 - 255). Not required for fading in.'}, result="Returns ''true'' if the camera was faded successfully, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/FadeCamera', name='fadeCamera', category='Camera functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fadeCamera', return_types=['bool'], arguments=[FunctionArgument(name='fadeIn', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='timeToFade', argument_type='float', default_value='1.0', optional=False), FunctionArgument(name='red', argument_type='int', default_value='0', optional=False), FunctionArgument(name='green', argument_type='int', default_value='0', optional=False), FunctionArgument(name='blue', argument_type='int', default_value='0', optional=False)]), docs=FunctionDoc(description="This function will fade a player's camera to a color or back to normal over a specified time period. This will also affect the sound volume for the player (50% faded = 50% volume, full fade = no sound). For clientside scripts you can perform 2 fade ins or fade outs in a row, but for serverside scripts you must use one then the other.", arguments={'fadeIn': 'Should the camera be faded in our out? Pass true to fade the camera in, false to fade it out to a color.', 'timeToFade': 'The number of seconds it should take to fade.', 'red': 'The amount of red in the color that the camera fades out to (0 - 255). Not required for fading in.', 'green': 'The amount of green in the color that the camera fades out to (0 - 255). Not required for fading in.', 'blue': 'The amount of blue in the color that the camera fades out to (0 - 255). Not required for fading in.'}, result="Returns ''true'' if the camera was faded successfully, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/FadeCamera', name='fadeCamera', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getCamera', return_types=['element'], arguments=[]), docs=FunctionDoc(description='This function returns an [[element]] that corresponds to the game camera \n}}', arguments={}, result='Returns an [[element]] that corresponds to the game camera '), oop=None, url=FunctionUrl(url='/wiki/GetCamera', name='getCamera', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getCameraClip', return_types=['bool,', 'bool'], arguments=[]), docs=FunctionDoc(description='', arguments={}, result="*'''objects:''' if you want the camera to clip on objects.\n*'''vehicles:''' if you want the camera to clip on vehicles."), oop=FunctionOOP(class_name='Camera', method_name='getClip', field=None), url=FunctionUrl(url='/wiki/GetCameraClip', name='getCameraClip', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getCameraFieldOfView', return_types=['float'], arguments=[FunctionArgument(name='cameraMode', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'cameraMode': 'the camera mode to get the field of view of\n** "player": whilst walking/running\n** "vehicle": whilst in vehicle\n** "vehicle_max": the max the field of view can go to when the vehicle is moving at a high speed (must be higher than "vehicle")'}, result='Returns one float - the field of view angle'), oop=None, url=FunctionUrl(url='/wiki/GetCameraFieldOfView', name='getCameraFieldOfView', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getCameraGoggleEffect', return_types=['string'], arguments=[]), docs=FunctionDoc(description='This function returns what goggle effect is currently affecting the camera.', arguments={}, result='* [[String]] indicating the current camera goggle effect. Their meanings can be seen below.\n{{Camera goggle modes}}'), oop=None, url=FunctionUrl(url='/wiki/GetCameraGoggleEffect', name='getCameraGoggleEffect', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getCameraInterior', return_types=['int'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the interior of the local camera (independent of the interior of the local player).', arguments={'thePlayer': ': The player whose camera interior you want to get.'}, result="Returns an ''integer'' indicating the camera's interior, ''false'' if the argument is invalid."), oop=FunctionOOP(class_name='player', method_name='getCameraInterior', field='cameraInterior'), url=FunctionUrl(url='/wiki/GetCameraInterior', name='getCameraInterior', category='Camera functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getCameraInterior', return_types=['int'], arguments=[]), docs=FunctionDoc(description='Returns the interior of the local camera (independent of the interior of the local player).', arguments={}, result="Returns an ''integer'' indicating the camera's interior, ''false'' if the argument is invalid."), oop=None, url=FunctionUrl(url='/wiki/GetCameraInterior', name='getCameraInterior', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getCameraMatrix', return_types=['float', 'float', 'float', 'float', 'float', 'float', 'float', 'float'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the position of the camera and the position of the point it is facing.', arguments={'thePlayer': 'The player whose camera matrix is to be returned.'}, result="This function returns 8 [[float|floats]] if the argument is valid (when applicable); the first three indicate the position of the camera, the next three indicate the position of the point it's facing, and the last two are the roll and field of view. Returns ''false'' if the argument is invalid."), oop=FunctionOOP(class_name='player', method_name='getCameraMatrix', field='cameraMatrix'), url=FunctionUrl(url='/wiki/GetCameraMatrix', name='getCameraMatrix', category='Camera functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getCameraMatrix', return_types=['float', 'float', 'float', 'float', 'float', 'float', 'float', 'float'], arguments=[]), docs=FunctionDoc(description='This function gets the position of the camera and the position of the point it is facing.', arguments={}, result="This function returns 8 [[float|floats]] if the argument is valid (when applicable); the first three indicate the position of the camera, the next three indicate the position of the point it's facing, and the last two are the roll and field of view. Returns ''false'' if the argument is invalid."), oop=FunctionOOP(class_name='Camera', method_name='getMatrix', field='matrix'), url=FunctionUrl(url='/wiki/GetCameraMatrix', name='getCameraMatrix', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getCameraShakeLevel', return_types=['int'], arguments=[]), docs=FunctionDoc(description='This function gets the camera shake level set by [[setCameraShakeLevel]].}}', arguments={}, result='Returns an integer representing the camera shake level, from 0 (no shaking effect) to 255 (maximum shaking effect). By default, the camera has no shaking effect.'), oop=None, url=FunctionUrl(url='/wiki/GetCameraShakeLevel', name='getCameraShakeLevel', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getCameraTarget', return_types=['element'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="This function returns an [[element]] that corresponds to the current target of the specified player's camera (i.e. what it is following). ", arguments={'thePlayer': 'The player whose camera you wish to receive the target of.'}, result="* Returns an [[element]] of the target if the function was successful, or ''false'' if bad arguments were specified\n{{New feature|3|1.0|\n* Returns ''false'' if the camera is in Fixed mode and has no target.\n}}"), oop=FunctionOOP(class_name='player', method_name='getCameraTarget', field='cameraTarget'), url=FunctionUrl(url='/wiki/GetCameraTarget', name='getCameraTarget', category='Camera functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getCameraTarget', return_types=['element'], arguments=[]), docs=FunctionDoc(description="This function returns an [[element]] that corresponds to the current target of the specified player's camera (i.e. what it is following). ", arguments={}, result="* Returns an [[element]] of the target if the function was successful, or ''false'' if bad arguments were specified\n{{New feature|3|1.0|\n* Returns ''false'' if the camera is in Fixed mode and has no target.\n}}"), oop=None, url=FunctionUrl(url='/wiki/GetCameraTarget', name='getCameraTarget', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getCameraViewMode', return_types=['int'], arguments=[]), docs=FunctionDoc(description="This function allows you to get the camera's view mode. This indicates at what distance the camera will follow the player.", arguments={}, result='Returns an [[int]] indicating the current camera view mode. Their meanings can be seen below.\n{{Camera view modes}}'), oop=None, url=FunctionUrl(url='/wiki/GetCameraViewMode', name='getCameraViewMode', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setCameraClip', return_types=['bool'], arguments=[FunctionArgument(name='objects', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='vehicles', argument_type='bool', default_value='true', optional=False)]), docs=FunctionDoc(description='This function sets if the camera will "collide" with any objects or vehicles in its way. This means that if object clip is enabled an object is in the way of where the camera actually wants to be, the camera will try to be in front of it. This function can disable that.', arguments={'objects': 'Sets if you want the camera to clip on objects.', 'vehicles': 'Sets if you want the camera to clip on vehicles.'}, result="Always returns ''true''."), oop=FunctionOOP(class_name='Camera', method_name='setClip', field=None), url=FunctionUrl(url='/wiki/SetCameraClip', name='setCameraClip', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setCameraFieldOfView', return_types=['bool'], arguments=[FunctionArgument(name='cameraMode', argument_type='string', default_value=None, optional=False), FunctionArgument(name='fieldOfView', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'cameraMode': 'the camera mode to get the field of view of\n** "player": whilst walking/running\n** "vehicle": whilst in vehicle\n** "vehicle_max": the max the field of view can go to when the vehicle is moving at a high speed (must be higher than "vehicle")', 'fieldOfView': 'The field of view angle, 0 to 179.'}, result="Returns ''true'' if the arguments are valid, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetCameraFieldOfView', name='setCameraFieldOfView', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setCameraGoggleEffect', return_types=['bool'], arguments=[FunctionArgument(name='goggleEffect', argument_type='string', default_value=None, optional=False), FunctionArgument(name='noiseEnabled', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description="This function allows you to set the camera's current goggle effect. This means you can activate nightvision or infrared effects by script", arguments={'goggleEffect': ': the goggle effect you wish to set\n{{Camera goggle modes}}\n{{New feature/item|3.0156|1.5.5|13999|', 'noiseEnabled': ': whether or not there should be a fuzzy noise effect\n}}'}, result="* ''true'' if the effect was set correctly.\n* ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetCameraGoggleEffect', name='setCameraGoggleEffect', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setCameraInterior', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='interior', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the interior of the local camera. Only the interior of the camera is changed, the local player stays in the interior he was in.', arguments={'thePlayer': 'the player whose camera interior will be set.', 'interior': 'the interior to place the camera in.'}, result="Returns ''true'' if the camera's interior was changed successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='setCameraInterior', field='cameraInterior'), url=FunctionUrl(url='/wiki/SetCameraInterior', name='setCameraInterior', category='Camera functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setCameraInterior', return_types=['bool'], arguments=[FunctionArgument(name='interior', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the interior of the local camera. Only the interior of the camera is changed, the local player stays in the interior he was in.', arguments={'interior': 'the interior to place the camera in.'}, result="Returns ''true'' if the camera's interior was changed successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetCameraInterior', name='setCameraInterior', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setCameraMatrix', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='positionX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='positionY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='positionZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='lookAtX', argument_type='float', default_value=None, optional=True), FunctionArgument(name='lookAtY', argument_type='float', default_value=None, optional=True), FunctionArgument(name='lookAtZ', argument_type='float', default_value=None, optional=True), FunctionArgument(name='roll', argument_type='float', default_value='0', optional=True), FunctionArgument(name='fov', argument_type='float', default_value='70', optional=True)]), docs=FunctionDoc(description='This function sets the camera\'s position and direction. The first three arguments are the point at which the camera lies, the last three are the point the camera faces (or the point it "looks at").', arguments={'thePlayer': 'The player whose camera is to be changed.', 'positionX': 'The x coordinate of the cameras position.', 'positionY': 'The y coordinate of the cameras position.', 'positionZ': 'The z coordinate of the cameras position.', '{{New feature/item|3.0141|1.4.1|7005|Instead of six coordinates, or two vectors, a Matrix can be supplied.}}': '', 'lookAtX': 'The x coordinate of the point the camera faces.', 'lookAtY': 'The y coordinate of the point the camera faces.', 'lookAtZ': 'The z coordinate of the point the camera faces.', 'roll': 'The camera roll angle, -180 to 180. A value of 0 means the camera sits straight, positive values will turn it counter-clockwise and negative values will turn it clockwise. -180 or 180 means the camera is upside down.', 'fov': 'the field of view angle, 0.01 to 180. The higher this value is, the more you will be able to see what is to your sides.'}, result="Returns ''true'' if the arguments are valid, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='setCameraMatrix', field='cameraMatrix'), url=FunctionUrl(url='/wiki/SetCameraMatrix', name='setCameraMatrix', category='Camera functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setCameraMatrix', return_types=['bool'], arguments=[FunctionArgument(name='positionX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='positionY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='positionZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='lookAtX', argument_type='float', default_value=None, optional=True), FunctionArgument(name='lookAtY', argument_type='float', default_value=None, optional=True), FunctionArgument(name='lookAtZ', argument_type='float', default_value=None, optional=True), FunctionArgument(name='roll', argument_type='float', default_value='0', optional=True), FunctionArgument(name='fov', argument_type='float', default_value='70', optional=True)]), docs=FunctionDoc(description='This function sets the camera\'s position and direction. The first three arguments are the point at which the camera lies, the last three are the point the camera faces (or the point it "looks at").', arguments={'positionX': 'The x coordinate of the cameras position.', 'positionY': 'The y coordinate of the cameras position.', 'positionZ': 'The z coordinate of the cameras position.', '{{New feature/item|3.0141|1.4.1|7005|Instead of six coordinates, or two vectors, a Matrix can be supplied.}}': '', 'lookAtX': 'The x coordinate of the point the camera faces.', 'lookAtY': 'The y coordinate of the point the camera faces.', 'lookAtZ': 'The z coordinate of the point the camera faces.', 'roll': 'The camera roll angle, -180 to 180. A value of 0 means the camera sits straight, positive values will turn it counter-clockwise and negative values will turn it clockwise. -180 or 180 means the camera is upside down.', 'fov': 'the field of view angle, 0.01 to 180. The higher this value is, the more you will be able to see what is to your sides.'}, result="Returns ''true'' if the arguments are valid, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetCameraMatrix', name='setCameraMatrix', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setCameraShakeLevel', return_types=['bool'], arguments=[FunctionArgument(name='shakeLevel', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the camera shake level (as seen on the ''Are you going to San Fierro?'' singleplayer mission).}}", arguments={'shakeLevel': ': an integer between 0 and 255, which represents the camera shake intensity level.'}, result="Returns ''true'' if the camera shake level was changed, ''false'' if the required argument is incorrect or missing."), oop=None, url=FunctionUrl(url='/wiki/SetCameraShakeLevel', name='setCameraShakeLevel', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setCameraTarget', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='target', argument_type='player', default_value='nil', optional=True)]), docs=FunctionDoc(description="This function allows you to set a player's camera to follow other elements instead. Currently supported element type is:\n*[[Player]]s", arguments={'thePlayer': 'The player whose camera you wish to modify.', 'target': 'The player who you want the camera to follow. If none is specified, the camera will target the player.'}, result="Returns ''true'' if the function was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='setCameraTarget', field='cameraTarget'), url=FunctionUrl(url='/wiki/SetCameraTarget', name='setCameraTarget', category='Camera functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setCameraTarget', return_types=['bool'], arguments=[FunctionArgument(name='target', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows you to set a player's camera to follow other elements instead. Currently supported element type is:\n*[[Player]]s", arguments={'target': 'The player who you want the local camera to follow.'}, result="Returns ''true'' if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetCameraTarget', name='setCameraTarget', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setCameraViewMode', return_types=['bool'], arguments=[FunctionArgument(name='viewMode', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows you to set the camera's view mode if you are inside a [[vehicle]]. This indicates at what distance the camera will follow the player.", arguments={'viewMode': ': The view mode you wish to use\n{{Camera view modes}}'}, result="Returns ''true'' if the view was set correctly, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetCameraViewMode', name='setCameraViewMode', category='Camera functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='addPedClothes', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='clothesTexture', argument_type='string', default_value=None, optional=False), FunctionArgument(name='clothesModel', argument_type='string', default_value=None, optional=False), FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the current clothes on a [[ped]]. ', arguments={'thePed': ': The ped whose clothes you want to change.', 'clothesTexture': ': A string determining the clothes texture that will be added. See the CJ Clothes|clothes catalog.', 'clothesModel': ': A string determining the clothes model that will be added. See the CJ Clothes|clothes catalog.', 'clothesType': ': A integer representing the clothes slot/type the clothes should be added to. See the CJ Clothes|clothes catalog.'}, result="This function returns ''true'' if the clothes were successfully added to the ped, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='addClothes', field=None), url=FunctionUrl(url='/wiki/AddPedClothes', name='addPedClothes', category='Clothes and body functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='addPedClothes', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='clothesTexture', argument_type='string', default_value=None, optional=False), FunctionArgument(name='clothesModel', argument_type='string', default_value=None, optional=False), FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the current clothes on a [[ped]]. ', arguments={'thePed': ': The ped whose clothes you want to change.', 'clothesTexture': ': A string determining the clothes texture that will be added. See the CJ Clothes|clothes catalog.', 'clothesModel': ': A string determining the clothes model that will be added. See the CJ Clothes|clothes catalog.', 'clothesType': ': A integer representing the clothes slot/type the clothes should be added to. See the CJ Clothes|clothes catalog.'}, result="This function returns ''true'' if the clothes were successfully added to the ped, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='addClothes', field=None), url=FunctionUrl(url='/wiki/AddPedClothes', name='addPedClothes', category='Clothes and body functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getBodyPartName', return_types=['string'], arguments=[FunctionArgument(name='bodyPartID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the name of a body part on a player.', arguments={'bodyPartID': ': An integer representing the body part ID you wish to retrieve the name of.\n{{BodyParts}}'}, result="This function returns a string containing the body part name if the ID is valid, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetBodyPartName', name='getBodyPartName', category='Clothes and body functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getBodyPartName', return_types=['string'], arguments=[FunctionArgument(name='bodyPartID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the name of a body part on a player.', arguments={'bodyPartID': ': An integer representing the body part ID you wish to retrieve the name of.\n{{BodyParts}}'}, result="This function returns a string containing the body part name if the ID is valid, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetBodyPartName', name='getBodyPartName', category='Clothes and body functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getClothesByTypeIndex', return_types=['string', 'string'], arguments=[FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='clothesIndex', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the texture and model of clothes by the clothes type and index.\n(Scans through the list of clothes for the specific type).', arguments={'clothesType': ': An integer representing the clothes slot/type to scan through.\n{{Clothes Textures}}', 'clothesIndex': ': An integer representing the index (0 based) set of clothes in the list you wish to retrieve. Each type has a different number of valid indexes.'}, result="This function returns 2 strings, a texture and model respectively, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/GetClothesByTypeIndex', name='getClothesByTypeIndex', category='Clothes and body functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getClothesByTypeIndex', return_types=['string', 'string'], arguments=[FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='clothesIndex', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the texture and model of clothes by the clothes type and index.\n(Scans through the list of clothes for the specific type).', arguments={'clothesType': ': An integer representing the clothes slot/type to scan through.\n{{Clothes Textures}}', 'clothesIndex': ': An integer representing the index (0 based) set of clothes in the list you wish to retrieve. Each type has a different number of valid indexes.'}, result="This function returns 2 strings, a texture and model respectively, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/GetClothesByTypeIndex', name='getClothesByTypeIndex', category='Clothes and body functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getClothesTypeName', return_types=['string'], arguments=[FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the name of a certain clothes type.', arguments={'clothesType': ': An integer determining the type of clothes you want to get the clothes of.\n{{Clothes Textures}}'}, result="This function returns a string (the name of the clothes type) if found, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetClothesTypeName', name='getClothesTypeName', category='Clothes and body functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getClothesTypeName', return_types=['string'], arguments=[FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the name of a certain clothes type.', arguments={'clothesType': ': An integer determining the type of clothes you want to get the clothes of.\n{{Clothes Textures}}'}, result="This function returns a string (the name of the clothes type) if found, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetClothesTypeName', name='getClothesTypeName', category='Clothes and body functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedClothes', return_types=['string,', 'string'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the current clothes texture and model of a certain type on a [[ped]].', arguments={'thePed': 'The ped whose clothes you want to retrieve.', 'clothesType': 'The type/slot of clothing you want to get.\n{{Clothes Textures}}'}, result="This function returns 2 [[string|strings]], the clothes texture and model. The first return value will be ''false'' if this player's clothes type is empty or an invalid player was specified."), oop=FunctionOOP(class_name='ped', method_name='getClothes', field=None), url=FunctionUrl(url='/wiki/GetPedClothes', name='getPedClothes', category='Clothes and body functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPedClothes', return_types=['string,', 'string'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the current clothes texture and model of a certain type on a [[ped]].', arguments={'thePed': 'The ped whose clothes you want to retrieve.', 'clothesType': 'The type/slot of clothing you want to get.\n{{Clothes Textures}}'}, result="This function returns 2 [[string|strings]], the clothes texture and model. The first return value will be ''false'' if this player's clothes type is empty or an invalid player was specified."), oop=FunctionOOP(class_name='ped', method_name='getClothes', field=None), url=FunctionUrl(url='/wiki/GetPedClothes', name='getPedClothes', category='Clothes and body functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getTypeIndexFromClothes', return_types=['int', 'int'], arguments=[FunctionArgument(name='clothesTexture', argument_type='string', default_value=None, optional=False), FunctionArgument(name='clothesModel', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the clothes type and index from the texture and model.\n(Scans through the list of clothes for the specific type).', arguments={'clothesTexture': ': A string determining the clothes texture that you wish to retrieve the type and index from. See the CJ Clothes|clothes catalog.', 'clothesModel': ': A string determining the corresponding clothes model that you wish to retrieve the type and index from. See the CJ Clothes|clothes catalog.'}, result="This function returns two integers, type and index respectively, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/GetTypeIndexFromClothes', name='getTypeIndexFromClothes', category='Clothes and body functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getTypeIndexFromClothes', return_types=['int', 'int'], arguments=[FunctionArgument(name='clothesTexture', argument_type='string', default_value=None, optional=False), FunctionArgument(name='clothesModel', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the clothes type and index from the texture and model.\n(Scans through the list of clothes for the specific type).', arguments={'clothesTexture': ': A string determining the clothes texture that you wish to retrieve the type and index from. See the CJ Clothes|clothes catalog.', 'clothesModel': ': A string determining the corresponding clothes model that you wish to retrieve the type and index from. See the CJ Clothes|clothes catalog.'}, result="This function returns two integers, type and index respectively, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/GetTypeIndexFromClothes', name='getTypeIndexFromClothes', category='Clothes and body functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removePedClothes', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='clothesTexture', argument_type='string', default_value=None, optional=False), FunctionArgument(name='clothesModel', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to remove the current clothes of a certain type on a [[ped]]. It will remove them if the clothesTexture and clothesModel aren't specified, or if they match the current clothes on that slot.", arguments={'thePed': ': The ped you want to remove clothes from.', 'clothesType': ': the clothes slot/type to remove. See the CJ Clothes|clothes catalog.', 'clothesTexture': ': (Server only) A string determining the clothes texture that will be removed. See the CJ Clothes|clothes catalog.', 'clothesModel': ': (Server only) A string determining the clothes model that will be removed. See the CJ Clothes|clothes catalog.'}, result="This function returns ''true'' if the clothes were successfully removed from the ped, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name="removeClothes}}\n\n===Required Arguments===\n*'''thePed''': The [[ped]] you want to remove clothes from.\n*'''clothesType''': the clothes slot/type to remove. See the [[CJ Clothes", field="clothes catalog]].\n\n===Optional Arguments===\n*'''clothesTexture''': (Server only) A string determining the clothes texture that will be removed. See the [[CJ Clothes"), url=FunctionUrl(url='/wiki/RemovePedClothes', name='removePedClothes', category='Clothes and body functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='removePedClothes', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='clothesTexture', argument_type='string', default_value=None, optional=False), FunctionArgument(name='clothesModel', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to remove the current clothes of a certain type on a [[ped]]. It will remove them if the clothesTexture and clothesModel aren't specified, or if they match the current clothes on that slot.", arguments={'thePed': ': The ped you want to remove clothes from.', 'clothesType': ': the clothes slot/type to remove. See the CJ Clothes|clothes catalog.', 'clothesTexture': ': (Server only) A string determining the clothes texture that will be removed. See the CJ Clothes|clothes catalog.', 'clothesModel': ': (Server only) A string determining the clothes model that will be removed. See the CJ Clothes|clothes catalog.'}, result="This function returns ''true'' if the clothes were successfully removed from the ped, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name="removeClothes}}\n\n===Required Arguments===\n*'''thePed''': The [[ped]] you want to remove clothes from.\n*'''clothesType''': the clothes slot/type to remove. See the [[CJ Clothes", field="clothes catalog]].\n\n===Optional Arguments===\n*'''clothesTexture''': (Server only) A string determining the clothes texture that will be removed. See the [[CJ Clothes"), url=FunctionUrl(url='/wiki/RemovePedClothes', name='removePedClothes', category='Clothes and body functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='addColPolygonPoint', return_types=['bool'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='fX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value='0', optional=True)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape polygon you wish add a point to.', 'fX': 'The X position of the new bound point.', 'fY': 'The Y position of the new bound point.\n{{OptionalArg}}', 'index': 'The index where the new point will be inserted in the polygon. The points are indexed in order, with 1 being the first bound point. Passing 0 will insert the point as the last one in the polygon.'}, result="Returns ''true'' if the polygon was changed, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='addPoint', field=None), url=FunctionUrl(url='/wiki/AddColPolygonPoint', name='addColPolygonPoint', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='addColPolygonPoint', return_types=['bool'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='fX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value='0', optional=True)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape polygon you wish add a point to.', 'fX': 'The X position of the new bound point.', 'fY': 'The Y position of the new bound point.\n{{OptionalArg}}', 'index': 'The index where the new point will be inserted in the polygon. The points are indexed in order, with 1 being the first bound point. Passing 0 will insert the point as the last one in the polygon.'}, result="Returns ''true'' if the polygon was changed, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='addPoint', field=None), url=FunctionUrl(url='/wiki/AddColPolygonPoint', name='addColPolygonPoint', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createColCircle', return_types=['colshape'], arguments=[FunctionArgument(name='fX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='radius', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function creates a collision circle. This is a shape that has a position and a radius and infinite height that you can use to detect a player's presence. Events will be triggered when a player enters or leaves it.", arguments={'fX': 'The collision circles center points X axis position', 'fY': 'The collision circles center points Y axis position', 'radius': 'The radius of the collision circle. Can not be smaller than 0.1'}, result="Returns a [[colshape]] element if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/CreateColCircle', name='createColCircle', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createColCircle', return_types=['colshape'], arguments=[FunctionArgument(name='fX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='radius', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function creates a collision circle. This is a shape that has a position and a radius and infinite height that you can use to detect a player's presence. Events will be triggered when a player enters or leaves it.", arguments={'fX': 'The collision circles center points X axis position', 'fY': 'The collision circles center points Y axis position', 'radius': 'The radius of the collision circle. Can not be smaller than 0.1'}, result="Returns a [[colshape]] element if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/CreateColCircle', name='createColCircle', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createColCuboid', return_types=['colshape'], arguments=[FunctionArgument(name='fX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fWidth', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fDepth', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fHeight', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function creates a collision cuboid. This is a shape that has a position, width, depth and height. See [http://en.wikipedia.org/wiki/Cuboid Wikipedia] for a definition of a cuboid. The XYZ of the col starts at the southwest bottom corner of the shape.', arguments={'fX': 'The X position of the collision cuboids western side', 'fY': 'The Y position of the collision cuboids southern side', 'fZ': 'The Z position of the collision cuboids lowest side', 'fWidth': 'The collision cuboids width', 'fDepth': 'The collision cuboids depth', 'fHeight': 'The collision cuboids height'}, result="Returns a [[colshape]] element if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/CreateColCuboid', name='createColCuboid', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createColCuboid', return_types=['colshape'], arguments=[FunctionArgument(name='fX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fWidth', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fDepth', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fHeight', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function creates a collision cuboid. This is a shape that has a position, width, depth and height. See [http://en.wikipedia.org/wiki/Cuboid Wikipedia] for a definition of a cuboid. The XYZ of the col starts at the southwest bottom corner of the shape.', arguments={'fX': 'The X position of the collision cuboids western side', 'fY': 'The Y position of the collision cuboids southern side', 'fZ': 'The Z position of the collision cuboids lowest side', 'fWidth': 'The collision cuboids width', 'fDepth': 'The collision cuboids depth', 'fHeight': 'The collision cuboids height'}, result="Returns a [[colshape]] element if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/CreateColCuboid', name='createColCuboid', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createColPolygon', return_types=['colshape'], arguments=[FunctionArgument(name='fCenterX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fCenterY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fX1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fX2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fX3', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY3', argument_type='float', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description="This function creates a collision polygon. See [http://en.wikipedia.org/wiki/Polygon Wikipedia] for a definition of a polygon. The first set of X Y of this shape is not part of the colshape bounds, so can set anywhere in the game world, however for performance, place it as close to the centre of the polygon as you can. It should be noted this shape is '''2D'''. There should be at least 3 bound points set. ", arguments={'fCenterX': 'The X position of the collision polygons position - the position that will be returned from getElementPosition.', 'fCenterY': 'The Y position of the collision polygons position - the position that will be returned from getElementPosition.', 'fX1': 'The 1st X position of the collision polygons bound point', 'fY1': 'The 1st Y position of the collision polygons bound point', 'fX2': 'The 2nd X position of the collision polygons bound point', 'fY2': 'The 2nd Y position of the collision polygons bound point', 'fX3': 'The 3rd X position of the collision polygons bound point', 'fY3': 'The 3rd Y position of the collision polygons bound point', '... ': 'From the 3rd position you can have as many points as you require to create the colshape.'}, result="Returns a [[colshape]] element if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/CreateColPolygon', name='createColPolygon', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createColPolygon', return_types=['colshape'], arguments=[FunctionArgument(name='fCenterX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fCenterY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fX1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fX2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fX3', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY3', argument_type='float', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description="This function creates a collision polygon. See [http://en.wikipedia.org/wiki/Polygon Wikipedia] for a definition of a polygon. The first set of X Y of this shape is not part of the colshape bounds, so can set anywhere in the game world, however for performance, place it as close to the centre of the polygon as you can. It should be noted this shape is '''2D'''. There should be at least 3 bound points set. ", arguments={'fCenterX': 'The X position of the collision polygons position - the position that will be returned from getElementPosition.', 'fCenterY': 'The Y position of the collision polygons position - the position that will be returned from getElementPosition.', 'fX1': 'The 1st X position of the collision polygons bound point', 'fY1': 'The 1st Y position of the collision polygons bound point', 'fX2': 'The 2nd X position of the collision polygons bound point', 'fY2': 'The 2nd Y position of the collision polygons bound point', 'fX3': 'The 3rd X position of the collision polygons bound point', 'fY3': 'The 3rd Y position of the collision polygons bound point', '... ': 'From the 3rd position you can have as many points as you require to create the colshape.'}, result="Returns a [[colshape]] element if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/CreateColPolygon', name='createColPolygon', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createColRectangle', return_types=['colshape'], arguments=[FunctionArgument(name='fX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fWidth', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fHeight', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function creates a collision rectangle. This is a shape that has a position and a width and a depth. See [http://en.wikipedia.org/wiki/Rectangle Rectangle] for a definition of a rectangle. XY marks on the south west corner of the colshape.', arguments={'fX': 'The X position of the collision rectangles west side', 'fY': 'The Y position of the collision rectangles south side', 'fWidth': 'The collision rectangles width', 'fHeight': 'The collision rectangles height'}, result="Returns a [[colshape]] element if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/CreateColRectangle', name='createColRectangle', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createColRectangle', return_types=['colshape'], arguments=[FunctionArgument(name='fX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fWidth', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fHeight', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function creates a collision rectangle. This is a shape that has a position and a width and a depth. See [http://en.wikipedia.org/wiki/Rectangle Rectangle] for a definition of a rectangle. XY marks on the south west corner of the colshape.', arguments={'fX': 'The X position of the collision rectangles west side', 'fY': 'The Y position of the collision rectangles south side', 'fWidth': 'The collision rectangles width', 'fHeight': 'The collision rectangles height'}, result="Returns a [[colshape]] element if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/CreateColRectangle', name='createColRectangle', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createColSphere', return_types=['colshape'], arguments=[FunctionArgument(name='fX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fRadius', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function creates a collision sphere. This is a shape that has a position and a radius. See [http://en.wikipedia.org/wiki/Sphere Wikipedia] for a definition of a sphere.', arguments={'fX': 'The collision spheres center points X axis position', 'fY': 'The collision spheres center points Y axis position', 'fZ': 'The collision spheres center points Z axis position', 'fRadius': 'The collision spheres radius'}, result="Returns a [[colshape]] element if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/CreateColSphere', name='createColSphere', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createColSphere', return_types=['colshape'], arguments=[FunctionArgument(name='fX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fRadius', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function creates a collision sphere. This is a shape that has a position and a radius. See [http://en.wikipedia.org/wiki/Sphere Wikipedia] for a definition of a sphere.', arguments={'fX': 'The collision spheres center points X axis position', 'fY': 'The collision spheres center points Y axis position', 'fZ': 'The collision spheres center points Z axis position', 'fRadius': 'The collision spheres radius'}, result="Returns a [[colshape]] element if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/CreateColSphere', name='createColSphere', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createColTube', return_types=['colshape'], arguments=[FunctionArgument(name='fX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fRadius', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fHeight', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function creates a collision tube. This is a shape that has a position and a 2D (X/Y) radius and a height. See [http://en.wikipedia.org/wiki/Cylinder_(geometry) Cylinder] for a definition of a tube. A tube is similar to a colcircle, except that it has a limited height, this means you can limit the distance above the position defined by (fX, fY, fZ) that the collision is detected.', arguments={'fX': 'The position of the base of the tubes center on the X axis', 'fY': 'The position of the base of the tubes center on the Y axis', 'fZ': 'The position of the base of the tubes center on the Z axis', 'fRadius': 'The collision tubes radius', 'fHeight': 'The collision tubes height'}, result="Returns a [[colshape]] element if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/CreateColTube', name='createColTube', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createColTube', return_types=['colshape'], arguments=[FunctionArgument(name='fX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fRadius', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fHeight', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function creates a collision tube. This is a shape that has a position and a 2D (X/Y) radius and a height. See [http://en.wikipedia.org/wiki/Cylinder_(geometry) Cylinder] for a definition of a tube. A tube is similar to a colcircle, except that it has a limited height, this means you can limit the distance above the position defined by (fX, fY, fZ) that the collision is detected.', arguments={'fX': 'The position of the base of the tubes center on the X axis', 'fY': 'The position of the base of the tubes center on the Y axis', 'fZ': 'The position of the base of the tubes center on the Z axis', 'fRadius': 'The collision tubes radius', 'fHeight': 'The collision tubes height'}, result="Returns a [[colshape]] element if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/CreateColTube', name='createColTube', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getColPolygonHeight', return_types=['float,', 'float'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False)]), docs=FunctionDoc(description='By default, a colshape polygon is infinitely tall.}}', arguments={'shape': 'The colshape polygon'}, result="Returns two [[float]]s, indicating the floor and ceiling of the colshape height, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='getHeight', field="}}\n\n===Required Arguments=== \n*'''shape:''' The [[colshape]] polygon\n\n===Returns===\nReturns two [[float]]s, indicating the floor and ceiling of the colshape height, ''false'' if invalid arguments were passed.\n\n"), url=FunctionUrl(url='/wiki/GetColPolygonHeight', name='getColPolygonHeight', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getColPolygonHeight', return_types=['float,', 'float'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False)]), docs=FunctionDoc(description='By default, a colshape polygon is infinitely tall.}}', arguments={'shape': 'The colshape polygon'}, result="Returns two [[float]]s, indicating the floor and ceiling of the colshape height, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='getHeight', field="}}\n\n===Required Arguments=== \n*'''shape:''' The [[colshape]] polygon\n\n===Returns===\nReturns two [[float]]s, indicating the floor and ceiling of the colshape height, ''false'' if invalid arguments were passed.\n\n"), url=FunctionUrl(url='/wiki/GetColPolygonHeight', name='getColPolygonHeight', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getColPolygonPoints', return_types=['table'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape polygon you wish to get the points of.'}, result="Returns a [[table]] of coordinates, each coordinate being a [[table]] containing the x and y position of a bound point, ''false'' if invalid arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/GetColPolygonPoints', name='getColPolygonPoints', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getColPolygonPoints', return_types=['table'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape polygon you wish to get the points of.'}, result="Returns a [[table]] of coordinates, each coordinate being a [[table]] containing the x and y position of a bound point, ''false'' if invalid arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/GetColPolygonPoints', name='getColPolygonPoints', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getColPolygonPointPosition', return_types=['float,', 'float'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape polygon you wish to change.', 'index': 'The index of the point you wish to retrieve. The points are indexed in order, with 1 being the first bound point.'}, result="Returns two [[float]]s, x and y, indicating the position of the point, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='getPointPosition', field=None), url=FunctionUrl(url='/wiki/GetColPolygonPointPosition', name='getColPolygonPointPosition', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getColPolygonPointPosition', return_types=['float,', 'float'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape polygon you wish to change.', 'index': 'The index of the point you wish to retrieve. The points are indexed in order, with 1 being the first bound point.'}, result="Returns two [[float]]s, x and y, indicating the position of the point, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='getPointPosition', field=None), url=FunctionUrl(url='/wiki/GetColPolygonPointPosition', name='getColPolygonPointPosition', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getColShapeType', return_types=['int'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape you wish to get the type of.'}, result="Returns ''false'' if invalid arguments were passed, or an [[int]]eger of the type of the colshape, which include:\n*'''0:''' circle\n*'''1:''' cuboid\n*'''2:''' sphere\n*'''3:''' rectangle\n*'''4:''' polygon\n*'''5:''' tube"), oop=FunctionOOP(class_name='colshape', method_name='getShapeType', field='shapeType'), url=FunctionUrl(url='/wiki/GetColShapeType', name='getColShapeType', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getColShapeType', return_types=['int'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape you wish to get the type of.'}, result="Returns ''false'' if invalid arguments were passed, or an [[int]]eger of the type of the colshape, which include:\n*'''0:''' circle\n*'''1:''' cuboid\n*'''2:''' sphere\n*'''3:''' rectangle\n*'''4:''' polygon\n*'''5:''' tube"), oop=FunctionOOP(class_name='colshape', method_name='getShapeType', field='shapeType'), url=FunctionUrl(url='/wiki/GetColShapeType', name='getColShapeType', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getColShapeRadius', return_types=['float'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape you wish to get the radius of.'}, result="Returns a [[float]] containing the radius of the colshape, ''false'' if an invalid colshape was passed."), oop=FunctionOOP(class_name='colshape', method_name='getRadius', field=None), url=FunctionUrl(url='/wiki/GetColShapeRadius', name='getColShapeRadius', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getColShapeRadius', return_types=['float'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape you wish to get the radius of.'}, result="Returns a [[float]] containing the radius of the colshape, ''false'' if an invalid colshape was passed."), oop=FunctionOOP(class_name='colshape', method_name='getRadius', field=None), url=FunctionUrl(url='/wiki/GetColShapeRadius', name='getColShapeRadius', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getColShapeSize', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape you wish to get the size of.'}, result="Returns up to 3 [[float]]s depending on the colshape type (see below), ''false'' if invalid arguments were passed.\n*''cuboid:'' width, depth, height.\n*''rectangle:'' width, height.\n*''tube:'' height."), oop=FunctionOOP(class_name='colshape', method_name='getSize', field=None), url=FunctionUrl(url='/wiki/GetColShapeSize', name='getColShapeSize', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getColShapeSize', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape you wish to get the size of.'}, result="Returns up to 3 [[float]]s depending on the colshape type (see below), ''false'' if invalid arguments were passed.\n*''cuboid:'' width, depth, height.\n*''rectangle:'' width, height.\n*''tube:'' height."), oop=FunctionOOP(class_name='colshape', method_name='getSize', field=None), url=FunctionUrl(url='/wiki/GetColShapeSize', name='getColShapeSize', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementColShape', return_types=['colshape'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='Some elements have an associated colshape, for example [[Marker]] and [[Pickup]]. This function is used to get the associated colshape.', arguments={'theElement': 'The element you want to get the colshape of'}, result="Returns ''colshape'' of the element, ''false'' if not or an invalid argument was passed to the function."), oop=FunctionOOP(class_name='element', method_name='getColShape', field='colShape'), url=FunctionUrl(url='/wiki/GetElementColShape', name='getElementColShape', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementColShape', return_types=['colshape'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='Some elements have an associated colshape, for example [[Marker]] and [[Pickup]]. This function is used to get the associated colshape.', arguments={'theElement': 'The element you want to get the colshape of'}, result="Returns ''colshape'' of the element, ''false'' if not or an invalid argument was passed to the function."), oop=FunctionOOP(class_name='element', method_name='getColShape', field='colShape'), url=FunctionUrl(url='/wiki/GetElementColShape', name='getElementColShape', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementsWithinColShape', return_types=['table'], arguments=[FunctionArgument(name='theShape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='elemType', argument_type='string', default_value='nil', optional=True)]), docs=FunctionDoc(description="This function is used to retrieve a list of all elements in a colshape, of the specified type.\n* For legacy reasons, a colshape created on the client does not collide with elements already existing at that location until they first move\n* This function doesn't verify whether elements are in the same dimension and interior, additional checks could be implemented manually if they are needed\n}}", arguments={'theShape': 'The colshape you want to get the elements from.', 'elemType': 'The type of element you want a list of. This can be any element type, the common ones being:', '"player"': 'A player connected to the server', '"ped"': 'A ped', '"vehicle"': 'A vehicle', '"object"': 'An object', '"pickup"': 'A pickup', '"marker"': 'A marker', '"spawnpoint"': 'A spawnpoint', '"remoteclient"': 'A remote client connected to the server', '"console"': 'The server Console-->'}, result="Returns a [[table]] containing all the elements inside the colshape, of the specified type. Returns an empty [[table]] if there are no elements inside. Returns ''false'' if the colshape is invalid."), oop=None, url=FunctionUrl(url='/wiki/GetElementsWithinColShape', name='getElementsWithinColShape', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementsWithinColShape', return_types=['table'], arguments=[FunctionArgument(name='theShape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='elemType', argument_type='string', default_value='nil', optional=True)]), docs=FunctionDoc(description="This function is used to retrieve a list of all elements in a colshape, of the specified type.\n* For legacy reasons, a colshape created on the client does not collide with elements already existing at that location until they first move\n* This function doesn't verify whether elements are in the same dimension and interior, additional checks could be implemented manually if they are needed\n}}", arguments={'theShape': 'The colshape you want to get the elements from.', 'elemType': 'The type of element you want a list of. This can be any element type, the common ones being:', '"player"': 'A player connected to the server', '"ped"': 'A ped', '"vehicle"': 'A vehicle', '"object"': 'An object', '"pickup"': 'A pickup', '"marker"': 'A marker', '"spawnpoint"': 'A spawnpoint', '"remoteclient"': 'A remote client connected to the server', '"console"': 'The server Console-->'}, result="Returns a [[table]] containing all the elements inside the colshape, of the specified type. Returns an empty [[table]] if there are no elements inside. Returns ''false'' if the colshape is invalid."), oop=None, url=FunctionUrl(url='/wiki/GetElementsWithinColShape', name='getElementsWithinColShape', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isElementWithinColShape', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theShape', argument_type='colshape', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to determine if an element is within a collision shape. Please note that for legacy reasons, a colshape created on the client does not collide with elements already existing at that location until they first move. Please also note that before 1.0.3, this did not function correctly when moving a colshape.\nPlease note that this function doesn't verify whether element is in the same dimension and interior, additional checks could be implemented manually if they are needed.", arguments={'theElement': 'The element youre checking.', 'theShape': 'The colshape youre checking'}, result="Returns ''true'' if the element is within the colshape, ''false'' otherwise"), oop=None, url=FunctionUrl(url='/wiki/IsElementWithinColShape', name='isElementWithinColShape', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isElementWithinColShape', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theShape', argument_type='colshape', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to determine if an element is within a collision shape. Please note that for legacy reasons, a colshape created on the client does not collide with elements already existing at that location until they first move. Please also note that before 1.0.3, this did not function correctly when moving a colshape.\nPlease note that this function doesn't verify whether element is in the same dimension and interior, additional checks could be implemented manually if they are needed.", arguments={'theElement': 'The element youre checking.', 'theShape': 'The colshape youre checking'}, result="Returns ''true'' if the element is within the colshape, ''false'' otherwise"), oop=None, url=FunctionUrl(url='/wiki/IsElementWithinColShape', name='isElementWithinColShape', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isInsideColShape', return_types=['bool'], arguments=[FunctionArgument(name='theShape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theShape': 'The colshape youre checking the position against.', 'posX': 'The X coordinate of the position youre checking.', 'posY': 'The Y coordinate of the position youre checking.', 'posZ': 'The Z coordinate of the position youre checking.'}, result="Returns ''true'' if the position is inside the colshape, ''false'' if it isn't or if any parameters are invalid."), oop=None, url=FunctionUrl(url='/wiki/IsInsideColShape', name='isInsideColShape', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isInsideColShape', return_types=['bool'], arguments=[FunctionArgument(name='theShape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theShape': 'The colshape youre checking the position against.', 'posX': 'The X coordinate of the position youre checking.', 'posY': 'The Y coordinate of the position youre checking.', 'posZ': 'The Z coordinate of the position youre checking.'}, result="Returns ''true'' if the position is inside the colshape, ''false'' if it isn't or if any parameters are invalid."), oop=None, url=FunctionUrl(url='/wiki/IsInsideColShape', name='isInsideColShape', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removeColPolygonPoint', return_types=['bool'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape polygon you wish to remove a point from.', 'index': 'The index of the point you wish to remove. The points are indexed in order, with 1 being the first bound point. You cant remove the last 3 points.'}, result="Returns ''true'' if the polygon was changed, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='removePoint', field=None), url=FunctionUrl(url='/wiki/RemoveColPolygonPoint', name='removeColPolygonPoint', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='removeColPolygonPoint', return_types=['bool'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape polygon you wish to remove a point from.', 'index': 'The index of the point you wish to remove. The points are indexed in order, with 1 being the first bound point. You cant remove the last 3 points.'}, result="Returns ''true'' if the polygon was changed, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='removePoint', field=None), url=FunctionUrl(url='/wiki/RemoveColPolygonPoint', name='removeColPolygonPoint', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setColPolygonHeight', return_types=['bool'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='floor', argument_type='float', default_value=None, optional=False), FunctionArgument(name='ceil', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='By default, a colshape polygon is infinitely tall.}}', arguments={'shape': 'The colshape polygon', 'floor': 'The polygon floor (lowest Z coordinate). Parse false to reset this value to 0.', 'ceil': 'The polygon ceiling (highest Z coordinate). Parse false to reset this value to infinitely tall.'}, result="Returns ''true'' if the polygon was changed, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='setHeight', field="}}\n\n===Required Arguments=== \n*'''shape:''' The [[colshape]] polygon\n*'''floor:''' The polygon floor (lowest Z coordinate). Parse ''false'' to reset this value to 0.\n*'''ceil:''' The polygon ceiling (highest Z coordinate). Parse ''false'' to reset this value to infinitely tall.\n\n===Returns===\nReturns ''true'' if the polygon was changed, ''false'' if invalid arguments were passed.\n\n"), url=FunctionUrl(url='/wiki/SetColPolygonHeight', name='setColPolygonHeight', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setColPolygonHeight', return_types=['bool'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='floor', argument_type='float', default_value=None, optional=False), FunctionArgument(name='ceil', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='By default, a colshape polygon is infinitely tall.}}', arguments={'shape': 'The colshape polygon', 'floor': 'The polygon floor (lowest Z coordinate). Parse false to reset this value to 0.', 'ceil': 'The polygon ceiling (highest Z coordinate). Parse false to reset this value to infinitely tall.'}, result="Returns ''true'' if the polygon was changed, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='setHeight', field="}}\n\n===Required Arguments=== \n*'''shape:''' The [[colshape]] polygon\n*'''floor:''' The polygon floor (lowest Z coordinate). Parse ''false'' to reset this value to 0.\n*'''ceil:''' The polygon ceiling (highest Z coordinate). Parse ''false'' to reset this value to infinitely tall.\n\n===Returns===\nReturns ''true'' if the polygon was changed, ''false'' if invalid arguments were passed.\n\n"), url=FunctionUrl(url='/wiki/SetColPolygonHeight', name='setColPolygonHeight', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setColPolygonPointPosition', return_types=['bool'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False), FunctionArgument(name='fX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape polygon you wish to change.', 'index': 'The index of the point you wish to change. The points are indexed in order, with 1 being the first bound point.', 'fX': 'The new X position of the bound point.', 'fY': 'The new Y position of the bound point.'}, result="Returns ''true'' if the polygon was changed, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='setPointPosition', field=None), url=FunctionUrl(url='/wiki/SetColPolygonPointPosition', name='setColPolygonPointPosition', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setColPolygonPointPosition', return_types=['bool'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False), FunctionArgument(name='fX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fY', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape polygon you wish to change.', 'index': 'The index of the point you wish to change. The points are indexed in order, with 1 being the first bound point.', 'fX': 'The new X position of the bound point.', 'fY': 'The new Y position of the bound point.'}, result="Returns ''true'' if the polygon was changed, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='setPointPosition', field=None), url=FunctionUrl(url='/wiki/SetColPolygonPointPosition', name='setColPolygonPointPosition', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setColShapeRadius', return_types=['bool'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='radius', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape you wish to change the radius of.', 'radius': 'The radius you want to set.'}, result="Returns ''true'' if the radius was changed, or ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='setRadius', field=None), url=FunctionUrl(url='/wiki/SetColShapeRadius', name='setColShapeRadius', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setColShapeRadius', return_types=['bool'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='radius', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape you wish to change the radius of.', 'radius': 'The radius you want to set.'}, result="Returns ''true'' if the radius was changed, or ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='setRadius', field=None), url=FunctionUrl(url='/wiki/SetColShapeRadius', name='setColShapeRadius', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setColShapeSize', return_types=['bool'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='depth', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape you wish to change the size of.', 'width': 'The collision cuboids width.', 'depth': 'The collision cuboids depth.', 'height': 'The collision cuboids height.'}, result="Returns ''true'' if the size was changed, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='setSize', field=None), url=FunctionUrl(url='/wiki/SetColShapeSize', name='setColShapeSize', category='Collision shape functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setColShapeSize', return_types=['bool'], arguments=[FunctionArgument(name='shape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='depth', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'shape': 'The colshape you wish to change the size of.', 'width': 'The collision cuboids width.', 'depth': 'The collision cuboids depth.', 'height': 'The collision cuboids height.'}, result="Returns ''true'' if the size was changed, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='colshape', method_name='setSize', field=None), url=FunctionUrl(url='/wiki/SetColShapeSize', name='setColShapeSize', category='Collision shape functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getCursorAlpha', return_types=['int'], arguments=[]), docs=FunctionDoc(description="This function is used to get alpha (transparency) from the client's cursor.", arguments={}, result='Returns a int, 0-255, where 255 is fully opaque and 0 is fully transparent.'), oop=None, url=FunctionUrl(url='/wiki/GetCursorAlpha', name='getCursorAlpha', category='Cursor functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getCursorPosition', return_types=['float,', 'float,', 'float,', 'float,', 'float'], arguments=[]), docs=FunctionDoc(description='This function gets the current position of the mouse cursor. Note that for performance reasons, the world position returned is always 300 units away. If you want the exact world point (similar to [[onClientClick]]), use [[processLineOfSight]] between the camera position and the worldX/Y/Z result of this function. (See example below)', arguments={}, result="Returns 5 values: ''cursorX'', ''cursorY'', ''worldX'', ''worldY'', ''worldZ''. The first two values are the 2D relative screen coordinates of the cursor: ''cursorX'' goes from 0 (left side of the screen) to 1 (right side), ''cursorY'' goes from 0 (top) to 1 (bottom). The 3 values that follow are the 3D world map coordinates that the cursor points at. If the cursor isn't showing, returns ''false'' as the first value."), oop=None, url=FunctionUrl(url='/wiki/GetCursorPosition', name='getCursorPosition', category='Cursor functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isCursorShowing', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to determine whether or not a player's cursor is showing.", arguments={'thePlayer': 'The player you want to get cursor state of.'}, result="Returns ''true'' if the player's cursor is showing, ''false'' if it isn't or if invalid parameters were passed."), oop=None, url=FunctionUrl(url='/wiki/IsCursorShowing', name='isCursorShowing', category='Cursor functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isCursorShowing', return_types=['bool'], arguments=[]), docs=FunctionDoc(description="This function is used to determine whether or not a player's cursor is showing.", arguments={}, result="Returns ''true'' if the player's cursor is showing, ''false'' if it isn't."), oop=None, url=FunctionUrl(url='/wiki/IsCursorShowing', name='isCursorShowing', category='Cursor functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setCursorAlpha', return_types=['bool'], arguments=[FunctionArgument(name='alpha', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to change alpha (transparency) from the client's cursor.", arguments={'alpha ': ': The alpha value to set. Value can be 0-255, where 255 is fully opaque and 0 is fully transparent.'}, result="Returns ''true'' if the new alpha value was set, or ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetCursorAlpha', name='setCursorAlpha', category='Cursor functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setCursorPosition', return_types=['bool'], arguments=[FunctionArgument(name='cursorX', argument_type='int', default_value=None, optional=False), FunctionArgument(name='cursorY', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the current position of the mouse cursor.', arguments={'cursorX': 'Position over the X axis', 'cursorY': 'Position over the Y axis'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the position has been successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetCursorPosition', name='setCursorPosition', category='Cursor functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='showCursor', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='show', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='toggleControls', argument_type='bool', default_value='true', optional=False)]), docs=FunctionDoc(description="This function is used to show or hide a [[player]]'s cursor.", arguments={'thePlayer': 'The player you want to show or hide the cursor of.', 'show': 'A boolean value determining whether to show (true) or hide (false) the cursor.\n{{OptionalArg}} ', 'toggleControls': 'A boolean value determining whether to disable controls whilst the cursor is showing.  true implies controls are disabled, false implies controls remain enabled.'}, result="Returns ''true'' if the player's cursor was shown or hidden successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ShowCursor', name='showCursor', category='Cursor functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='showCursor', return_types=['bool'], arguments=[FunctionArgument(name='show', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='toggleControls', argument_type='bool', default_value='true', optional=False)]), docs=FunctionDoc(description="This function is used to show or hide a [[player]]'s cursor.", arguments={'show': 'A boolean value determining whether to show (true) or hide (false) the cursor.\n{{OptionalArg}} ', 'toggleControls': 'A boolean value determining whether to disable controls whilst the cursor is showing.  true implies controls are disabled, false implies controls remain enabled.'}, result="Returns ''true'' if the player's cursor was shown or hidden successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ShowCursor', name='showCursor', category='Cursor functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxConvertPixels', return_types=['string'], arguments=[FunctionArgument(name='pixels', argument_type='string', default_value=None, optional=False), FunctionArgument(name='newFormat', argument_type='string', default_value=None, optional=False), FunctionArgument(name='quality', argument_type='int', default_value='80', optional=True)]), docs=FunctionDoc(description='This function converts [[Texture_pixels|pixels]] from one format to another.', arguments={'pixels ': 'The pixels to convert the format of', 'newFormat ': 'The new format required (plain or png or jpeg)', 'quality ': 'The quality of the returned pixels if the new format is jpeg'}, result="Returns a copy of the pixels in the new format, or ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/DxConvertPixels', name='dxConvertPixels', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxCreateFont', return_types=['element'], arguments=[FunctionArgument(name='filepath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='size', argument_type='int', default_value='9', optional=True), FunctionArgument(name='bold', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='quality', argument_type='string', default_value='"proof"', optional=True)]), docs=FunctionDoc(description="<br/>\nThis function creates a [[DX font]] element that can be used in [[dxDrawText]]. Successful font creation is not guaranteed, and may fail due to hardware or memory limitations.\nTo see if creation is likely to fail, use [[dxGetStatus]]. (When '''VideoMemoryFreeForMTA''' is zero, failure ''is'' guaranteed.)", arguments={'filepath': 'the name of the file containing the font', 'size': 'size of the font', 'bold': 'flag to indicate if the font should be bold', 'quality': 'the font quality\n** "default": not the actual default\n** "draft"\n** "proof": the default \n** "nonantialiased"\n** "antialiased"\n** "cleartype"\n** "cleartype_natural"'}, result="Returns a [[DX font]] element if successful, ''false'' if invalid arguments were passed to the function, or there is insufficient resources available.\n'''You should always check to see if this function has returned false.'''"), oop=None, url=FunctionUrl(url='/wiki/DxCreateFont', name='dxCreateFont', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxCreateRenderTarget', return_types=['element'], arguments=[FunctionArgument(name='width', argument_type='int', default_value=None, optional=False), FunctionArgument(name='height', argument_type='int', default_value=None, optional=False), FunctionArgument(name='withAlpha', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="This function creates a render target element, which is a special type of [[texture]] that can be drawn on with the dx functions. Successful render target creation is not guaranteed, and may fail due to hardware or memory limitations.\nTo see if creation is likely to fail, use [[dxGetStatus]]. (When '''VideoMemoryFreeForMTA''' is zero, failure ''is'' guaranteed.)", arguments={'width ': 'The width of the texture in pixels.', 'height ': 'The height of the texture in pixels.', 'withAlpha': 'The render target will be created with an alpha channel. false will turn images alpha channels to black color'}, result="Returns a [[texture]] element if successful, ''false'' if the system is unable to create a render target.\n'''You should always check to see if this function has returned false.'''"), oop=None, url=FunctionUrl(url='/wiki/DxCreateRenderTarget', name='dxCreateRenderTarget', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxCreateScreenSource', return_types=['element'], arguments=[FunctionArgument(name='width', argument_type='int', default_value=None, optional=False), FunctionArgument(name='height', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function creates a screen source, which is a special type of [[texture]] that contains the screen as rendered by GTA\nNote that successful screen source creation is not guaranteed, and may fail due to hardware or memory limitations. You should always check to see if this function has returned false.', arguments={'width ': 'The width of the texture in pixels.', 'height ': 'The height of the texture  in pixels.'}, result="Returns a [[texture]] [[element]] if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/DxCreateScreenSource', name='dxCreateScreenSource', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxCreateTexture', return_types=['element'], arguments=[FunctionArgument(name='pixels', argument_type='string', default_value=None, optional=False), FunctionArgument(name='textureFormat', argument_type='string', default_value='"argb"', optional=True), FunctionArgument(name='mipmaps', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='textureEdge', argument_type='string', default_value='"wrap"', optional=True)]), docs=FunctionDoc(description='This function creates a [[texture]] element that can be used in the dxDraw functions.\n[[Image:Screenshot_27.png|frame|A speedtest showing the performance of a texture created with various settings of textureFormat.[Mipmaps = true][textureEdge = "wrap"]]]\n[[Image:DxCreateTexture_mipmaps_false.png |frame|A speedtest showing the performance of a texture created with various settings of textureFormat.[Mipmaps = false][textureEdge = "wrap"]]]\nIt is possible to use dxCreateTexture to load cubemaps and volume textures, but these will only be useable as inputs for a shader. The Microsoft utility [http://nightly.mtasa.com/files/shaders/DxTex.zip DxTex] can view and change cubemaps and volume textures. DxTex can also convert standard textures into DXT1/3/5 compressed .dds which should reduce file sizes.', arguments={'filepath': 'The filepath of the image. (.bmp, .dds, .jpg, .png, and .tga images are supported). Image files should ideally have dimensions that are a power of two, to prevent possible blurring.\nor', 'pixels': 'Texture_pixels|Pixels containing image data. (plain, jpeg or png pixels can be used here)\nor', 'width': 'Desired width, preferably power of two (16, 32, 64 etc.), maximum is 16384', 'height ': 'Desired height, preferably power of two (16, 32, 64 etc.), maximum is 16384\n{{OptionalArg}}', 'textureFormat ': 'A string representing the desired texture format, which can be one of:', '"argb"': ': ARGB uncompressed 32 bit color (default).', '"dxt1"': ': DXT1 compressed - Can take a fraction of a second longer to load (unless the file is already a DXT1 .dds). Uses 8 times less video memory than ARGB and can speed up drawing. Quality not as good as ARGB. It supports alpha blending, but it can only be on or off, that is: either 0 or 255.', '"dxt3"': ': DXT3 compressed - Can take a fraction of a second longer to load (unless the file is already a DXT3 .dds). Uses 4 times less video memory than ARGB and can speed up drawing. Quality slightly better than DXT1 and supports crisp alpha blending.', '"dxt5"': ': DXT5 compressed - Can take a fraction of a second longer to load (unless the file is already a DXT5 .dds). Uses 4 times less video memory than ARGB and can speed up drawing. Quality slightly better than DXT1 and supports smooth alpha blending.', 'mipmaps ': 'True to create a mip-map chain so the texture looks good when drawn at various sizes.', 'textureEdge ': 'A string representing the desired texture edge handling, which can be one of:', '"wrap"': ': Wrap the texture at the edges (default)', '"clamp"': ': Clamp the texture at the edges. This may help avoid edge artifacts.', '"mirror"': ': Mirror the texture at the edges.', 'textureType ': 'A string representing the desired texture type, which can be one of:', '"2d"': ': Standard texture (default)', '"3d"': ': Volume texture', '"cube"': ': Cube map', 'depth': 'Desired number of slices when creating a volume texture'}, result="Returns a [[texture]] if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/DxCreateTexture', name='dxCreateTexture', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxDrawCircle', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='radius', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startAngle', argument_type='float', default_value='0.0', optional=True), FunctionArgument(name='stopAngle', argument_type='float', default_value='360.0', optional=True), FunctionArgument(name='theColor', argument_type='int', default_value='white', optional=True), FunctionArgument(name='theCenterColor', argument_type='int', default_value='theColor', optional=True), FunctionArgument(name='segments', argument_type='int', default_value='32', optional=True), FunctionArgument(name='ratio', argument_type='int', default_value='1', optional=True), FunctionArgument(name='postGUI', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='<lowercasetitle/>', arguments={'posX': ': An integer representing the absolute X position of the circle center, represented by pixels on the screen.', 'posY': ': An integer representing the absolute Y position of the circle center, represented by pixels on the screen.', 'radius': ': An integer representing the radius scale of the circle that is being drawn.\n{{OptionalArg}}', 'startAngle': ': An integer representing the angle of the first point of the circle.', 'stopAngle': ': An integer representing the angle of the last point of the circle.', 'theColor': ': An integer of the hex color, produced using tocolor or 0xAARRGGBB (AA = alpha, RR = red, GG = green, BB = blue).', 'theCenterColor': ': An integer of the hex color, produced using tocolor or 0xAARRGGBB (AA = alpha, RR = red, GG = green, BB = blue).', 'segments': ': An integer ranging from 3-1024 representing how many triangles are used to form the circle, more segments = smoother circle. Note: using lots of segments may cause lag.', 'ratio': ': Ratio between width and height, e.g: 2 would mean that the width of the circle is 2 times the height.', 'postGUI': ': A bool representing whether the circle should be drawn on top of or behind any ingame GUI (rendered by CEGUI).'}, result="Returns ''true'' if the creation of the 2D circle was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxDrawCircle', name='dxDrawCircle', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxDrawImageSection', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='u', argument_type='float', default_value=None, optional=False), FunctionArgument(name='v', argument_type='float', default_value=None, optional=False), FunctionArgument(name='usize', argument_type='float', default_value=None, optional=False), FunctionArgument(name='vsize', argument_type='float', default_value=None, optional=False), FunctionArgument(name='image', argument_type='mixed', default_value=None, optional=False), FunctionArgument(name='rotation', argument_type='float', default_value='0', optional=False), FunctionArgument(name='rotationCenterOffsetX', argument_type='float', default_value='0', optional=False), FunctionArgument(name='rotationCenterOffsetY', argument_type='float', default_value='0', optional=False), FunctionArgument(name='color', argument_type='int', default_value='white', optional=False), FunctionArgument(name='postGUI', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='Differing from [[dxDrawImage]], this function only draws a part of an image on the screen for a single frame. In order for the image to stay visible continuously, you need to call this function with the same parameters on each frame update (see [[onClientRender]]).\nImage files should ideally have dimensions that are a power of two, to prevent possible blurring.<br/>\n<b>Power of two: 2px, 4px, 8px, 16px, 32px, 64px, 128px, 256px, 512px, 1024px...</b>', arguments={'posX': 'the absolute X coordinate of the top left corner of the image', 'posY': 'the absolute Y coordinate of the top left corner of the image', 'width': 'the absolute width of the image', 'height': 'the absolute height of the image', 'u': 'the absolute X coordinate of the top left corner of the section which should be drawn from image', 'v': 'the absolute Y coordinate of the top left corner of the section which should be drawn from image', 'usize': 'the absolute width of the image section', 'vsize': 'the absolute height of the image section', 'image': 'Either a material element or a filepath of the image which is going to be drawn. (.dds images are also supported). Image files should ideally have dimensions that are a power of two, to prevent possible blurring. Use a texture created with dxCreateTexture to speed up drawing.', 'rotation': 'the rotation, in degrees for the image.', 'rotationCenterOffsetX': 'the absolute X offset from the image center for which to rotate the image from.', 'rotationCenterOffsetY': 'the absolute Y offset from the image center for which to rotate the image from.', 'color': 'the color of the image, a value produced by tocolor or hexadecimal number in format: 0xAARRGGBB (AA = alpha, RR = red, GG = green, BB = blue).', 'postgui ': 'A bool representing whether the image should be drawn on top of or behind any ingame GUI (rendered by CEGUI).'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxDrawImageSection', name='dxDrawImageSection', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxDrawLine', return_types=['bool'], arguments=[FunctionArgument(name='startX', argument_type='int', default_value=None, optional=False), FunctionArgument(name='startY', argument_type='int', default_value=None, optional=False), FunctionArgument(name='endX', argument_type='int', default_value=None, optional=False), FunctionArgument(name='endY', argument_type='int', default_value=None, optional=False), FunctionArgument(name='color', argument_type='int', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value='1.0', optional=True), FunctionArgument(name='postGUI', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="This function draws a 2D line across the screen - rendered for '''one''' frame.  This should be used in conjunction with [[onClientRender]] in order to display continuously.", arguments={'startX': 'An integer representing the absolute start X position of the line, represented by pixels on the screen.', 'startY': 'An integer representing the absolute start Y position of the line, represented by pixels on the screen.', 'endX': 'An integer representing the absolute end X position of the line, represented by pixels on the screen.', 'endY': 'An integer representing the absolute end Y position of the line, represented by pixels on the screen.', 'color': 'An integer of the hex color, produced using tocolor or 0xAARRGGBB (AA = alpha, RR = red, GG = green, BB = blue).\n{{OptionalArg}}', 'width': 'The width/thickness of the line', 'postGUI': 'A bool representing whether the line should be drawn on top of or behind any ingame GUI (rendered by CEGUI).'}, result='Returns a true if the operation was successful, false otherwise. '), oop=None, url=FunctionUrl(url='/wiki/DxDrawLine', name='dxDrawLine', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxDrawLine3D', return_types=['bool'], arguments=[FunctionArgument(name='startX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='color', argument_type='int', default_value='0xFFFFFFFF', optional=True), FunctionArgument(name='width', argument_type='float', default_value='1.0', optional=True), FunctionArgument(name='postGUI', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="This function draws a 3D line between two points in the 3D world - rendered for '''one''' frame.  This should be used in conjunction with [[onClientRender]] in order to display continuously.", arguments={'startX': 'The start X position of the 3D line, representing a coordinate in the GTA world.', 'startY': 'The start Y position of the 3D line, representing a coordinate in the GTA world.', 'startZ': 'The start Z position of the 3D line, representing a coordinate in the GTA world.', 'endX': 'The end X position of the 3D line, representing a coordinate in the GTA world.', 'endY': 'The end Y position of the 3D line, representing a coordinate in the GTA world.', 'endZ': 'The end Z position of the 3D line, representing a coordinate in the GTA world.\n{{OptionalArg}}', 'color': 'An integer of the hex color, produced using tocolor or 0xAARRGGBB (AA = alpha, RR = red, GG = green, BB = blue).', 'width': 'The width/thickness of the line', 'postGUI': 'A bool representing whether the line should be drawn on top of or behind any ingame GUI (rendered by CEGUI).'}, result="Returns a ''true'' if the operation was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxDrawLine3D', name='dxDrawLine3D', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxDrawMaterialLine3D', return_types=['bool'], arguments=[FunctionArgument(name='startX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='material', argument_type='element', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='color', argument_type='int', default_value='white', optional=False), FunctionArgument(name='postGUI', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='faceTowardX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='faceTowardY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='faceTowardZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function draws a textured 3D line between two points in the 3D world - rendered for one frame.  This should be used in conjunction with [[onClientPreRender]] in order to display continuously.\nThe 3D line with a large width value effectively becomes a rectangle, so it it possible to construct basic shapes such as boxes with several large width lines and the appropriate values for 'faceToward'.\n3D lines are drawn at a particular place in the [[Game_Processing_Order|game processing order]], so use [[onClientPreRender]] for drawing if you are attaching them to world elements.", arguments={'startX/Y/Z': 'The start position of the 3D line, representing a coordinate in the GTA world.', 'endX/Y/Z': 'The end position of the 3D line, representing a coordinate in the GTA world.', 'material': 'A material to draw the line with.', 'width': 'The width/thickness of the line in GTA world units. (This is 1/75th of the width used in dxDrawLine3D)\n{{OptionalArg}}', 'color': 'An int|integer of the hex color, produced using tocolor or 0xAARRGGBB (AA = alpha, RR = red, GG = green, BB = blue).\n{{New items|3.0156|1.5.5|', 'postGUI': ': A bool representing whether the line should be drawn on top of or behind any ingame GUI.\n|11998}}', 'faceTowardX/Y/Z': 'The position the front of the line should face towards. If this is not set, the camera position is used, so the front of the line faces toward the camera.'}, result="Returns a ''true'' if the operation was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxDrawMaterialLine3D', name='dxDrawMaterialLine3D', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxDrawMaterialPrimitive', return_types=['bool'], arguments=[FunctionArgument(name='pType', argument_type='primitiveType', default_value=None, optional=False), FunctionArgument(name='material', argument_type='mixed', default_value=None, optional=False), FunctionArgument(name='postGUI', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='vertice1', argument_type='table', default_value=None, optional=False), FunctionArgument(name='vertice2', argument_type='table', default_value=None, optional=True), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='If image file is used, it should ideally have dimensions that are a power of two, to prevent possible blurring.\nPower of two: 2px, 4px, 8px, 16px, 32px, 64px, 128px, 256px, 512px, 1024px...}}', arguments={'pType': 'Type of primitive to be drawn.', 'image': 'Either a material element or a filepath of the image which is going to be drawn. (.dds images are also supported). Image files should ideally have dimensions that are a power of two, to prevent possible blurring. Use a texture created with dxCreateTexture to speed up drawing.', 'postGUI': 'A bool representing whether the line should be drawn on top of or behind any ingame GUI (rendered by CEGUI).', 'vertices': 'Tables representing each primitive vertice, required amount of them is determined by primitive type.'}, result="Returns a ''true'' if the operation was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxDrawMaterialPrimitive', name='dxDrawMaterialPrimitive', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxDrawMaterialPrimitive3D', return_types=['bool'], arguments=[FunctionArgument(name='pType', argument_type='primitiveType', default_value=None, optional=False), FunctionArgument(name='material', argument_type='mixed', default_value=None, optional=False), FunctionArgument(name='postGUI', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='vertice1', argument_type='table', default_value=None, optional=False), FunctionArgument(name='vertice2', argument_type='table', default_value=None, optional=True), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function draws a 3D primitive shape with material applied to it in the 3D world - rendered for one frame. This should be used in conjunction with [[onClientRender]] in order to display continuously.\nIf image file is used, it should ideally have dimensions that are a power of two, to prevent possible blurring.\nPower of two: 2px, 4px, 8px, 16px, 32px, 64px, 128px, 256px, 512px, 1024px...', arguments={'pType': 'Type of primitive to be drawn.', 'image': 'Either a material element or a filepath of the image which is going to be drawn. (.dds images are also supported). Image files should ideally have dimensions that are a power of two, to prevent possible blurring. Use a texture created with dxCreateTexture to speed up drawing.', 'postGUI': 'A bool representing whether the line should be drawn on top of or behind any ingame GUI (rendered by CEGUI).', 'vertices': 'Tables representing each primitive vertice, required amount of them is determined by primitive type.'}, result="Returns a ''true'' if the operation was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxDrawMaterialPrimitive3D', name='dxDrawMaterialPrimitive3D', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxDrawMaterialSectionLine3D', return_types=['bool'], arguments=[FunctionArgument(name='startX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='u', argument_type='float', default_value=None, optional=False), FunctionArgument(name='v', argument_type='float', default_value=None, optional=False), FunctionArgument(name='usize', argument_type='float', default_value=None, optional=False), FunctionArgument(name='vsize', argument_type='float', default_value=None, optional=False), FunctionArgument(name='material', argument_type='element', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='color', argument_type='int', default_value='white', optional=False), FunctionArgument(name='postGUI', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='faceTowardX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='faceTowardY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='faceTowardZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function draws a textured 3D line between two points in the 3D world - rendered for one frame.  This should be used in conjunction with [[onClientPreRender]] in order to display continuously.\nThe 3D line with a large width value effectively becomes a rectangle, so it it possible to construct basic shapes such as boxes with several large width lines and the appropriate values for 'faceToward'.", arguments={'startX/Y/Z': 'The start position of the 3D line, representing a coordinate in the GTA world.', 'endX/Y/Z': 'The end position of the 3D line, representing a coordinate in the GTA world.', 'u': 'the absolute X coordinate of the top left corner of the section', 'v': 'the absolute Y coordinate of the top left corner of the section', 'usize': 'the absolute width of the section', 'vsize': 'the absolute height of the section', 'material': 'A material to draw the line with.', 'width': 'The width/thickness of the line in GTA world units. (This is 1/75th of the width used in dxDrawLine3D)', 'color': 'An integer of the hex color, produced using tocolor or 0xAARRGGBB (AA = alpha, RR = red, GG = green, BB = blue).\n{{New items|5.0155|1.5.5-9.11998|', 'postGUI': ': A bool representing whether the line should be drawn on top of or behind any ingame GUI.\n}}', 'faceTowardX/Y/Z': 'The direction the front of the line should face towards. If this is not set, the front of the line always faces toward the camera.'}, result="Returns a ''true'' if the operation was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxDrawMaterialSectionLine3D', name='dxDrawMaterialSectionLine3D', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxDrawPrimitive', return_types=['bool'], arguments=[FunctionArgument(name='pType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='postGUI', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='vertice1', argument_type='table', default_value=None, optional=False), FunctionArgument(name='vertice2', argument_type='table', default_value=None, optional=True), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='', arguments={'pType': 'Type of primitive to be drawn.', 'postGUI': 'A bool representing whether the line should be drawn on top of or behind any ingame GUI (rendered by CEGUI).', 'vertices': 'Tables representing each primitive vertice, required amount of them is determined by primitive type.'}, result="Returns a ''true'' if the operation was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxDrawPrimitive', name='dxDrawPrimitive', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxDrawPrimitive3D', return_types=['bool'], arguments=[FunctionArgument(name='primitiveType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='postGUI', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='vertex1', argument_type='table', default_value=None, optional=False), FunctionArgument(name='vertex2', argument_type='table', default_value=None, optional=False), FunctionArgument(name='vertex3', argument_type='table', default_value=None, optional=False), FunctionArgument(name='vertex4', argument_type='table', default_value=None, optional=True), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description="This function draws a 3D primitive in the 3D world - rendered for '''one''' frame.  This should be used in conjunction with [[onClientRender]] in order to display continuously.", arguments={'primitiveType': 'The type of primitive to be drawn. This could be:\n    "pointlist"\n    "linelist"\n    "linestrip"\n    "trianglefan"\n    "trianglelist"\n    "trianglestrip"', 'postGUI': 'A bool representing whether the line should be drawn on top of or behind any ingame GUI (rendered by CEGUI).', 'vertex1': 'A table with the coordinates of the vertex plus its color.', 'vertex2': 'A table with the coordinates of the vertex plus its color.', 'vertex3': 'A table with the coordinates of the vertex plus its color.\nThe vertex should be passed like this:\n<syntaxhighlight lang="lua">\n{x, y, z, color}\n</syntaxhighlight>\n{{OptionalArg}}', 'vertexN': 'A table with the coordinates of the vertex plus its color. You can add as much as you want.'}, result="Returns a ''true'' if the operation was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxDrawPrimitive3D', name='dxDrawPrimitive3D', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxDrawRectangle', return_types=['bool'], arguments=[FunctionArgument(name='startX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='color', argument_type='int', default_value='white', optional=True), FunctionArgument(name='postGUI', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='subPixelPositioning', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="This function draws a 2D rectangle across the screen - rendered for '''one''' frame. This should be used in conjunction with [[onClientRender]] in order to display continuously. ", arguments={'startX': 'An float representing the absolute origin X position of the rectangle, represented by pixels on the screen.', 'startY': 'An float representing the absolute origin Y position of the rectangle, represented by pixels on the screen.', 'width': 'An float representing the width of the rectangle, drawn in a right direction from the origin.', 'height': 'An float representing the height of the rectangle, drawn in a downwards direction from the origin.', 'color': 'the hex color of the rectangle, produced using tocolor or 0xAARRGGBB (AA = alpha, RR = red, GG = green, BB = blue).', 'postGUI': 'A bool representing whether the line should be drawn on top of or behind any ingame GUI.\n{{New feature/item|9.06931|1.4.0|6931|', 'subPixelPositioning': 'A bool representing whether the rectangle can be positioned sub-pixel-ly.\n}}'}, result='Returns true if the operation was successful, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/DxDrawRectangle', name='dxDrawRectangle', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxDrawText', return_types=['bool'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='leftX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='topY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rightX', argument_type='float', default_value='leftX', optional=True), FunctionArgument(name='bottomY', argument_type='float', default_value='topY', optional=True), FunctionArgument(name='color', argument_type='int', default_value='white', optional=True), FunctionArgument(name='scaleXY', argument_type='float', default_value='1.0 [', optional=True), FunctionArgument(name='scaleY', argument_type='float', default_value='1.0', optional=True), FunctionArgument(name='font', argument_type='mixed', default_value='"default"', optional=True), FunctionArgument(name='alignX', argument_type='string', default_value='"left"', optional=True), FunctionArgument(name='alignY', argument_type='string', default_value='"top"', optional=True), FunctionArgument(name='clip', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='wordBreak', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='postGUI', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='colorCoded', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='subPixelPositioning', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='fRotation', argument_type='float', default_value='0.0', optional=True), FunctionArgument(name='fRotationCenterX', argument_type='float', default_value='0.0', optional=True), FunctionArgument(name='fRotationCenterY', argument_type='float', default_value='0.0', optional=True)]), docs=FunctionDoc(description='Draws a string of text on the screen for one frame. In order for the text to stay visible continuously, you need to call this function with the same parameters on each frame update (see [[onClientRender]]).', arguments={'text': 'the text to draw', 'leftX': 'the absolute X coordinate of the top left corner of the text', 'topY': 'the absolute Y coordinate of the top left corner of the text', 'rightX': 'the absolute X coordinate of the right side of the text bounding box. Used for text aligning, clipping and word breaking.', 'bottomY': 'the absolute Y coordinate of the bottom side of the text bounding box. Used for text aligning, clipping and word breaking.', 'color': 'the color of the text, a value produced by tocolor or 0xAARRGGBB (AA = alpha, RR = red, GG = green, BB = blue).', 'scale': 'the size of the text.{{New feature|3.0110|1.1|scale: can (optionally) be specified as two floats. i.e. scaleX, scaleY}}', 'font': 'Either a custom DX font element or the name of a built-in DX font: Note: Some fonts are incompatible with certain languages such as Arabic.\n{{DxFonts}}', 'alignX': 'horizontal alignment of the text within the bounding box. Can be left, center or right.', 'alignY': 'vertical alignment of the text within the bounding box. Can be top, center or bottom.', 'clip': 'if set to true, the parts of the text that dont fit within the bounding box will be cut off.', 'wordBreak': 'if set to true, the text will wrap to a new line whenever it reaches the right side of the bounding box. If false, the text will always be completely on one line.', 'postGUI': 'A bool representing whether the text should be drawn on top of or behind any ingame GUI (rendered by CEGUI).\n{{New feature/item|3.0130|1.3.0|3986|', 'colorCoded': 'Set to true to enable embedded #FFFFFF color codes. Note: clip and wordBreak are forced false if this is set.', 'subPixelPositioning': 'A bool representing whether the text can be positioned sub-pixel-ly. Looks nicer for moving/scaling animations.\n}}\n{{New feature/item|3.0135|1.3.5|6054|', 'fRotation': 'Rotation', 'fRotationCenterX': 'Rotation Origin X', 'fRotationCenterY': 'Rotation Origin Y\n}}'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxDrawText', name='dxDrawText', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxDrawWiredSphere', return_types=['bool'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='radius', argument_type='float', default_value=None, optional=False), FunctionArgument(name='theColor', argument_type='color', default_value=None, optional=False), FunctionArgument(name='fLineWidth', argument_type='float', default_value=None, optional=False), FunctionArgument(name='iterations', argument_type='uint', default_value=None, optional=False)]), docs=FunctionDoc(description='This function drawn same sphere as /showcol. It provides 4 levels of iterations which mean density of sphere. Adjust radius to iterations to get optimum density of mesh. About 50 spheres with iterations = 4 can cause fps drop.', arguments={'x, y, z': 'A position in world of sphere.', 'radius': 'A radius of sphere.', 'theColor': 'A color of sphere from tocolor function.', 'fLineWidth': 'A width of line', 'iterations ': 'Number 1, 2, 3 or 4. 1 mean low density, 4 mean high.'}, result="Returns a ''true'' if the operation was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxDrawWiredSphere', name='dxDrawWiredSphere', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxGetBlendMode', return_types=['string'], arguments=[]), docs=FunctionDoc(description='This function returns the current blend mode for the dxDraw functions. The blend mode is set using [[dxSetBlendMode]]', arguments={}, result="Returns the current blend mode, which can be one of:\n*'''blend'''\n*'''add'''\n*'''modulate_add'''\n*'''overwrite'''"), oop=None, url=FunctionUrl(url='/wiki/DxGetBlendMode', name='dxGetBlendMode', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxGetFontHeight', return_types=['int'], arguments=[FunctionArgument(name='scale', argument_type='float', default_value='1', optional=False), FunctionArgument(name='font', argument_type='mixed', default_value='"default"', optional=False)]), docs=FunctionDoc(description='This function retrieves the theoretical height of a certain piece of text, if it were to be drawn using [[dxDrawText]]. ', arguments={'scale': 'The size of the text.', 'font': 'Either a custom DX font element or the name of a built-in dx font:\n{{DxFonts}}'}, result='Returns an integer of the height of the text.'), oop=None, url=FunctionUrl(url='/wiki/DxGetFontHeight', name='dxGetFontHeight', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxGetMaterialSize', return_types=['int,', 'int', '[,', 'int]'], arguments=[FunctionArgument(name='material', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This gets the dimensions of the supplied [[material]] element.', arguments={'material ': 'The material element whose size is to be gotten'}, result="Returns two ''ints'' representing the width and height in pixels of the material, or false if an invalid parameter was passed to the function. \nIf the material is a volume texture, this function will return three ''ints'' representing the width, height and depth."), oop=None, url=FunctionUrl(url='/wiki/DxGetMaterialSize', name='dxGetMaterialSize', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxGetPixelColor', return_types=['int,', 'int,', 'int,', 'int'], arguments=[FunctionArgument(name='pixels', argument_type='string', default_value=None, optional=False), FunctionArgument(name='x', argument_type='int', default_value=None, optional=False), FunctionArgument(name='y', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets the color of a single pixel from [[Texture_pixels|pixels]] contained in a string. It only works with ''''plain'''' format pixels.", arguments={'pixels ': 'The pixels to use', 'x': 'The X coordinate for the pixel', 'y': 'The Y coordinate for the pixel'}, result="Returns 4 ''int''s representing the rgba color value of the pixel if succesful, or ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/DxGetPixelColor', name='dxGetPixelColor', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxGetPixelsSize', return_types=['int,', 'int'], arguments=[FunctionArgument(name='pixels', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the dimensions of [[Texture_pixels|pixels]] contained in a string. It works with all pixel formats.', arguments={'pixels': 'The pixels to get the dimensions of'}, result="Returns width and height of the pixels if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/DxGetPixelsSize', name='dxGetPixelsSize', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxGetPixelsFormat', return_types=['string'], arguments=[FunctionArgument(name='pixels', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the format of [[Texture_pixels|pixels]] contained in a string.', arguments={'pixels ': 'The pixels to get the format of'}, result="Returns the format of the pixels if successful (''''plain'''' or ''''png'''' or ''''jpeg''''), ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/DxGetPixelsFormat', name='dxGetPixelsFormat', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxGetStatus', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function gets information about various internal datum', arguments={}, result='Returns a table with the following entries:\n* \'\'\'TestMode :\'\'\' The current dx test mode. See [[dxSetTestMode]].\n*\'\'\'VideoCardName :\'\'\' The name of the graphics card.\n*\'\'\'VideoCardRAM :\'\'\' The installed memory in MB of the graphics card.\n*\'\'\'VideoCardPSVersion :\'\'\' The maximum pixel shader version of the graphics card.\n*\'\'\'VideoCardMaxAnisotropy:\'\'\' The maximum anisotropic filtering available. (0-4 which respectively mean: off,2x,4x,8x,16x)\n*\'\'\'VideoCardNumRenderTargets:\'\'\' The maximum number of simultaneous render targets a shader can use.\n*\'\'\'VideoMemoryFreeForMTA :\'\'\' The amount of memory in MB available for MTA to use. \'\'\'When this gets to zero, [[guiCreateFont]], [[dxCreateFont]] and [[dxCreateRenderTarget]] will fail.\'\'\'\n*\'\'\'VideoMemoryUsedByFonts :\'\'\' The amount of graphic memory in MB used by custom fonts.\n*\'\'\'VideoMemoryUsedByTextures :\'\'\' The amount of graphic memory in MB used by textures.\n*\'\'\'VideoMemoryUsedByRenderTargets :\'\'\' The amount of graphic memory in MB used by render targets.\n*\'\'\'SettingWindowed :\'\'\' The windowed setting. (true/false)\n*\'\'\'SettingFullScreenStyle :\'\'\' Display style when in full screen mode. (0-2 which respectively mean: Standard, Borderless window, Borderless keep res)\n*\'\'\'SettingFXQuality :\'\'\' The FX Quality. (0-3)\n*\'\'\'SettingDrawDistance :\'\'\' The draw distance setting. (0-100)\n*\'\'\'SettingVolumetricShadows :\'\'\' The volumetric shadows setting. (true/false)\n*\'\'\'SettingStreamingVideoMemoryForGTA :\'\'\' The usable graphics memory setting. (64-256)\n*\'\'\'SettingAnisotropicFiltering:\'\'\' The anisotropic filtering setting. (0-4 which respectively mean: off,2x,4x,8x,16x)\n*\'\'\'SettingAntiAliasing:\'\'\' The anti-aliasing setting. (0-3 which respectively mean: off,1x,2x,3x)\n*\'\'\'SettingHeatHaze:\'\'\' The heat haze setting. (true/false)\n*\'\'\'SettingGrassEffect:\'\'\' The grass effect setting. (true/false)\n*\'\'\'Setting32BitColor:\'\'\' The color depth of the screen. (false is 16bit, true is 32bit)\n*\'\'\'SettingHUDMatchAspectRatio:\'\'\' The hud match aspect ratio setting (true/false)\n*\'\'\'SettingAspectRatio:\'\'\' The aspect ratio setting ("auto", "4:3", "16:10", "16:9")\n*\'\'\'SettingFOV:\'\'\' The FOV setting\n{{New feature/item|3.0154|1.5.3|11199|\n*\'\'\'SettingHighDetailVehicles:\'\'\' High detail vehicles setting (true/false).\n}}\n{{New feature/item|3.0160|1.5.8||\n*\'\'\'SettingHighDetailPeds:\'\'\' High detail peds setting (true/false).\n}}\n*\'\'\'AllowScreenUpload :\'\'\' The allows screen uploads setting. (true/false)\n*\'\'\'DepthBufferFormat:\'\'\' The format of the shader readable depth buffer, or \'unknown\' if not available\n*\'\'\'UsingDepthBuffer:\'\'\' \'\'true\'\' if the depth buffer is used, \'\'false\'\' otherwise'), oop=None, url=FunctionUrl(url='/wiki/DxGetStatus', name='dxGetStatus', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxGetTextSize', return_types=['float,', 'float'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value='0', optional=True), FunctionArgument(name='scaleX', argument_type='float', default_value='1.0', optional=True), FunctionArgument(name='scaleY', argument_type='float', default_value='1.0', optional=True), FunctionArgument(name='font', argument_type='mixed', default_value='"default"', optional=True), FunctionArgument(name='wordBreak', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='colorCoded', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="'''NOTE:''' This function already takes the client's screen resolution into account.", arguments={'text': 'A string representing the text for which you wish to retrieve with width for.\n{{OptionalArg}}', 'width': 'The width of the text. Use with wordBreak = true.', 'scaleX': 'The scale of the text. Scale can also be inputted as a Vector2.', 'scaleY': 'The scale of the text.', 'font': 'Either a custom DX font element or the name of a built-in dx font:\n{{DxFonts}}', 'wordBreak': 'If set to true, the text will wrap to a new line whenever it reaches the right side of the bounding box. If false, the text will always be completely on one line.', 'colorCoded': 'Should we exclude color codes from the width? False will include the hex in the length.'}, result='Returns two floats representing the width and height of the text in pixels.'), oop=None, url=FunctionUrl(url='/wiki/DxGetTextSize', name='dxGetTextSize', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxGetTextWidth', return_types=['float'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='scale', argument_type='float', default_value='1', optional=False), FunctionArgument(name='font', argument_type='mixed', default_value='"default"', optional=False), FunctionArgument(name='bColorCoded', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description="This function retrieves the theoretical width (in pixels) of a certain piece of text, if it were to be drawn using [[dxDrawText]].\n'''NOTE:''' This function already takes the client's screen resolution into account.", arguments={'text': 'A string representing the text for which you wish to retrieve with width for.\n{{OptionalArg}}', 'scale': 'The size of the text.', 'font': 'Either a custom DX font element or the name of a built-in dx font:\n{{DxFonts}}', 'bColorCoded': 'Should we exclude color codes from the width? (false will include the hex in the length)'}, result='Returns the float of the width of the text (in pixels). '), oop=None, url=FunctionUrl(url='/wiki/DxGetTextWidth', name='dxGetTextWidth', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxGetTexturePixels', return_types=['string'], arguments=[FunctionArgument(name='surfaceIndex', argument_type='int', default_value='0', optional=False), FunctionArgument(name='texture', argument_type='element', default_value=None, optional=False), FunctionArgument(name='x', argument_type='int', default_value='0', optional=True), FunctionArgument(name='y', argument_type='int', default_value='0', optional=True), FunctionArgument(name='width', argument_type='int', default_value='0', optional=True), FunctionArgument(name='height', argument_type='int', default_value='0', optional=True)]), docs=FunctionDoc(description="This function fetches the [[Texture_pixels|pixels]] from a [[texture]] element. It can be used with a standard texture, render target or screen source.\n*This function is slow and not something you want to be doing once a frame.\n*It is slower when reading pixels from a render target or screen source.\n*And is very slow indeed if the texture format is not ''' 'argb' '''.\n}}", arguments={'texture ': 'The texture element to get the pixels from', 'surfaceIndex': 'Desired slice to get if the texture is a volume texture, or desired face to get if the texture is a cube map. <nowiki>(Cube map faces: 0=+X 1=-X 2=+Y 3=-Y 4=+Z 5=-Z)</nowiki>\nBy default the pixels from the whole texture is returned. To get only a portion of the texture, define a rectangular area using all four of these optional arguments:', 'x': 'Rectangle left position', 'y': 'Rectangle top position', 'width': 'Rectangle width', 'height ': 'Rectangle height'}, result="Returns a ''''plain'''' format pixels string if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/DxGetTexturePixels', name='dxGetTexturePixels', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxIsAspectRatioAdjustmentEnabled', return_types=['bool,', 'float'], arguments=[]), docs=FunctionDoc(description='This function gets the current aspect ratio set by [[dxSetAspectRatioAdjustmentEnabled]].\n}}', arguments={}, result="*'''boolean:''' returns '''true''' when enabled by [[dxSetAspectRatioAdjustmentEnabled]], '''false''' otherwise.\n*'''float:''' aspect ratio set by [[dxSetAspectRatioAdjustmentEnabled]]"), oop=None, url=FunctionUrl(url='/wiki/DxIsAspectRatioAdjustmentEnabled', name='dxIsAspectRatioAdjustmentEnabled', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxSetAspectRatioAdjustmentEnabled', return_types=['bool'], arguments=[FunctionArgument(name='bEnabled', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='sourceRatio', argument_type='float', default_value='4/3', optional=True)]), docs=FunctionDoc(description="This function allows for the positioning of dxDraw calls to be automatically adjusted according to the client's aspect ratio setting.  This lasts for a single execution of an event handler for one of the following events: [[onClientRender]], [[onClientPreRender]] and [[onClientHUDRender]]. So the function has to be called every frame, just like dxDraws.\nThis is particularly useful for draws that must align with the GTA HUD, for which the sizing and positioning can vary for different aspect ratios.\n}}", arguments={'bEnabled': ': Should the adjustment be enabled or disabled.\n{{OptionalArg}}', 'sourceRatio ': 'This should be set to the aspect ratio the dxDraws were originally designed in.'}, result="Returns ''true'' when it was changed successfully, or ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxSetAspectRatioAdjustmentEnabled', name='dxSetAspectRatioAdjustmentEnabled', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxSetBlendMode', return_types=['bool'], arguments=[FunctionArgument(name='blendMode', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the current blend mode for the dxDraw functions. Changing the blend mode can increase the quality when drawing text or certain other images to a render target. As a general guide use '''modulate_add''' when drawing text to a render target, and '''add''' when drawing the render target to the screen. Don't forget to restore the default '''blend''' at the end - See the example below.", arguments={'blendMode ': 'The blend mode to use which can be one of:', 'blend': 'The source textures are alpha blended to the screen/render target. This is the default mode for drawing and gives the results we all know and love.', 'add': 'The source textures are added to the screen/render target.', 'modulate_add': 'The source textures are multiplied by the alpha and then added to the screen/render target.', 'overwrite ': 'The source textures are overwritten. This can be useful for clearing render targets.'}, result="Returns true if successful, or ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/DxSetBlendMode', name='dxSetBlendMode', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxSetPixelColor', return_types=['bool'], arguments=[FunctionArgument(name='pixels', argument_type='string', default_value=None, optional=False), FunctionArgument(name='x', argument_type='int', default_value=None, optional=False), FunctionArgument(name='y', argument_type='int', default_value=None, optional=False), FunctionArgument(name='r', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b', argument_type='int', default_value=None, optional=False), FunctionArgument(name='a', argument_type='int', default_value='255', optional=True)]), docs=FunctionDoc(description="This function sets the color of a single pixel for [[Texture_pixels|pixels]] contained in a string. It only works with ''''plain'''' format pixels.", arguments={'pixels ': 'The pixels to use', 'x': 'The X coordinate for the pixel', 'y': 'The Y coordinate for the pixel', 'r': 'The red channel for the color (0-255)', 'g': 'The green channel for the color (0-255)', 'b': 'The blue channel for the color (0-255)', 'a': 'The alpha channel for the color (0-255)'}, result="Returns true if successful, or ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/DxSetPixelColor', name='dxSetPixelColor', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxSetRenderTarget', return_types=['bool'], arguments=[FunctionArgument(name='renderTarget', argument_type='element', default_value=None, optional=False), FunctionArgument(name='clear', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='This function changes the drawing destination for the dx functions. It can be used to select a previously created render target, or if called with no arguments, restore drawing directly to the screen.', arguments={'renderTarget': 'The render target element whose pixels we want to draw on.', 'clear': 'If set to true, the render target will also be cleared.'}, result="Returns ''true'' if the render target was successfully changed, ''false'' otherwise."), oop=FunctionOOP(class_name='rendertarget', method_name="setAsTarget}}\n\n===Optional Arguments=== \n*'''renderTarget:''' The render target element whose pixels we want to draw on.\n*'''clear:''' If set to true, the render target will also be cleared.\n\n===Returns===\nReturns ''true'' if the render target was successfully changed, ''false'' otherwise.\n\n==Usage restrictions==\n*Items drawn with ''postGUI'' set to ''true'' will not appear on a custom render target.\n{{Deprecated feature", field='3.0131'), url=FunctionUrl(url='/wiki/DxSetRenderTarget', name='dxSetRenderTarget', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxSetShaderValue', return_types=['bool'], arguments=[FunctionArgument(name='theShader', argument_type='element', default_value=None, optional=False), FunctionArgument(name='parameterName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='mixed', default_value=None, optional=False)]), docs=FunctionDoc(description='This sets a named parameter for a [[shader]] element', arguments={'theShader': 'The shader element whose parameter is to be changed', 'parameterName': 'The name of parameter', 'value': 'The value to set, which can be a texture, a bool, a number or a list of numbers(max 16 floats(numbers))'}, result="Returns ''true'' if the shader element's parameter was successfully changed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxSetShaderValue', name='dxSetShaderValue', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxSetShaderTessellation', return_types=['bool'], arguments=[FunctionArgument(name='theShader', argument_type='element', default_value=None, optional=False), FunctionArgument(name='tessellationX', argument_type='int', default_value=None, optional=False), FunctionArgument(name='tessellationY', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the amount of geometric sub-division to use when drawing a [[shader]] element with [[dxDrawImage]].\nUsing tessellation allows a shader to manipulate the shape of the rendered image at each sub-division boundary.', arguments={'theShader': 'The shader element whose tessellation is to be changed', 'tessellationX': 'The number of sub-division points along the X axis. Range is 1 to 500.', 'tessellationY': 'The number of sub-division points along the Y axis. Range is 1 to 500.'}, result="Returns ''true'' if the shader element's tessellation was successfully changed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxSetShaderTessellation', name='dxSetShaderTessellation', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxSetShaderTransform', return_types=['bool'], arguments=[FunctionArgument(name='theShader', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rotationX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rotationY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rotationZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rotationCenterOffsetX', argument_type='float', default_value='0', optional=False), FunctionArgument(name='rotationCenterOffsetY', argument_type='float', default_value='0', optional=False), FunctionArgument(name='rotationCenterOffsetZ', argument_type='float', default_value='0', optional=False), FunctionArgument(name='bRotationCenterOffsetOriginIsScreen', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='perspectiveCenterOffsetX', argument_type='float', default_value='0', optional=False), FunctionArgument(name='perspectiveCenterOffsetY', argument_type='float', default_value='0', optional=False), FunctionArgument(name='bPerspectiveCenterOffsetOriginIsScreen', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='This function applies a 3D transformation to a [[shader]] element when it is drawn with [[dxDrawImage]].', arguments={'theShader': 'The shader element whose transformation is to be changed', 'rotationX': 'Rotation angle in degrees around the X axis (Left,right). This will make the shader rotate along its width.', 'rotationY': 'Rotation angle in degrees around the Y axis (Up,down). This will make the shader rotate along its height.', 'rotationZ': 'Rotation angle in degrees around the Z axis (In,out). This will make the shader rotate in a similar way to the rotation argument in dxDrawImage.\n{{OptionalArg}}', 'rotationCenterOffsetX ': 'The center of rotation offset X position in screen relative units.', 'rotationCenterOffsetY ': 'The center of rotation offset Y position in screen relative units.', 'rotationCenterOffsetZ ': 'The center of rotation offset Z position in screen relative units.', 'bRotationCenterOffsetOriginIsScreen ': 'Set to boolean|true if the center of rotation origin should be the center of the screen rather than the center of the image.', 'perspectiveCenterOffsetX ': 'The center of perspective offset X position in screen relative units.', 'perspectiveCenterOffsetY ': 'The center of perspective offset Y position in screen relative units.', 'bPerspectiveCenterOffsetOriginIsScreen ': "Set to boolean|true if the center of perspective origin should be the center of the screen rather than the center of the image.\nTo convert screen relative units into screen pixel coordinates, ''multiply'' by the screen size. Conversely, to convert screen pixel coordinates to screen relative units, '''''divide''''' by the screen size."}, result="Returns ''true'' if the shader element's transform was successfully changed, ''false'' otherwise."), oop=FunctionOOP(class_name='shader', method_name="setTransform}}\n\n===Required Arguments=== \n*'''theShader:''' The shader element whose transformation is to be changed\n*'''rotationX:''' Rotation angle in degrees around the X axis (Left,right). This will make the shader rotate along its width.\n*'''rotationY:''' Rotation angle in degrees around the Y axis (Up,down). This will make the shader rotate along its height.\n*'''rotationZ:''' Rotation angle in degrees around the Z axis (In,out). This will make the shader rotate in a similar way to the rotation argument in [[dxDrawImage]].\n\n===Optional Arguments=== \n{{OptionalArg}}\n*'''rotationCenterOffsetX :''' The center of rotation offset X position in screen relative units.\n*'''rotationCenterOffsetY :''' The center of rotation offset Y position in screen relative units.\n*'''rotationCenterOffsetZ :''' The center of rotation offset Z position in screen relative units.\n*'''bRotationCenterOffsetOriginIsScreen :''' Set to [[boolean", field="true]] if the center of rotation origin should be the center of the screen rather than the center of the image.\n*'''perspectiveCenterOffsetX :''' The center of perspective offset X position in screen relative units.\n*'''perspectiveCenterOffsetY :''' The center of perspective offset Y position in screen relative units.\n*'''bPerspectiveCenterOffsetOriginIsScreen :''' Set to [[boolean"), url=FunctionUrl(url='/wiki/DxSetShaderTransform', name='dxSetShaderTransform', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxSetTestMode', return_types=['bool'], arguments=[FunctionArgument(name='testMode', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used for testing scripts written using [[guiCreateFont]], [[dxCreateFont]], [[dxCreateShader]] and [[dxCreateRenderTarget]].\nEach one of the 3 test modes should be used in turn to help highlight any potential problems.', arguments={'testMode ': 'The test mode to be set. It can be one of the following values:', 'none ': 'Test mode disabled', 'no_mem': 'Simulate no free video memory available for MTA.', 'low_mem': 'Simulate little free video memory available for MTA.', 'no_shader': 'Simulate shaders failing validation.'}, result="Returns ''true'' if the test mode was successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxSetTestMode', name='dxSetTestMode', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxSetTextureEdge', return_types=['bool'], arguments=[FunctionArgument(name='theTexture', argument_type='texture', default_value=None, optional=False), FunctionArgument(name='textureEdge', argument_type='string', default_value=None, optional=False), FunctionArgument(name='border', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='This functions allows you to change the edge handling after creating the texture.\n}}\n[[File:TextureEdges.jpg|600px]]', arguments={'theTexture': 'The affected texture', 'textureEdge': 'The texture edge mode. Available modes are wrap, mirror, clamp, border, mirror-once', 'border-color': 'If textureEdge is set to border, you are able to define a border color here'}, result=''), oop=None, url=FunctionUrl(url='/wiki/DxSetTextureEdge', name='dxSetTextureEdge', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxSetTexturePixels', return_types=['bool'], arguments=[FunctionArgument(name='surfaceIndex', argument_type='int', default_value='0', optional=False), FunctionArgument(name='texture', argument_type='element', default_value=None, optional=False), FunctionArgument(name='pixels', argument_type='string', default_value=None, optional=False), FunctionArgument(name='x', argument_type='int', default_value='0', optional=True), FunctionArgument(name='y', argument_type='int', default_value='0', optional=True), FunctionArgument(name='width', argument_type='int', default_value='0', optional=True), FunctionArgument(name='height', argument_type='int', default_value='0', optional=True)]), docs=FunctionDoc(description='This function sets the [[Texture_pixels|pixels]] of a [[texture]] element. It can be used with a standard texture, render target or screen source. Only \'\'\'\'plain\'\'\'\' format pixels please.\n* This function is slow and not something you want to be doing once a frame.\n* It is very slow when setting pixels to a render target or screen source.\n* And is very slow indeed if the texture format is not \'\'\'"argb"\'\'\'.\n}}', arguments={'texture ': 'The texture element to set the pixels of', 'pixels ': 'The plain format pixels to use', 'surfaceIndex': 'Desired slice to set if the texture is a volume texture, or desired face to set if the texture is a cube map. <nowiki>(Cube map faces: 0=+X 1=-X 2=+Y 3=-Y 4=+Z 5=-Z)</nowiki>\nBy default the pixels are set starting at the top left corner of the texture. To set a different region, define a rectangular area using all four of these optional arguments:', 'x': 'Rectangle left position', 'y': 'Rectangle top position', 'width': 'Rectangle width', 'height ': 'Rectangle height'}, result="Returns a string if successful, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/DxSetTexturePixels', name='dxSetTexturePixels', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='dxUpdateScreenSource', return_types=['bool'], arguments=[FunctionArgument(name='screenSource', argument_type='element', default_value=None, optional=False), FunctionArgument(name='resampleNow', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function updates the contents of a screen source [[texture]] with the screen output from GTA', arguments={'screenSource': 'The screen source element whose pixels we want to fill with the screen capture', 'resampleNow': 'A bool to indicate if the screen should be captured immediately. The default is false which means the screen from the end of the previous frame is used (better for performance and consistency). Use true for layering fullscreen effects.'}, result="Returns ''true'' if the screen was successfully captured, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DxUpdateScreenSource', name='dxUpdateScreenSource', category='Drawing functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='createEffect', return_types=['effect'], arguments=[FunctionArgument(name='name', argument_type='string', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rX', argument_type='float', default_value=None, optional=True), FunctionArgument(name='rY', argument_type='float', default_value=None, optional=True), FunctionArgument(name='rZ', argument_type='float', default_value=None, optional=True), FunctionArgument(name='drawDistance', argument_type='float', default_value='0', optional=True), FunctionArgument(name='soundEnable', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='Creates an [[Element/Effect|effect]] on specified position.\n}}', arguments={'name': 'A string contains Element/Effect#Effects_list|effect name.', 'x': 'A floating point number representing the X coordinate on the map.', 'y': 'A floating point number representing the Y coordinate on the map.', 'z': 'A floating point number representing the Z coordinate on the map.\n{{OptionalArg}} ', 'rX': 'A floating point number representing the rotation about the X axis in degrees.', 'rY': 'A floating point number representing the rotation about the Y axis in degrees.', 'rZ': 'A floating point number representing the rotation about the Z axis in degrees.', 'drawDistance': 'A floating point number between 1 and 8191 which represents the draw distance of the effect, or 0 to use the default draw distance.\n{{New feature/item|3.0155|1.5.5||', 'soundEnable': 'to enable the sound of the effect.\n}}'}, result=''), oop=None, url=FunctionUrl(url='/wiki/CreateEffect', name='createEffect', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fxAddBlood', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='count', argument_type='int', default_value='1', optional=True), FunctionArgument(name='brightness', argument_type='float', default_value='1.0', optional=True)]), docs=FunctionDoc(description='[[Image:Fxblood.png|thumb|200px|Blood splatter]]\nCreates a blood splatter particle effect.', arguments={'posX, posY, posZ': 'the world coordinates where the effect originates.', 'dirX, dirY, dirZ': 'a direction vector indicating where the blood flies to.\n{{OptionalArg}}', 'count': 'the number of flying droplets to create.', 'brightness': 'the brightness. Ranges from 0 (almost black) to 1 (normal color).'}, result=''), oop=None, url=FunctionUrl(url='/wiki/FxAddBlood', name='fxAddBlood', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fxAddBulletImpact', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='smokeSize', argument_type='int', default_value='1', optional=True), FunctionArgument(name='sparkCount', argument_type='int', default_value='1', optional=True), FunctionArgument(name='smokeIntensity', argument_type='float', default_value='1.0', optional=True)]), docs=FunctionDoc(description='[[Image:Fxbulletimpact.png|thumb|200px|Bullet impact]]\nCreates a bullet impact particle effect, consisting of a small smoke cloud and a number of sparks.', arguments={'posX, posY, posZ': 'the world coordinates where the effect originates.', 'dirX, dirY, dirZ': 'a vector indicating the direction of the effect.\n{{OptionalArg}}', 'smokeSize': 'the size of the smoke cloud.', 'sparkCount': 'the number of sparks to create.', 'smokeIntensity': 'the amount/transparency of smoke, ranges from 0 to 1.'}, result='Returns a true if the operation was successful, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/FxAddBulletImpact', name='fxAddBulletImpact', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fxAddBulletSplash', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='[[Image:Fxbulletsplash.png|thumb|200px|Bullet splash]]\nThis function creates a bullet splash particle effect, normally created when shooting into water.', arguments={'posX': 'A float representing the x position of the splash', 'posY': 'A float representing the y position of the splash', 'posZ': 'A float representing the z position of the splash'}, result='Returns a true if the operation was successful, false otherwise. '), oop=None, url=FunctionUrl(url='/wiki/FxAddBulletSplash', name='fxAddBulletSplash', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fxAddDebris', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='colorR', argument_type='int', default_value='255', optional=True), FunctionArgument(name='colorG', argument_type='int', default_value='0', optional=True), FunctionArgument(name='colorB', argument_type='int', default_value='0', optional=True), FunctionArgument(name='colorA', argument_type='int', default_value='255', optional=True), FunctionArgument(name='scale', argument_type='float', default_value='1.0', optional=True), FunctionArgument(name='count', argument_type='int', default_value='1', optional=True)]), docs=FunctionDoc(description='[[Image:Fxdebris.png|thumb|200px|Debris]]\nCreates a debris particle effect (e.g. bits that fly off a car when ramming a wall).', arguments={'posX, posY, posZ': 'the world coordinates where the debris originates.\n{{OptionalArg}}', 'colorR, colorG, colorB, colorA': 'the color and alpha (transparency) of the debris effect.', 'scale': 'the size of the chunks.', 'count': 'the number of chunks to create.'}, result='Returns a true if the operation was successful, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/FxAddDebris', name='fxAddDebris', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fxAddFootSplash', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='[[Image:Fxfootsplash.png|thumb|200px|Foot splash]]\nThis function creates a foot splash particle effect, normally created when walking into water.', arguments={'posX': 'A float representing the x position of the splash', 'posY': 'A float representing the y position of the splash', 'posZ': 'A float representing the z position of the splash'}, result='Returns a true if the operation was successful, false otherwise. '), oop=None, url=FunctionUrl(url='/wiki/FxAddFootSplash', name='fxAddFootSplash', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fxAddGlass', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='colorR', argument_type='int', default_value='255', optional=True), FunctionArgument(name='colorG', argument_type='int', default_value='0', optional=True), FunctionArgument(name='colorB', argument_type='int', default_value='0', optional=True), FunctionArgument(name='colorA', argument_type='int', default_value='255', optional=True), FunctionArgument(name='scale', argument_type='float', default_value='1.0', optional=True), FunctionArgument(name='count', argument_type='int', default_value='1', optional=True)]), docs=FunctionDoc(description='[[Image:Fxglass.png|thumb|200px|Glass]]\nThis function creates a glass particle effect.', arguments={'posX': 'A float representing the x position of the glass', 'posY': 'A float representing the y position of the glass', 'posZ': 'A float representing the z position of the glass\n{{OptionalArg}}', 'colorR, colorG, colorB, colorA': 'the color and alpha (transparency) of the glass effect.', 'scale': 'A float representing the size of the particle effect, where 1 is the standard size.', 'count': 'The density of the particle effect.'}, result='Returns a true if the operation was successful, false otherwise. '), oop=None, url=FunctionUrl(url='/wiki/FxAddGlass', name='fxAddGlass', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fxAddGunshot', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='includeSparks', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description='[[Image:Fxgunshot.png|thumb|200px|Gunshot]]\nThis function creates a gunshot particle effect.', arguments={'posX, posY, posZ': 'the world coordinates where the effect originates.', 'dirX, dirY, dirZ': 'a direction vector indicating where the bullet is fired.\n{{OptionalArg}}', 'includeSparks': 'A bool representing whether the particle effect will generate sparks.'}, result='Returns a true if the operation was successful, false otherwise. '), oop=None, url=FunctionUrl(url='/wiki/FxAddGunshot', name='fxAddGunshot', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fxAddPunchImpact', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='[[Image:Fxpunchimpact.png|thumb|200px|Punch impact]]\nCreates a punch impact particle effect (a small dust cloud).', arguments={'posX, posY, posZ': 'the world coordinates where the effect originates.', 'dirX, dirY, dirZ': 'a vector indicating the movement direction of the effect.'}, result='Returns a true if the operation was successful, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/FxAddPunchImpact', name='fxAddPunchImpact', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fxAddSparks', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='force', argument_type='float', default_value='1.0', optional=True), FunctionArgument(name='count', argument_type='int', default_value='1', optional=True), FunctionArgument(name='acrossLineX', argument_type='float', default_value='0.0', optional=True), FunctionArgument(name='acrossLineY', argument_type='float', default_value='0.0', optional=True), FunctionArgument(name='acrossLineZ', argument_type='float', default_value='0.0', optional=True), FunctionArgument(name='blur', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='spread', argument_type='float', default_value='1.0', optional=True), FunctionArgument(name='life', argument_type='float', default_value='1.0', optional=True)]), docs=FunctionDoc(description='[[Image:Fxsparks.png|thumb|200px|Sparks]]\nCreates a number of sparks originating from a point or along a line.', arguments={'posX, posY, posZ': 'the world coordinates where the sparks originate.', 'dirX, dirY, dirZ': 'a direction vector indicating where the sparks fly to. The longer this vector is, the faster the sparks fly.\n{{OptionalArg}}', 'force': 'speed factor: the higher this value, the faster and further the sparks fly.', 'count': 'the number of effects to create.', 'acrossLineX, acrossLineY, acrossLineZ': 'a vector starting at the pos coordinates. If specified, the sparks will be created along a line going from pos to pos - acrossLine. If not specified, all sparks originate from the point at pos.', 'blur': 'if false, creates standard bullet impact-like sparks. If true, adds motion blur to the sparks.', 'spread': 'determines how strongly the particles deviate from each other. With low values the particles will stay quite close together, high values will make them fly in all directions. Also affects their speed.', 'life': 'the higher this value, the longer the sparks survive before they disappear.'}, result='Returns a true if the operation was successful, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/FxAddSparks', name='fxAddSparks', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fxAddTankFire', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='[[Image:Fxtankfire.png|thumb|200px|Tank fire]]\nThis function creates a tank firing particle effect.', arguments={'posX, posY, posZ': 'the world coordinates where the effect originates.', 'dirX, dirY, dirZ': 'a direction vector indicating where the tank fire is directed to.'}, result='Returns a true if the operation was successful, false otherwise. '), oop=None, url=FunctionUrl(url='/wiki/FxAddTankFire', name='fxAddTankFire', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fxAddTyreBurst', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='[[Image:Fxtyreburst.png|thumb|200px|Tyre burst]]\nCreates a tyre burst particle effect (a small white smoke puff).', arguments={'posX, posY, posZ': 'the world coordinates where the puff originates.', 'dirX, dirY, dirZ': 'a vector indicating the movement direction of the effect.'}, result='Returns a true if the operation was successful, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/FxAddTyreBurst', name='fxAddTyreBurst', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fxAddWaterHydrant', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='[[Image:Fxwaterhydrant.png|thumb|200px|Water hydrant]]\nThis function creates a water hydrant particle effect.', arguments={'posX': 'A float representing the x position of the hydrant', 'posY': 'A float representing the y position of the hydrant', 'posZ': 'A float representing the z position of the hydrant'}, result='Returns a true if the operation was successful, false otherwise. '), oop=None, url=FunctionUrl(url='/wiki/FxAddWaterHydrant', name='fxAddWaterHydrant', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fxAddWaterSplash', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='[[Image:Fxwatersplash.png|thumb|200px|Water splash]]\nThis function creates a water splash particle effect.', arguments={'posX': 'A float representing the x position of the splash', 'posY': 'A float representing the y position of the splash', 'posZ': 'A float representing the z position of the splash'}, result='Returns a true if the operation was successful, false otherwise. '), oop=None, url=FunctionUrl(url='/wiki/FxAddWaterSplash', name='fxAddWaterSplash', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fxAddWood', return_types=['bool'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='dirZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='count', argument_type='int', default_value='1', optional=True), FunctionArgument(name='brightness', argument_type='float', default_value='1.0', optional=True)]), docs=FunctionDoc(description='[[Image:Fxwood.png|thumb|200px|Wood]]\nCreates a wood splinter particle effect.', arguments={'posX, posY, posZ': 'the world coordinates where the effect originates.', 'dirX, dirY, dirZ': 'a direction vector indicating where the wood splinters fly to.\n{{OptionalArg}}', 'count': 'the number of splinters to create.', 'brightness': 'the brightness. Ranges from 0 (black) to 1 (normal color).'}, result='Returns a true if the operation was successful, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/FxAddWood', name='fxAddWood', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getEffectDensity', return_types=['float'], arguments=[FunctionArgument(name='theEffect', argument_type='effect', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the density of certain [[effect]].\n}}', arguments={'theEffect': 'The effect to get density of.'}, result=''), oop=FunctionOOP(class_name='effect', method_name='getDensity', field='density'), url=FunctionUrl(url='/wiki/GetEffectDensity', name='getEffectDensity', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getEffectSpeed', return_types=['float'], arguments=[FunctionArgument(name='theEffect', argument_type='effect', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the speed of a specified [[effect]].\n}}', arguments={'theEffect': 'The effect to get the speed of.'}, result="Returns [[float]] containing the effect's speed, ''false'' if invalid arguments were specified."), oop=FunctionOOP(class_name='effect', method_name='getSpeed', field='speed'), url=FunctionUrl(url='/wiki/GetEffectSpeed', name='getEffectSpeed', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setEffectDensity', return_types=['bool'], arguments=[FunctionArgument(name='theEffect', argument_type='effect', default_value=None, optional=False), FunctionArgument(name='density', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the density of a specified [[effect]].\n}}\nThe limit is 1 for Low, 1.5 for Medium, and 2 for High/Very high.|true}}', arguments={'theEffect': 'The effect to change the speed of.', 'density': 'The level of density (from 0 to 2).'}, result="Returns ''true'' if the density was succesfully changed, ''false'' otherwise."), oop=FunctionOOP(class_name='effect', method_name='setDensity', field='density'), url=FunctionUrl(url='/wiki/SetEffectDensity', name='setEffectDensity', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setEffectSpeed', return_types=['bool'], arguments=[FunctionArgument(name='theEffect', argument_type='effect', default_value=None, optional=False), FunctionArgument(name='speed', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the speed of a specified [[effect]].\n}}', arguments={'theEffect': 'The effect to change the speed of.', 'speed': 'The speed to set.'}, result="Returns ''true'' if the effect speed was succesfuly changed, ''false'' otherwise."), oop=FunctionOOP(class_name='effect', method_name='setSpeed', field='speed'), url=FunctionUrl(url='/wiki/SetEffectSpeed', name='setEffectSpeed', category='Effects functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='attachElements', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theAttachToElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='xPosOffset', argument_type='float', default_value='0', optional=False), FunctionArgument(name='yPosOffset', argument_type='float', default_value='0', optional=False), FunctionArgument(name='zPosOffset', argument_type='float', default_value='0', optional=False), FunctionArgument(name='xRotOffset', argument_type='float', default_value='0', optional=False), FunctionArgument(name='yRotOffset', argument_type='float', default_value='0', optional=False), FunctionArgument(name='zRotOffset', argument_type='float', default_value='0', optional=False)]), docs=FunctionDoc(description="This function attaches one element to another, so that the first one follows the second whenever it moves. \nIf an attempt is made to attach two elements that are already attached the opposite way (eg theElement becomes theAttachToElement and vice versa), the 1st attachment order is automatically detached in favor of the 2nd attachment order. For example, if carA was attached to carB, now carB is attached to carA. Also, an element cannot be attached to two separate elements at one time. For example, two cars can be attached to one single car, but one single car cannot be attached to two separate cars. If you attempt to do this, the existing attachment will automatically be dropped in favor of the new attachment. For example, if carA is asked to attached to carB then carC, it is only attached to carC.\nThis is not compatible with all elements.  The following elements are compatible:\n* [[Ped]]s\n* [[Player]]s\n* [[Blip]]s\n* [[Vehicle]]s\n* [[Object]]s\n* [[Marker]]s\n* [[Pickup]]s\n* [[Sound]]s\n* [[Colshape]]s\n* [[createWeapon|Weapons]]\n* [[Camera]]s\n*The offset coodinates reflect the object space, not the world space. This means that you cannot calculate the exact offsets between two objects by pre-positioning them in the map editor as a reference. Please see [[attachElementsOffsets]] for more details.\n*Due to a limitation in GTA, unexpected attach rotations may occur if all rotation offsets are non-zero. (i.e. Try to ensure at least one of 'xRotOffset', 'yRotOffset' or 'zRotOffset' is zero).}}", arguments={'theElement': 'The element to be attached.', 'theAttachToElement': 'The element to attach the first to.\n{{OptionalArg}} ', 'xPosOffset': 'The x offset, if you want the elements to be a certain distance from one another (default 0).', 'yPosOffset': 'The y offset (default 0).', 'zPosOffset': 'The z offset (default 0).', 'xRotOffset': 'The x rotation offset (default 0).', 'yRotOffset': 'The y rotation offset (default 0).', 'zRotOffset': 'The z rotation offset (default 0).'}, result="Returns ''true'' if the attaching process was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='attach', field=None), url=FunctionUrl(url='/wiki/AttachElements', name='attachElements', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='attachElements', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theAttachToElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='xPosOffset', argument_type='float', default_value='0', optional=False), FunctionArgument(name='yPosOffset', argument_type='float', default_value='0', optional=False), FunctionArgument(name='zPosOffset', argument_type='float', default_value='0', optional=False), FunctionArgument(name='xRotOffset', argument_type='float', default_value='0', optional=False), FunctionArgument(name='yRotOffset', argument_type='float', default_value='0', optional=False), FunctionArgument(name='zRotOffset', argument_type='float', default_value='0', optional=False)]), docs=FunctionDoc(description="This function attaches one element to another, so that the first one follows the second whenever it moves. \nIf an attempt is made to attach two elements that are already attached the opposite way (eg theElement becomes theAttachToElement and vice versa), the 1st attachment order is automatically detached in favor of the 2nd attachment order. For example, if carA was attached to carB, now carB is attached to carA. Also, an element cannot be attached to two separate elements at one time. For example, two cars can be attached to one single car, but one single car cannot be attached to two separate cars. If you attempt to do this, the existing attachment will automatically be dropped in favor of the new attachment. For example, if carA is asked to attached to carB then carC, it is only attached to carC.\nThis is not compatible with all elements.  The following elements are compatible:\n* [[Ped]]s\n* [[Player]]s\n* [[Blip]]s\n* [[Vehicle]]s\n* [[Object]]s\n* [[Marker]]s\n* [[Pickup]]s\n* [[Sound]]s\n* [[Colshape]]s\n* [[createWeapon|Weapons]]\n* [[Camera]]s\n*The offset coodinates reflect the object space, not the world space. This means that you cannot calculate the exact offsets between two objects by pre-positioning them in the map editor as a reference. Please see [[attachElementsOffsets]] for more details.\n*Due to a limitation in GTA, unexpected attach rotations may occur if all rotation offsets are non-zero. (i.e. Try to ensure at least one of 'xRotOffset', 'yRotOffset' or 'zRotOffset' is zero).}}", arguments={'theElement': 'The element to be attached.', 'theAttachToElement': 'The element to attach the first to.\n{{OptionalArg}} ', 'xPosOffset': 'The x offset, if you want the elements to be a certain distance from one another (default 0).', 'yPosOffset': 'The y offset (default 0).', 'zPosOffset': 'The z offset (default 0).', 'xRotOffset': 'The x rotation offset (default 0).', 'yRotOffset': 'The y rotation offset (default 0).', 'zRotOffset': 'The z rotation offset (default 0).'}, result="Returns ''true'' if the attaching process was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='attach', field=None), url=FunctionUrl(url='/wiki/AttachElements', name='attachElements', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createElement', return_types=['element'], arguments=[FunctionArgument(name='elementType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='elementID', argument_type='string', default_value='nil', optional=False)]), docs=FunctionDoc(description="This function is used to create a new dummy element in the [[element tree]] which do not necessarily represent an entity within the San Andreas world. A common use for this function is for creating custom elements, such as a Flag or a Base.\nElements created using this function are placed in the element tree with their parent as the 'dynamic' map element.", arguments={'elementType': 'The type of element being created.', 'elementID': 'The ID of the element being created.'}, result="Returns the element if it was successfully created. Returns ''false'' if the arguments are wrong."), oop=None, url=FunctionUrl(url='/wiki/CreateElement', name='createElement', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createElement', return_types=['element'], arguments=[FunctionArgument(name='elementType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='elementID', argument_type='string', default_value='nil', optional=False)]), docs=FunctionDoc(description="This function is used to create a new dummy element in the [[element tree]] which do not necessarily represent an entity within the San Andreas world. A common use for this function is for creating custom elements, such as a Flag or a Base.\nElements created using this function are placed in the element tree with their parent as the 'dynamic' map element.", arguments={'elementType': 'The type of element being created.', 'elementID': 'The ID of the element being created.'}, result="Returns the element if it was successfully created. Returns ''false'' if the arguments are wrong."), oop=None, url=FunctionUrl(url='/wiki/CreateElement', name='createElement', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='destroyElement', return_types=['bool'], arguments=[FunctionArgument(name='elementToDestroy', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function destroys an [[element]] and all elements within it in the hierarchy (its children, the children of those children etc). [[player|Player]] elements cannot be destroyed using this function. A player can only be removed from the hierarchy when they quit or are kicked. The root element also cannot be destroyed, however, passing the root as an argument will wipe all elements from the server, except for the players and clients, which will become direct descendants of the root node, and other elements that cannot be destroyed, such as resource root elements.\nPlayers are not the only elements that cannot be deleted. This list also includes remote clients and console elements.', arguments={'elementToDestroy': 'The element you wish to destroy.'}, result="Returns ''true'' if the element was destroyed successfully, ''false'' if either the element passed to it was invalid or it could not be destroyed for some other reason (for example, clientside destroyElement can't destroy serverside elements)."), oop=FunctionOOP(class_name='element', method_name='destroy', field=None), url=FunctionUrl(url='/wiki/DestroyElement', name='destroyElement', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='destroyElement', return_types=['bool'], arguments=[FunctionArgument(name='elementToDestroy', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function destroys an [[element]] and all elements within it in the hierarchy (its children, the children of those children etc). [[player|Player]] elements cannot be destroyed using this function. A player can only be removed from the hierarchy when they quit or are kicked. The root element also cannot be destroyed, however, passing the root as an argument will wipe all elements from the server, except for the players and clients, which will become direct descendants of the root node, and other elements that cannot be destroyed, such as resource root elements.\nPlayers are not the only elements that cannot be deleted. This list also includes remote clients and console elements.', arguments={'elementToDestroy': 'The element you wish to destroy.'}, result="Returns ''true'' if the element was destroyed successfully, ''false'' if either the element passed to it was invalid or it could not be destroyed for some other reason (for example, clientside destroyElement can't destroy serverside elements)."), oop=FunctionOOP(class_name='element', method_name='destroy', field=None), url=FunctionUrl(url='/wiki/DestroyElement', name='destroyElement', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='detachElements', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theAttachToElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function detaches attached elements from one another.', arguments={'theElement': 'The element to be detached (the child)\n{{OptionalArg}} ', 'theAttachToElement': 'The element you wish to detach from, will detach from the attached element if this isnt specified.'}, result="Returns ''true'' if the detaching was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='detach', field=None), url=FunctionUrl(url='/wiki/DetachElements', name='detachElements', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='detachElements', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theAttachToElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function detaches attached elements from one another.', arguments={'theElement': 'The element to be detached (the child)\n{{OptionalArg}} ', 'theAttachToElement': 'The element you wish to detach from, will detach from the attached element if this isnt specified.'}, result="Returns ''true'' if the detaching was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='detach', field=None), url=FunctionUrl(url='/wiki/DetachElements', name='detachElements', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAttachedElements', return_types=['table'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a table of all the elements attached to the specified element', arguments={'theElement': ': The element which you require the information from.'}, result='Returns a table of all the elements attached to the specified element.'), oop=FunctionOOP(class_name='element', method_name='getAttachedElements', field=None), url=FunctionUrl(url='/wiki/GetAttachedElements', name='getAttachedElements', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getAttachedElements', return_types=['table'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a table of all the elements attached to the specified element', arguments={'theElement': ': The element which you require the information from.'}, result='Returns a table of all the elements attached to the specified element.'), oop=FunctionOOP(class_name='element', method_name='getAttachedElements', field=None), url=FunctionUrl(url='/wiki/GetAttachedElements', name='getAttachedElements', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementAlpha', return_types=['int'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the alpha (transparency) value for the specified [[element]]. This can be a [[player]], [[ped]], [[object]], [[vehicle]] or [[Element/Weapon|weapon]].', arguments={'theElement': 'The element whose alpha you want to retrieve.'}, result="Returns an integer (0-255; 0 = transparent) indicating the element's alpha, or ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='element', method_name='getAlpha', field='alpha'), url=FunctionUrl(url='/wiki/GetElementAlpha', name='getElementAlpha', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementAlpha', return_types=['int'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the alpha (transparency) value for the specified [[element]]. This can be a [[player]], [[ped]], [[object]], [[vehicle]] or [[Element/Weapon|weapon]].', arguments={'theElement': 'The element whose alpha you want to retrieve.'}, result="Returns an integer (0-255; 0 = transparent) indicating the element's alpha, or ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='element', method_name='getAlpha', field='alpha'), url=FunctionUrl(url='/wiki/GetElementAlpha', name='getElementAlpha', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementAttachedOffsets', return_types=['float,', 'float,', 'float,', 'float,', 'float,', 'float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the offsets of an element that has been attached to another element using [[attachElements]].', arguments={'theElement': 'The attached element.'}, result="Returns 6 [[float|floats]], of which the first 3 indicate the position offset (x, y, z), and the last 3 indicate the rotation offset (x, y, z), if successful. ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='getAttachedOffsets', field=None), url=FunctionUrl(url='/wiki/GetElementAttachedOffsets', name='getElementAttachedOffsets', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementAttachedOffsets', return_types=['float,', 'float,', 'float,', 'float,', 'float,', 'float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the offsets of an element that has been attached to another element using [[attachElements]].', arguments={'theElement': 'The attached element.'}, result="Returns 6 [[float|floats]], of which the first 3 indicate the position offset (x, y, z), and the last 3 indicate the rotation offset (x, y, z), if successful. ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='getAttachedOffsets', field=None), url=FunctionUrl(url='/wiki/GetElementAttachedOffsets', name='getElementAttachedOffsets', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementAttachedTo', return_types=['element'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function determines the element that the specified element is attached to.', arguments={'theElement': 'The element you require the information for.'}, result="Returns the element that the chosen element is attached to, or ''false'' if the element isn't attached to another element."), oop=FunctionOOP(class_name='element', method_name='getAttachedTo', field=None), url=FunctionUrl(url='/wiki/GetElementAttachedTo', name='getElementAttachedTo', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementAttachedTo', return_types=['element'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function determines the element that the specified element is attached to.', arguments={'theElement': 'The element you require the information for.'}, result="Returns the element that the chosen element is attached to, or ''false'' if the element isn't attached to another element."), oop=FunctionOOP(class_name='element', method_name='getAttachedTo', field=None), url=FunctionUrl(url='/wiki/GetElementAttachedTo', name='getElementAttachedTo', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getElementBoneMatrix', return_types=['table'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='bone', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='* [[Element/Player|Player]]\n* [[Element/Ped|Ped]]\n}}', arguments={'theElement': 'the element to get the bone matrix on.', 'bone': 'the ID of the bone to get the matrix of. See Bone IDs'}, result="Returns a multi-dimensional array (which can be transformed into a proper [[matrix]] class using ''Matrix.create'' method) containing a 4x4 matrix. Returns ''false'' if invalid arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/GetElementBoneMatrix', name='getElementBoneMatrix', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getElementBonePosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='bone', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='* [[Element/Player|Player]]\n* [[Element/Ped|Ped]]\n}}', arguments={'theElement': 'the element to get the bone position on.', 'bone': 'the ID of the bone to get the position of. See Bone IDs'}, result='Returns the x, y, z world position of the bone.'), oop=None, url=FunctionUrl(url='/wiki/GetElementBonePosition', name='getElementBonePosition', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getElementBoneRotation', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='bone', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='* [[Element/Player|Player]]\n* [[Element/Ped|Ped]]\n}}', arguments={'theElement': 'the element to get the bone rotation on.', 'bone': 'the ID of the bone to get the rotation of. See Bone IDs'}, result='Returns the yaw, pitch, roll rotation values.'), oop=None, url=FunctionUrl(url='/wiki/GetElementBoneRotation', name='getElementBoneRotation', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getElementBoundingBox', return_types=['float,', 'float,', 'float,', 'float,', 'float,', 'float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="This function returns the minimum and maximum coordinates of an element's bounding box.\nIt should be noted that the values returned are relative to the position of the element, and as such if you wish to get world coordinates for drawing, etc., you should retrieve the position of the element and add the returned values onto that.", arguments={}, result="*Returns ''min x, min y, min z, max x, max y, max z'' if the passed element is valid and streamed in, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetElementBoundingBox', name='getElementBoundingBox', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementByID', return_types=['element'], arguments=[FunctionArgument(name='id', argument_type='string', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value='0', optional=True)]), docs=FunctionDoc(description='This function returns an element from the specified ID. If more than one element with the same ID exists, only the first one in the order it appears in the XML tree will be returned by this function.', arguments={'id': 'The ID of the element as it appears in the XML file or as set by setElementID.\n{{optionalArg}}', 'index': 'If there are two or more elements of the same ID it will return the element with the specified index starting at 0.'}, result="Returns the [[element]] with the given ID, or ''false'' if no such element exists."), oop=None, url=FunctionUrl(url='/wiki/GetElementByID', name='getElementByID', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementByID', return_types=['element'], arguments=[FunctionArgument(name='id', argument_type='string', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value='0', optional=True)]), docs=FunctionDoc(description='This function returns an element from the specified ID. If more than one element with the same ID exists, only the first one in the order it appears in the XML tree will be returned by this function.', arguments={'id': 'The ID of the element as it appears in the XML file or as set by setElementID.\n{{optionalArg}}', 'index': 'If there are two or more elements of the same ID it will return the element with the specified index starting at 0.'}, result="Returns the [[element]] with the given ID, or ''false'' if no such element exists."), oop=None, url=FunctionUrl(url='/wiki/GetElementByID', name='getElementByID', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementChild', return_types=['element'], arguments=[FunctionArgument(name='parent', argument_type='element', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns one of the child elements of a given parent element. The child element is selected by its index (0 for the first child, 1 for the second and so on).', arguments={'parent': 'the element above the one to be returned in the hierarchy.', 'index': 'the elements index (0 for the first element, 1 for the second, etc).'}, result="Returns the requested element if it exists, or ''false'' if it doesn't."), oop=FunctionOOP(class_name='element', method_name='getChild', field=None), url=FunctionUrl(url='/wiki/GetElementChild', name='getElementChild', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementChild', return_types=['element'], arguments=[FunctionArgument(name='parent', argument_type='element', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns one of the child elements of a given parent element. The child element is selected by its index (0 for the first child, 1 for the second and so on).', arguments={'parent': 'the element above the one to be returned in the hierarchy.', 'index': 'the elements index (0 for the first element, 1 for the second, etc).'}, result="Returns the requested element if it exists, or ''false'' if it doesn't."), oop=FunctionOOP(class_name='element', method_name='getChild', field=None), url=FunctionUrl(url='/wiki/GetElementChild', name='getElementChild', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementChildren', return_types=['table'], arguments=[FunctionArgument(name='parent', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theType', argument_type='string', default_value='nil', optional=True)]), docs=FunctionDoc(description='This function is used to retrieve a list of the child elements of a given parent element. Note that it will only return direct children and not elements that are further down the [[element tree]].', arguments={'parent': 'Supply this argument with the parent of the children you want returned.', 'theType': 'The type of element you want a list of. This is the same as the tag name in the .map file, so this can be used with a custom element type if desired. Built in types are:', '"player"': 'A player connected to the server', '"ped"': 'A ped', '"water"': 'A water polygon', '"sound"': 'A playing sound', '"vehicle"': 'A vehicle', '"object"': 'An object', '"pickup"': 'A pickup', '"marker"': 'A marker', '"colshape"': 'A collision shape', '"blip"': 'A blip', '"radararea"': 'A radar area', '"team"': 'A team', '"spawnpoint"': 'A spawnpoint', '"remoteclient"': 'A remote client connected to the server', '"console"': 'The server Console'}, result="This function returns a ''table'' that contains a list of elements that the parent has. If the element has no children, it will return an empy ''table''. It will return ''false'' if the parent element does not exist."), oop=FunctionOOP(class_name='element', method_name='getChildren', field=None), url=FunctionUrl(url='/wiki/GetElementChildren', name='getElementChildren', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementChildren', return_types=['table'], arguments=[FunctionArgument(name='parent', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theType', argument_type='string', default_value='nil', optional=True)]), docs=FunctionDoc(description='This function is used to retrieve a list of the child elements of a given parent element. Note that it will only return direct children and not elements that are further down the [[element tree]].', arguments={'parent': 'Supply this argument with the parent of the children you want returned.', 'theType': 'The type of element you want a list of. This is the same as the tag name in the .map file, so this can be used with a custom element type if desired. Built in types are:', '"player"': 'A player connected to the server', '"ped"': 'A ped', '"water"': 'A water polygon', '"sound"': 'A playing sound', '"vehicle"': 'A vehicle', '"object"': 'An object', '"pickup"': 'A pickup', '"marker"': 'A marker', '"colshape"': 'A collision shape', '"blip"': 'A blip', '"radararea"': 'A radar area', '"team"': 'A team', '"spawnpoint"': 'A spawnpoint', '"remoteclient"': 'A remote client connected to the server', '"console"': 'The server Console'}, result="This function returns a ''table'' that contains a list of elements that the parent has. If the element has no children, it will return an empy ''table''. It will return ''false'' if the parent element does not exist."), oop=FunctionOOP(class_name='element', method_name='getChildren', field=None), url=FunctionUrl(url='/wiki/GetElementChildren', name='getElementChildren', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementChildrenCount', return_types=['int'], arguments=[FunctionArgument(name='parent', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the number of children an element has. Note that only the direct children are counted and not elements that are further down the [[element tree]].', arguments={'parent': 'the parent element'}, result="Returns an ''int'' with the number of child elements, or ''false'' if the parent element does not exist."), oop=FunctionOOP(class_name='element', method_name='getChildrenCount', field=None), url=FunctionUrl(url='/wiki/GetElementChildrenCount', name='getElementChildrenCount', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementChildrenCount', return_types=['int'], arguments=[FunctionArgument(name='parent', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the number of children an element has. Note that only the direct children are counted and not elements that are further down the [[element tree]].', arguments={'parent': 'the parent element'}, result="Returns an ''int'' with the number of child elements, or ''false'' if the parent element does not exist."), oop=FunctionOOP(class_name='element', method_name='getChildrenCount', field=None), url=FunctionUrl(url='/wiki/GetElementChildrenCount', name='getElementChildrenCount', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementColShape', return_types=['colshape'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='Some elements have an associated colshape, for example [[Marker]] and [[Pickup]]. This function is used to get the associated colshape.', arguments={'theElement': 'The element you want to get the colshape of'}, result="Returns ''colshape'' of the element, ''false'' if not or an invalid argument was passed to the function."), oop=FunctionOOP(class_name='element', method_name='getColShape', field='colShape'), url=FunctionUrl(url='/wiki/GetElementColShape', name='getElementColShape', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementColShape', return_types=['colshape'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='Some elements have an associated colshape, for example [[Marker]] and [[Pickup]]. This function is used to get the associated colshape.', arguments={'theElement': 'The element you want to get the colshape of'}, result="Returns ''colshape'' of the element, ''false'' if not or an invalid argument was passed to the function."), oop=FunctionOOP(class_name='element', method_name='getColShape', field='colShape'), url=FunctionUrl(url='/wiki/GetElementColShape', name='getElementColShape', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementCollisionsEnabled', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function indicates if a specific element is set to have collisions disabled. An element without collisions does not interact with the physical environment and remains static.', arguments={'theElement': 'The element for which you want to check whether collisions are enabled'}, result="Returns ''true'' if the collisions are enabled, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='getCollisionsEnabled', field='collisions'), url=FunctionUrl(url='/wiki/GetElementCollisionsEnabled', name='getElementCollisionsEnabled', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementCollisionsEnabled', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function indicates if a specific element is set to have collisions disabled. An element without collisions does not interact with the physical environment and remains static.', arguments={'theElement': 'The element for which you want to check whether collisions are enabled'}, result="Returns ''true'' if the collisions are enabled, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='getCollisionsEnabled', field='collisions'), url=FunctionUrl(url='/wiki/GetElementCollisionsEnabled', name='getElementCollisionsEnabled', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementData', return_types=['var'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='inherit', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description='This function retrieves [[element data]] attached to an element under a certain key.', arguments={'theElement': 'This is the element with data you want to retrieve.', 'key': 'The name of the element data entry you want to retrieve. (Maximum 31 characters.)', 'inherit': '- toggles whether or not the function should go up the hierarchy to find the requested key in case the specified element doesnt have it.'}, result="This function returns a ''variable'' containing the requested element data, or ''false'' if the element or the element data does not exist. When getting data corresponding to a XML attribute, this is always a ''string''."), oop=FunctionOOP(class_name='element', method_name='getData', field=None), url=FunctionUrl(url='/wiki/GetElementData', name='getElementData', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementData', return_types=['var'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='inherit', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description='This function retrieves [[element data]] attached to an element under a certain key.', arguments={'theElement': 'This is the element with data you want to retrieve.', 'key': 'The name of the element data entry you want to retrieve. (Maximum 31 characters.)', 'inherit': '- toggles whether or not the function should go up the hierarchy to find the requested key in case the specified element doesnt have it.'}, result="This function returns a ''variable'' containing the requested element data, or ''false'' if the element or the element data does not exist. When getting data corresponding to a XML attribute, this is always a ''string''."), oop=FunctionOOP(class_name='element', method_name='getData', field=None), url=FunctionUrl(url='/wiki/GetElementData', name='getElementData', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementDimension', return_types=['int'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to retrieve the dimension of any element. The dimension determines what/who the element is visible to.', arguments={'theElement': 'The element in which youd like to retrieve the dimension of.'}, result="Returns an integer for the dimension if '''theElement''' is valid, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='getDimension', field='dimension'), url=FunctionUrl(url='/wiki/GetElementDimension', name='getElementDimension', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementDimension', return_types=['int'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to retrieve the dimension of any element. The dimension determines what/who the element is visible to.', arguments={'theElement': 'The element in which youd like to retrieve the dimension of.'}, result="Returns an integer for the dimension if '''theElement''' is valid, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='getDimension', field='dimension'), url=FunctionUrl(url='/wiki/GetElementDimension', name='getElementDimension', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getElementDistanceFromCentreOfMassToBaseOfModel', return_types=['float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to retrieve the distance between a [[element]]'s centre of mass to the base of the model. This can be used to calculate the position the [[element]] has to be set to, to have it on ground level.", arguments={}, result="Returns a ''float'' with the distance, or ''false'' if the element is invalid."), oop=FunctionOOP(class_name='element', method_name='getDistanceFromCentreOfMassToBaseOfModel', field="distanceFromCentreOfMassToBaseOfModel}}\n\n===Required Parameters===\n'''theElement:''' The element you want to retrieve the value of.\n\n===Returns===\nReturns a ''float'' with the distance, or ''false'' if the element is invalid.\n\n"), url=FunctionUrl(url='/wiki/GetElementDistanceFromCentreOfMassToBaseOfModel', name='getElementDistanceFromCentreOfMassToBaseOfModel', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementHealth', return_types=['float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current health for the specified [[element]]. This can be a [[player]], a [[ped]], a [[vehicle]], or an [[object]].', arguments={'theElement': 'The player or vehicle whose health you want to check.'}, result="Returns a float indicating the element's health, or ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='element', method_name='getHealth', field='health'), url=FunctionUrl(url='/wiki/GetElementHealth', name='getElementHealth', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementHealth', return_types=['float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current health for the specified [[element]]. This can be a [[player]], a [[ped]], a [[vehicle]], or an [[object]].', arguments={'theElement': 'The player or vehicle whose health you want to check.'}, result="Returns a float indicating the element's health, or ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='element', method_name='getHealth', field='health'), url=FunctionUrl(url='/wiki/GetElementHealth', name='getElementHealth', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementID', return_types=['string'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the ID of an element. This is the "id" attribute of the element and is a string, NOT a number like a model ID, weapons ID or similar.', arguments={'theElement': 'the element from which to retrieve the ID.'}, result="This returns a ''string'' containing the element ID. It will return an empty ''string'' if it has no ID. It will return ''false'' if the element is invalid."), oop=FunctionOOP(class_name='element', method_name='getID', field='id'), url=FunctionUrl(url='/wiki/GetElementID', name='getElementID', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementID', return_types=['string'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the ID of an element. This is the "id" attribute of the element and is a string, NOT a number like a model ID, weapons ID or similar.', arguments={'theElement': 'the element from which to retrieve the ID.'}, result="This returns a ''string'' containing the element ID. It will return an empty ''string'' if it has no ID. It will return ''false'' if the element is invalid."), oop=FunctionOOP(class_name='element', method_name='getID', field='id'), url=FunctionUrl(url='/wiki/GetElementID', name='getElementID', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementInterior', return_types=['int'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to retrieve the interior of any element. An interior is the current loaded place, 0 being outside.', arguments={'theElement': 'The element of which youd like to retrieve the interior'}, result="Returns an [[int]] for the interior if '''theElement''' is valid, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='getInterior', field='interior'), url=FunctionUrl(url='/wiki/GetElementInterior', name='getElementInterior', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementInterior', return_types=['int'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to retrieve the interior of any element. An interior is the current loaded place, 0 being outside.', arguments={'theElement': 'The element of which youd like to retrieve the interior'}, result="Returns an [[int]] for the interior if '''theElement''' is valid, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='getInterior', field='interior'), url=FunctionUrl(url='/wiki/GetElementInterior', name='getElementInterior', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementModel', return_types=['int'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the model ID of a given element. This can be a player/ped skin, a pickup model, an object model or a vehicle model.', arguments={'theElement': 'the element to retrieve the model ID of.'}, result="Returns the model ID if successful, ''false'' otherwise.\n* For players/peds: A GTASA player model (skin) ID. See [[Character Skins]].\n* For vehicles: The [[Vehicle IDs|vehicle ID]] of the vehicle.\n* For objects: An [[int]] specifying the model id."), oop=FunctionOOP(class_name='element', method_name='getModel', field='model'), url=FunctionUrl(url='/wiki/GetElementModel', name='getElementModel', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementModel', return_types=['int'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the model ID of a given element. This can be a player/ped skin, a pickup model, an object model or a vehicle model.', arguments={'theElement': 'the element to retrieve the model ID of.'}, result="Returns the model ID if successful, ''false'' otherwise.\n* For players/peds: A GTASA player model (skin) ID. See [[Character Skins]].\n* For vehicles: The [[Vehicle IDs|vehicle ID]] of the vehicle.\n* For objects: An [[int]] specifying the model id."), oop=FunctionOOP(class_name='element', method_name='getModel', field='model'), url=FunctionUrl(url='/wiki/GetElementModel', name='getElementModel', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementParent', return_types=['element'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to determine the parent of an ''element''.", arguments={'theElement': 'The child of the parent element you want returned.'}, result="This returns the parent as an ''element''. It returns ''false'' if ''theElement'' is invalid, or is the root node."), oop=FunctionOOP(class_name='element', method_name='getParent', field='parent'), url=FunctionUrl(url='/wiki/GetElementParent', name='getElementParent', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementParent', return_types=['element'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to determine the parent of an ''element''.", arguments={'theElement': 'The child of the parent element you want returned.'}, result="This returns the parent as an ''element''. It returns ''false'' if ''theElement'' is invalid, or is the root node."), oop=FunctionOOP(class_name='element', method_name='getParent', field='parent'), url=FunctionUrl(url='/wiki/GetElementParent', name='getElementParent', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementPosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='The getElementPosition function allows you to retrieve the position coordinates of an element.  This can be any real world element, including:\n* [[Element/Player|Players]]\n* [[Element/Vehicle|Vehicles]]\n* [[Element/Object|Objects]]\n* [[Element/Pickup|Pickups]]\n* [[Element/Marker|Markers]]\n* [[Element/Collision shape|Collision shapes]]\n* [[Element/Blip|Blips]]\n* [[Element/Radar area|Radar areas]]', arguments={'theElement': 'The element which youd like to retrieve the location of'}, result="Returns three ''float''s indicating the position of the element, ''x'', ''y'' and ''z'' respectively."), oop=FunctionOOP(class_name='element', method_name='getPosition', field='position'), url=FunctionUrl(url='/wiki/GetElementPosition', name='getElementPosition', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementPosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='The getElementPosition function allows you to retrieve the position coordinates of an element.  This can be any real world element, including:\n* [[Element/Player|Players]]\n* [[Element/Vehicle|Vehicles]]\n* [[Element/Object|Objects]]\n* [[Element/Pickup|Pickups]]\n* [[Element/Marker|Markers]]\n* [[Element/Collision shape|Collision shapes]]\n* [[Element/Blip|Blips]]\n* [[Element/Radar area|Radar areas]]', arguments={'theElement': 'The element which youd like to retrieve the location of'}, result="Returns three ''float''s indicating the position of the element, ''x'', ''y'' and ''z'' respectively."), oop=FunctionOOP(class_name='element', method_name='getPosition', field='position'), url=FunctionUrl(url='/wiki/GetElementPosition', name='getElementPosition', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getElementRadius', return_types=['float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the radius of an [[element]]. Normally, sphere or circle-shaped elements tend to return a more accurate and expected radius than others with another shapes.', arguments={'theElement': 'The element to get the radius of. It can be any entity type, such as:', '[[player|Players]]': '.', '[[ped|Peds]]': '.', '[[vehicle|Vehicles]]': '.', '[[object|Objects]]': '.'}, result="Returns a ''float'' containing the radius if the element is valid, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='getRadius', field="radius}}}}\n\n===Required Arguments=== \n*'''theElement:''' The element to get the radius of. It can be any entity type, such as:\n** '''[[player"), url=FunctionUrl(url='/wiki/GetElementRadius', name='getElementRadius', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementRotation', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rotOrder', argument_type='string', default_value='"default"', optional=True)]), docs=FunctionDoc(description='Retrieve the rotation of elements.', arguments={'theElement': 'The element whose rotation will be retrieved', 'rotOrder': 'A string representing the rotation order desired when returning the http://en.wikipedia.org/wiki/Euler_angles euler angles. If omitted, default value is default. Allowed values are:', '"default"': 'default MTA behavior prior to 1.1, where rotation order depends on element type', '"ZXY"': 'rotation about the Z axis (up), then about the resulting X axis (right) and finally about the resulting Y axis (front). This is the default rotation order for object|objects', '"ZYX"': 'rotation about the Z axis (up), then about the resulting Y axis (front), and finally about the resulting X axis (right). This is the default rotation order for vehicle|vehicles\nThe default rotation order for peds/players is Z-Y-X (clientside) and -Z-Y-X (serverside) but those rotation orders (set using \'\'"default"\'\' on peds) can not be used manually on other element types since they only exist due to historical and backward compatibility reasons.\nSpecifying a rotation order other than \'\'"default"\'\' allows the same angles to later be uniformly used on several elements without having to consider their type.'}, result="* ''rx, ry, rz'': 3 ''float''s representing the Euler rotation angles on the axis X, Y and Z (with the rotation order depending on the ''rotOrder'' argument) if ''element'' exists and is a valid element, ''false'' if it's invalid."), oop=FunctionOOP(class_name='element', method_name='getRotation', field='rotation'), url=FunctionUrl(url='/wiki/GetElementRotation', name='getElementRotation', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementRotation', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rotOrder', argument_type='string', default_value='"default"', optional=True)]), docs=FunctionDoc(description='Retrieve the rotation of elements.', arguments={'theElement': 'The element whose rotation will be retrieved', 'rotOrder': 'A string representing the rotation order desired when returning the http://en.wikipedia.org/wiki/Euler_angles euler angles. If omitted, default value is default. Allowed values are:', '"default"': 'default MTA behavior prior to 1.1, where rotation order depends on element type', '"ZXY"': 'rotation about the Z axis (up), then about the resulting X axis (right) and finally about the resulting Y axis (front). This is the default rotation order for object|objects', '"ZYX"': 'rotation about the Z axis (up), then about the resulting Y axis (front), and finally about the resulting X axis (right). This is the default rotation order for vehicle|vehicles\nThe default rotation order for peds/players is Z-Y-X (clientside) and -Z-Y-X (serverside) but those rotation orders (set using \'\'"default"\'\' on peds) can not be used manually on other element types since they only exist due to historical and backward compatibility reasons.\nSpecifying a rotation order other than \'\'"default"\'\' allows the same angles to later be uniformly used on several elements without having to consider their type.'}, result="* ''rx, ry, rz'': 3 ''float''s representing the Euler rotation angles on the axis X, Y and Z (with the rotation order depending on the ''rotOrder'' argument) if ''element'' exists and is a valid element, ''false'' if it's invalid."), oop=FunctionOOP(class_name='element', method_name='getRotation', field='rotation'), url=FunctionUrl(url='/wiki/GetElementRotation', name='getElementRotation', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementType', return_types=['string'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to retrieve the type of an element.', arguments={'theElement': 'The element you wish to get the type of.'}, result="Returns a ''string'' containing the element type, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='element', method_name='getType', field='type'), url=FunctionUrl(url='/wiki/GetElementType', name='getElementType', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementType', return_types=['string'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to retrieve the type of an element.', arguments={'theElement': 'The element you wish to get the type of.'}, result="Returns a ''string'' containing the element type, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='element', method_name='getType', field='type'), url=FunctionUrl(url='/wiki/GetElementType', name='getElementType', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementVelocity', return_types=['float', 'float', 'float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns three floats containing the velocity (movement speeds) along the X, Y, and Z axis respectively. This means that velocity values can be positive and negative for each axis. ', arguments={'theElement': ': The element you wish to retrieve the velocity of.'}, result="If succesful, returns three ''float''s that represent the element's current velocity along the ''x'', ''y'', and ''z'' axis respectively. This function can fail if the element is a player in a car. Use the vehicle element in this case. It will also fail if the element specified does not have a velocity, or does not exist. In case of failure, the first return value will be ''false''.\nThe returned values are expressed in GTA units per 1/50th of a second[http://forum.mtasa.com/viewtopic.php?f=91&t=31225]. A GTA Unit is equal to one metre[http://gta.wikia.com/Unit#GTA3.2C_GTAVC_.26_GTASA]."), oop=FunctionOOP(class_name='element', method_name='getVelocity', field='velocity'), url=FunctionUrl(url='/wiki/GetElementVelocity', name='getElementVelocity', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementVelocity', return_types=['float', 'float', 'float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns three floats containing the velocity (movement speeds) along the X, Y, and Z axis respectively. This means that velocity values can be positive and negative for each axis. ', arguments={'theElement': ': The element you wish to retrieve the velocity of.'}, result="If succesful, returns three ''float''s that represent the element's current velocity along the ''x'', ''y'', and ''z'' axis respectively. This function can fail if the element is a player in a car. Use the vehicle element in this case. It will also fail if the element specified does not have a velocity, or does not exist. In case of failure, the first return value will be ''false''.\nThe returned values are expressed in GTA units per 1/50th of a second[http://forum.mtasa.com/viewtopic.php?f=91&t=31225]. A GTA Unit is equal to one metre[http://gta.wikia.com/Unit#GTA3.2C_GTAVC_.26_GTASA]."), oop=FunctionOOP(class_name='element', method_name='getVelocity', field='velocity'), url=FunctionUrl(url='/wiki/GetElementVelocity', name='getElementVelocity', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementsByType', return_types=['table'], arguments=[FunctionArgument(name='theType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='startat', argument_type='element', default_value='getRootElement(', optional=False)]), docs=FunctionDoc(description='This function is used to retrieve a list of all elements of the specified type. This can be useful, as it disregards \'\'where\'\' in the element tree it is. It can be used with either the built in types (listed below) or with any custom type used in a .map file. For example, if there is an element of type "flag" (e.g. <flag />) in the .map file, the using "flag" as the type argument would find it.', arguments={}, result="Returns a ''table'' containing all the elements of the specified type. Returns an empty ''table'' if there are no elements of the specified type. Returns ''false'' if the string specified is invalid (or not a string)."), oop=None, url=FunctionUrl(url='/wiki/GetElementsByType', name='getElementsByType', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementsByType', return_types=['table'], arguments=[FunctionArgument(name='theType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='startat', argument_type='element', default_value='getRootElement(', optional=False), FunctionArgument(name='streamedIn', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='This function is used to retrieve a list of all elements of the specified type. This can be useful, as it disregards \'\'where\'\' in the element tree it is. It can be used with either the built in types (listed below) or with any custom type used in a .map file. For example, if there is an element of type "flag" (e.g. <flag />) in the .map file, the using "flag" as the type argument would find it.', arguments={}, result="Returns a ''table'' containing all the elements of the specified type. Returns an empty ''table'' if there are no elements of the specified type. Returns ''false'' if the string specified is invalid (or not a string)."), oop=None, url=FunctionUrl(url='/wiki/GetElementsByType', name='getElementsByType', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementsWithinColShape', return_types=['table'], arguments=[FunctionArgument(name='theShape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='elemType', argument_type='string', default_value='nil', optional=True)]), docs=FunctionDoc(description="This function is used to retrieve a list of all elements in a colshape, of the specified type.\n* For legacy reasons, a colshape created on the client does not collide with elements already existing at that location until they first move\n* This function doesn't verify whether elements are in the same dimension and interior, additional checks could be implemented manually if they are needed\n}}", arguments={'theShape': 'The colshape you want to get the elements from.', 'elemType': 'The type of element you want a list of. This can be any element type, the common ones being:', '"player"': 'A player connected to the server', '"ped"': 'A ped', '"vehicle"': 'A vehicle', '"object"': 'An object', '"pickup"': 'A pickup', '"marker"': 'A marker', '"spawnpoint"': 'A spawnpoint', '"remoteclient"': 'A remote client connected to the server', '"console"': 'The server Console-->'}, result="Returns a [[table]] containing all the elements inside the colshape, of the specified type. Returns an empty [[table]] if there are no elements inside. Returns ''false'' if the colshape is invalid."), oop=FunctionOOP(class_name='colshape', method_name='getElementsWithin', field='elementsWithin'), url=FunctionUrl(url='/wiki/GetElementsWithinColShape', name='getElementsWithinColShape', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementsWithinColShape', return_types=['table'], arguments=[FunctionArgument(name='theShape', argument_type='colshape', default_value=None, optional=False), FunctionArgument(name='elemType', argument_type='string', default_value='nil', optional=True)]), docs=FunctionDoc(description="This function is used to retrieve a list of all elements in a colshape, of the specified type.\n* For legacy reasons, a colshape created on the client does not collide with elements already existing at that location until they first move\n* This function doesn't verify whether elements are in the same dimension and interior, additional checks could be implemented manually if they are needed\n}}", arguments={'theShape': 'The colshape you want to get the elements from.', 'elemType': 'The type of element you want a list of. This can be any element type, the common ones being:', '"player"': 'A player connected to the server', '"ped"': 'A ped', '"vehicle"': 'A vehicle', '"object"': 'An object', '"pickup"': 'A pickup', '"marker"': 'A marker', '"spawnpoint"': 'A spawnpoint', '"remoteclient"': 'A remote client connected to the server', '"console"': 'The server Console-->'}, result="Returns a [[table]] containing all the elements inside the colshape, of the specified type. Returns an empty [[table]] if there are no elements inside. Returns ''false'' if the colshape is invalid."), oop=FunctionOOP(class_name='colshape', method_name='getElementsWithin', field='elementsWithin'), url=FunctionUrl(url='/wiki/GetElementsWithinColShape', name='getElementsWithinColShape', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementsWithinRange', return_types=['table'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='range', argument_type='float', default_value=None, optional=False), FunctionArgument(name='elemType', argument_type='string', default_value='""', optional=True)]), docs=FunctionDoc(description="* This function checks if elements are in a box, not in a sphere.\n* Z argument isn't in use currently, but make your scripts like it is for future compatibility reasons.\n* This function doesn't work with elements which is created by createElement.}}", arguments={'x': 'the x coordinate at which to retrieve elements', 'y': 'the y coordinate at which to retrieve elements', 'z': 'the z coordinate at which to retrieve elements', 'range': 'the range at the coordinates in which to retrieve elements', 'elemType': 'The type of element you want a list of. This can be any element type, such as:', '"player"': 'A player connected to the server', '"ped"': 'A ped', '"vehicle"': 'A vehicle', '"object"': 'An object', '"pickup"': 'A pickup', '"marker"': 'A marker', 'interior': 'The interior you want to limit the search to. If not specified, it can return elements in any interior.', 'dimension': 'The dimension you want to limit the search to. If not specified, it can return elements in any dimension.\n}}'}, result="Returns a [[table]] containing all the elements of the specified type within range. Returns an empty [[table]] if there are no elements within range. Returns ''false'' if the arguments are invalid."), oop=FunctionOOP(class_name='Element', method_name='getWithinRange}}\n===Required Arguments===\n*\'\'\'x:\'\'\' the x coordinate at which to retrieve elements\n*\'\'\'y:\'\'\' the y coordinate at which to retrieve elements\n*\'\'\'z:\'\'\' the z coordinate at which to retrieve elements\n*\'\'\'range:\'\'\' the range at the coordinates in which to retrieve elements\n\n===Optional Arguments===\n*\'\'\'elemType:\'\'\' The type of element you want a list of. This can be any element type, such as:\n**\'\'\'"player":\'\'\' A player connected to the server\n**\'\'\'"ped":\'\'\' A ped\n**\'\'\'"vehicle":\'\'\' A vehicle\n**\'\'\'"object":\'\'\' An object\n**\'\'\'"pickup":\'\'\' A pickup\n**\'\'\'"marker":\'\'\' A marker\n\n{{New feature/item', field='3.0160'), url=FunctionUrl(url='/wiki/GetElementsWithinRange', name='getElementsWithinRange', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementsWithinRange', return_types=['table'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='range', argument_type='float', default_value=None, optional=False), FunctionArgument(name='elemType', argument_type='string', default_value='""', optional=True)]), docs=FunctionDoc(description="* This function checks if elements are in a box, not in a sphere.\n* Z argument isn't in use currently, but make your scripts like it is for future compatibility reasons.\n* This function doesn't work with elements which is created by createElement.}}", arguments={'x': 'the x coordinate at which to retrieve elements', 'y': 'the y coordinate at which to retrieve elements', 'z': 'the z coordinate at which to retrieve elements', 'range': 'the range at the coordinates in which to retrieve elements', 'elemType': 'The type of element you want a list of. This can be any element type, such as:', '"player"': 'A player connected to the server', '"ped"': 'A ped', '"vehicle"': 'A vehicle', '"object"': 'An object', '"pickup"': 'A pickup', '"marker"': 'A marker', 'interior': 'The interior you want to limit the search to. If not specified, it can return elements in any interior.', 'dimension': 'The dimension you want to limit the search to. If not specified, it can return elements in any dimension.\n}}'}, result="Returns a [[table]] containing all the elements of the specified type within range. Returns an empty [[table]] if there are no elements within range. Returns ''false'' if the arguments are invalid."), oop=FunctionOOP(class_name='Element', method_name='getWithinRange}}\n===Required Arguments===\n*\'\'\'x:\'\'\' the x coordinate at which to retrieve elements\n*\'\'\'y:\'\'\' the y coordinate at which to retrieve elements\n*\'\'\'z:\'\'\' the z coordinate at which to retrieve elements\n*\'\'\'range:\'\'\' the range at the coordinates in which to retrieve elements\n\n===Optional Arguments===\n*\'\'\'elemType:\'\'\' The type of element you want a list of. This can be any element type, such as:\n**\'\'\'"player":\'\'\' A player connected to the server\n**\'\'\'"ped":\'\'\' A ped\n**\'\'\'"vehicle":\'\'\' A vehicle\n**\'\'\'"object":\'\'\' An object\n**\'\'\'"pickup":\'\'\' A pickup\n**\'\'\'"marker":\'\'\' A marker\n\n{{New feature/item', field='3.0160'), url=FunctionUrl(url='/wiki/GetElementsWithinRange', name='getElementsWithinRange', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getLowLODElement', return_types=['element'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function return the low LOD element that an element is associated with.', arguments={'theElement': 'The element whose low LOD version we want to get.'}, result="Returns a low LOD element if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='getLowLOD', field='lowLOD'), url=FunctionUrl(url='/wiki/GetLowLODElement', name='getLowLODElement', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getLowLODElement', return_types=['element'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function return the low LOD element that an element is associated with.', arguments={'theElement': 'The element whose low LOD version we want to get.'}, result="Returns a low LOD element if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='getLowLOD', field='lowLOD'), url=FunctionUrl(url='/wiki/GetLowLODElement', name='getLowLODElement', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getRootElement', return_types=['element'], arguments=[]), docs=FunctionDoc(description="This function returns the root node of the [[element tree]], called ''root''. This node contains every other element: all resource root elements, players and remote clients. It is never destroyed and cannot be destroyed using [[destroyElement]].\nIt is often used to attach handler functions to events triggered for any element, or also to make a scripting function affect all elements.", arguments={}, result='Returns the root [[element]].'), oop=None, url=FunctionUrl(url='/wiki/GetRootElement', name='getRootElement', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getRootElement', return_types=['element'], arguments=[]), docs=FunctionDoc(description="This function returns the root node of the [[element tree]], called ''root''. This node contains every other element: all resource root elements, players and remote clients. It is never destroyed and cannot be destroyed using [[destroyElement]].\nIt is often used to attach handler functions to events triggered for any element, or also to make a scripting function affect all elements.", arguments={}, result='Returns the root [[element]].'), oop=None, url=FunctionUrl(url='/wiki/GetRootElement', name='getRootElement', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isElement', return_types=['bool'], arguments=[FunctionArgument(name='theValue', argument_type='var', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if a value is an [[element]] or not.', arguments={'theValue': ': The value that we want to check.'}, result="Returns ''true'' if the passed value is an element, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsElement', name='isElement', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isElement', return_types=['bool'], arguments=[FunctionArgument(name='theValue', argument_type='var', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if a value is an [[element]] or not.', arguments={'theValue': ': The value that we want to check.'}, result="Returns ''true'' if the passed value is an element, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsElement', name='isElement', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isElementAttached', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis functions checks whether or not an element is attached to another element.", arguments={'theElement': 'The element to check for attachment.'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the specified element is attached to another element, ''false'' if it is not attached or ''nil'' if an improper argument was passed."), oop=FunctionOOP(class_name='element', method_name='isAttached', field='attached'), url=FunctionUrl(url='/wiki/IsElementAttached', name='isElementAttached', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isElementAttached', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis functions checks whether or not an element is attached to another element.", arguments={'theElement': 'The element to check for attachment.'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the specified element is attached to another element, ''false'' if it is not attached or ''nil'' if an improper argument was passed."), oop=FunctionOOP(class_name='element', method_name='isAttached', field='attached'), url=FunctionUrl(url='/wiki/IsElementAttached', name='isElementAttached', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isElementCallPropagationEnabled', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This functions checks if certain element has call propagation enabled.', arguments={'theElement': 'The element to check'}, result="Returns ''true'' if the propagation is enabled, ''false'' if disabled or invalid arguments have been passed."), oop=FunctionOOP(class_name='element', method_name='isCallPropagationEnabled', field=None), url=FunctionUrl(url='/wiki/IsElementCallPropagationEnabled', name='isElementCallPropagationEnabled', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isElementCollidableWith', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='withElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="This function can be used to check whether specified element is collidable with another element.<br>\n'''Note:''' You can only use this function with the element types listed below.\n*[[Player]]\n*[[Ped]]\n*[[Vehicle]]\n*[[Object]]", arguments={'theElement': 'The element which colliding you want to get', 'withElement': 'The other element which colliding with the first entity you want to get'}, result="Returns ''true'' if the elements collide with eachother, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='isCollidableWith', field=None), url=FunctionUrl(url='/wiki/IsElementCollidableWith', name='isElementCollidableWith', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isElementDoubleSided', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks whether an element is double-sided as set by [[setElementDoubleSided]] or not.', arguments={'theElement': 'The element in which youd like to check the double-sidedness of.'}, result="Returns ''true'' if the '''theElement''' is double-sided, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='isDoubleSided', field='doubleSided'), url=FunctionUrl(url='/wiki/IsElementDoubleSided', name='isElementDoubleSided', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isElementDoubleSided', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks whether an element is double-sided as set by [[setElementDoubleSided]] or not.', arguments={'theElement': 'The element in which youd like to check the double-sidedness of.'}, result="Returns ''true'' if the '''theElement''' is double-sided, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='isDoubleSided', field='doubleSided'), url=FunctionUrl(url='/wiki/IsElementDoubleSided', name='isElementDoubleSided', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isElementFrozen', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if element has been frozen.', arguments={'theElement': 'the element whose freeze status we want to check.'}, result="*Returns ''true'' if the element is frozen, ''false'' if it isn't or if invalid arguments were passed."), oop=FunctionOOP(class_name='element', method_name='isFrozen', field='frozen'), url=FunctionUrl(url='/wiki/IsElementFrozen', name='isElementFrozen', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isElementFrozen', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if element has been frozen.', arguments={'theElement': 'the element whose freeze status we want to check.'}, result="*Returns ''true'' if the element is frozen, ''false'' if it isn't or if invalid arguments were passed."), oop=FunctionOOP(class_name='element', method_name='isFrozen', field='frozen'), url=FunctionUrl(url='/wiki/IsElementFrozen', name='isElementFrozen', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isElementInWater', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks whether an [[element]] is submerged in water.', arguments={'theElement': ': The element to check.'}, result="Returns ''true'' if the passed element is in water, ''false'' if it isn't, or if the element is invalid."), oop=FunctionOOP(class_name='element', method_name='isInWater', field="inWater}}\n\n===Required Arguments===\n* '''theElement''': The element to check.\n\n===Returns===\nReturns ''true'' if the passed element is in water, ''false'' if it isn't, or if the element is invalid.\n\n"), url=FunctionUrl(url='/wiki/IsElementInWater', name='isElementInWater', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isElementInWater', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks whether an [[element]] is submerged in water.', arguments={'theElement': ': The element to check.'}, result="Returns ''true'' if the passed element is in water, ''false'' if it isn't, or if the element is invalid."), oop=FunctionOOP(class_name='element', method_name='isInWater', field="inWater}}\n\n===Required Arguments===\n* '''theElement''': The element to check.\n\n===Returns===\nReturns ''true'' if the passed element is in water, ''false'' if it isn't, or if the element is invalid.\n\n"), url=FunctionUrl(url='/wiki/IsElementInWater', name='isElementInWater', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isElementLocal', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="This function checks whether a clientside [[element]] is local to the client (doesn't exist in the server) or not.", arguments={'theElement': ': The element that we want to check.'}, result="Returns ''true'' if the passed element is local, ''false'' if not or if invalid parameters are passed."), oop=FunctionOOP(class_name='element', method_name='isLocal', field="localElement}}}}\n\n===Required Arguments===\n* '''theElement''': The [[element]] that we want to check.\n\n===Returns===\nReturns ''true'' if the passed element is local, ''false'' if not or if invalid parameters are passed.\n\n"), url=FunctionUrl(url='/wiki/IsElementLocal', name='isElementLocal', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isElementLowLOD', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function reveals if an element is low LOD.', arguments={'theElement': 'The element whose low LOD status we want to get.'}, result="Returns ''true'' if the element is low LOD, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='isLowLOD', field=None), url=FunctionUrl(url='/wiki/IsElementLowLOD', name='isElementLowLOD', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isElementLowLOD', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function reveals if an element is low LOD.', arguments={'theElement': 'The element whose low LOD status we want to get.'}, result="Returns ''true'' if the element is low LOD, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='isLowLOD', field=None), url=FunctionUrl(url='/wiki/IsElementLowLOD', name='isElementLowLOD', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isElementOnScreen', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will check if an element is on the screen. Elements behind objects but still in the camera view count as being on screen.\nThis function is particularly useful for detecting if dynamic objects are in "destroyed" state. Destroyed objects will return false.', arguments={'theElement': 'The element of which you wish to check wether its being rendered on screen.'}, result="Returns ''true'' if element is on screen, ''false'' if not."), oop=FunctionOOP(class_name='element', method_name='isOnScreen', field="onScreen}}}}\n\n===Required Arguments===\n*'''theElement:''' The element of which you wish to check wether it's being rendered on screen.\n===Returns===\nReturns ''true'' if element is on screen, ''false'' if not.\n==Issues==\n{{Issues"), url=FunctionUrl(url='/wiki/IsElementOnScreen', name='isElementOnScreen', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isElementStreamable', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks whether an [[element]] is streamable as set by [[setElementStreamable]] or not.', arguments={'theElement': ': The element to check the streamability of.'}, result="Returns ''true'' if the passed element is streamable like normal, ''false'' if this element must always be streamed in."), oop=FunctionOOP(class_name='element', method_name='isStreamable', field='streamable'), url=FunctionUrl(url='/wiki/IsElementStreamable', name='isElementStreamable', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isElementStreamedIn', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks whether an [[element]] is currently streamed in (not virtualized) and are actual GTA objects in the world. You can force an element to be streamed in using [[setElementStreamable]].<br>\nDP2 can return true even if this element is not fully streamed in. This can happen during the period when the vehicle/object model is loading while the element is not actually fully created yet.\n}}', arguments={'theElement': ': The element to check whether is streamed in or not.'}, result="Returns ''true'' if the passed element is currently streamed in, ''false'' if it is virtualized."), oop=None, url=FunctionUrl(url='/wiki/IsElementStreamedIn', name='isElementStreamedIn', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isElementSyncer', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks whether an [[element]] is synced by the local player or not. Accepted elements are [[ped|peds]] and [[vehicle|vehicles]].', arguments={'theElement': ': The element to check.'}, result="Returns ''true'' if the passed element is synced by the local player, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='isSyncer', field="syncedByLocalPlayer}}}}\n\n===Required Arguments===\n* '''theElement''': The [[element]] to check.\n\n===Returns===\nReturns ''true'' if the passed element is synced by the local player, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/IsElementSyncer', name='isElementSyncer', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isElementWaitingForGroundToLoad', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theElement': 'the element to check its frozen waiting for custom map objects to load status. It can be a vehicle, ped or player.'}, result="Returns ''true'' if the specified [[element]] is frozen waiting for collisions of custom map objects to load. Returns ''false'' if it's not or if the specified [[element]] is invalid."), oop=FunctionOOP(class_name='element', method_name='isWaitingForGroundToLoad', field="waitingForGroundToLoad}}}}\n\n===Required arguments===\n* '''theElement:''' the element to check its frozen waiting for custom map objects to load status. It can be a [[vehicle]], [[ped]] or [[player]].\n\n===Returns===\nReturns ''true'' if the specified [[element]] is frozen waiting for collisions of custom map objects to load. Returns ''false'' if it's not or if the specified [[element]] is invalid.\n\n"), url=FunctionUrl(url='/wiki/IsElementWaitingForGroundToLoad', name='isElementWaitingForGroundToLoad', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isElementWithinColShape', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theShape', argument_type='colshape', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to determine if an element is within a collision shape. Please note that for legacy reasons, a colshape created on the client does not collide with elements already existing at that location until they first move. Please also note that before 1.0.3, this did not function correctly when moving a colshape.\nPlease note that this function doesn't verify whether element is in the same dimension and interior, additional checks could be implemented manually if they are needed.", arguments={'theElement': 'The element youre checking.', 'theShape': 'The colshape youre checking'}, result="Returns ''true'' if the element is within the colshape, ''false'' otherwise"), oop=None, url=FunctionUrl(url='/wiki/IsElementWithinColShape', name='isElementWithinColShape', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isElementWithinColShape', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theShape', argument_type='colshape', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to determine if an element is within a collision shape. Please note that for legacy reasons, a colshape created on the client does not collide with elements already existing at that location until they first move. Please also note that before 1.0.3, this did not function correctly when moving a colshape.\nPlease note that this function doesn't verify whether element is in the same dimension and interior, additional checks could be implemented manually if they are needed.", arguments={'theElement': 'The element youre checking.', 'theShape': 'The colshape youre checking'}, result="Returns ''true'' if the element is within the colshape, ''false'' otherwise"), oop=None, url=FunctionUrl(url='/wiki/IsElementWithinColShape', name='isElementWithinColShape', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementAlpha', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='alpha', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='[[file:SetElementAlpha.png|400px|thumb|right|Player ped alpha demonstration. Shown alpha levels are 255, 100 and 0 (left to right).]]\nThis function sets the alpha (transparency) value for the specified [[element]]. This can be a [[player]], [[ped]], [[object]], [[vehicle]] or [[Element/Weapon|weapon]].', arguments={'theElement': 'The element whose alpha you want to set.', 'alpha': 'The alpha value to set. Values are 0-255, where 255 is fully opaque and 0 is fully transparent.', 'Note': 'Objects are fully transparent at 140.'}, result="Returns ''true'' or ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='element', method_name='setAlpha', field='alpha'), url=FunctionUrl(url='/wiki/SetElementAlpha', name='setElementAlpha', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementAlpha', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='alpha', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='[[file:SetElementAlpha.png|400px|thumb|right|Player ped alpha demonstration. Shown alpha levels are 255, 100 and 0 (left to right).]]\nThis function sets the alpha (transparency) value for the specified [[element]]. This can be a [[player]], [[ped]], [[object]], [[vehicle]] or [[Element/Weapon|weapon]].', arguments={'theElement': 'The element whose alpha you want to set.', 'alpha': 'The alpha value to set. Values are 0-255, where 255 is fully opaque and 0 is fully transparent.', 'Note': 'Objects are fully transparent at 140.'}, result="Returns ''true'' or ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='element', method_name='setAlpha', field='alpha'), url=FunctionUrl(url='/wiki/SetElementAlpha', name='setElementAlpha', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementAngularVelocity', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rx', argument_type='float', default_value=None, optional=False), FunctionArgument(name='ry', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rz', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theElement': 'The element to apply the spin to. Can be either a player, ped, object, vehicle or a Element/Weapon|custom weapon.', 'rx': 'velocity around the X axis', 'ry': 'velocity around the Y axis', 'rz': 'velocity around the Z axis'}, result="Returns ''true'' if it was succesful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setAngularVelocity', field='angularVelocity'), url=FunctionUrl(url='/wiki/SetElementAngularVelocity', name='setElementAngularVelocity', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementAngularVelocity', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rx', argument_type='float', default_value=None, optional=False), FunctionArgument(name='ry', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rz', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theElement': 'The element to apply the spin to. Can be either a player, ped, object, vehicle or a Element/Weapon|custom weapon.', 'rx': 'velocity around the X axis', 'ry': 'velocity around the Y axis', 'rz': 'velocity around the Z axis'}, result="Returns ''true'' if it was succesful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setAngularVelocity', field='angularVelocity'), url=FunctionUrl(url='/wiki/SetElementAngularVelocity', name='setElementAngularVelocity', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getElementAngularVelocity', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theElement': 'The element to retrieve the angular velocity from. Can be either a player, ped, object, vehicle or a Element/Weapon|custom weapon. Server side supports only vehicles currently.'}, result='Returns three floats describing the x, y and z rotation'), oop=FunctionOOP(class_name='element', method_name='getAngularVelocity', field='angularVelocity'), url=FunctionUrl(url='/wiki/GetElementAngularVelocity', name='getElementAngularVelocity', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getElementAngularVelocity', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theElement': 'The element to retrieve the angular velocity from. Can be either a player, ped, object, vehicle or a Element/Weapon|custom weapon. Server side supports only vehicles currently.'}, result='Returns three floats describing the x, y and z rotation'), oop=FunctionOOP(class_name='element', method_name='getAngularVelocity', field='angularVelocity'), url=FunctionUrl(url='/wiki/GetElementAngularVelocity', name='getElementAngularVelocity', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementAttachedOffsets', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='xPosOffset', argument_type='float', default_value=None, optional=False), FunctionArgument(name='yPosOffset', argument_type='float', default_value=None, optional=False), FunctionArgument(name='zPosOffset', argument_type='float', default_value=None, optional=False), FunctionArgument(name='xRotOffset', argument_type='float', default_value=None, optional=False), FunctionArgument(name='yRotOffset', argument_type='float', default_value=None, optional=False), FunctionArgument(name='zRotOffset', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function updates the offsets of an element that has been attached to another element using [[attachElements]].', arguments={'theElement': 'The attached element.\n{{OptionalArg}} ', 'xPosOffset': 'The x offset, if you want the elements to be a certain distance from one another (default 0).', 'yPosOffset': 'The y offset (default 0).', 'zPosOffset': 'The z offset (default 0).', 'xRotOffset': 'The x rotation offset (default 0).', 'yRotOffset': 'The y rotation offset (default 0).', 'zRotOffset': 'The z rotation offset (default 0).'}, result="Returns ''true'' if the attaching process was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setAttachedOffsets', field=None), url=FunctionUrl(url='/wiki/SetElementAttachedOffsets', name='setElementAttachedOffsets', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementAttachedOffsets', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='xPosOffset', argument_type='float', default_value=None, optional=False), FunctionArgument(name='yPosOffset', argument_type='float', default_value=None, optional=False), FunctionArgument(name='zPosOffset', argument_type='float', default_value=None, optional=False), FunctionArgument(name='xRotOffset', argument_type='float', default_value=None, optional=False), FunctionArgument(name='yRotOffset', argument_type='float', default_value=None, optional=False), FunctionArgument(name='zRotOffset', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function updates the offsets of an element that has been attached to another element using [[attachElements]].', arguments={'theElement': 'The attached element.\n{{OptionalArg}} ', 'xPosOffset': 'The x offset, if you want the elements to be a certain distance from one another (default 0).', 'yPosOffset': 'The y offset (default 0).', 'zPosOffset': 'The z offset (default 0).', 'xRotOffset': 'The x rotation offset (default 0).', 'yRotOffset': 'The y rotation offset (default 0).', 'zRotOffset': 'The z rotation offset (default 0).'}, result="Returns ''true'' if the attaching process was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setAttachedOffsets', field=None), url=FunctionUrl(url='/wiki/SetElementAttachedOffsets', name='setElementAttachedOffsets', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setElementBoneMatrix', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='bone', argument_type='int', default_value=None, optional=False), FunctionArgument(name='matrix', argument_type='matrix', default_value=None, optional=False)]), docs=FunctionDoc(description='* [[Element/Player|Player]]\n* [[Element/Ped|Ped]]\n}}', arguments={'theElement': 'the element to set the bone matrix on.', 'bone': 'the ID of the bone. See Bone IDs', 'matrix': 'the MTA matrix to set.'}, result="Returns ''true'' if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetElementBoneMatrix', name='setElementBoneMatrix', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setElementBonePosition', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='bone', argument_type='int', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='* [[Element/Player|Player]]\n* [[Element/Ped|Ped]]\n}}', arguments={'theElement': 'the element to set the bone position on.', 'bone': 'the ID of the bone to set the position of. See Bone IDs', 'x': 'The x coordinate of the destination.', 'y': 'The y coordinate of the destination.', 'z': 'The z coordinate of the destination.'}, result="Returns ''true'' if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetElementBonePosition', name='setElementBonePosition', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setElementBoneRotation', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='bone', argument_type='int', default_value=None, optional=False), FunctionArgument(name='yaw', argument_type='float', default_value=None, optional=False), FunctionArgument(name='pitch', argument_type='float', default_value=None, optional=False), FunctionArgument(name='roll', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='* [[Element/Player|Player]]\n* [[Element/Ped|Ped]]\n}}', arguments={'theElement': 'the element to set the bone rotation on.', 'bone': 'the ID of the bone to set the rotation of. See Bone IDs', 'yaw': 'the yaw rotation value.', 'pitch': 'the pitch rotation value.', 'roll': 'the roll rotation value.'}, result="Returns ''true'' if the function was successful, ''false'' otherwise.\n'''Note:''' [[updateElementRpHAnim]] must be called after this function to apply bone rotation."), oop=None, url=FunctionUrl(url='/wiki/SetElementBoneRotation', name='setElementBoneRotation', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setElementCallPropagationEnabled', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function enables/disables call propagation on a certain element. Look at the example for a practical application.', arguments={'theElement': 'The element whose propagation behaviour youd like to change', 'enabled': 'Whether propagation should be enabled or not'}, result="Returns ''true'', if the propagation behaviour has been changed successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setCallPropagationEnabled', field=None), url=FunctionUrl(url='/wiki/SetElementCallPropagationEnabled', name='setElementCallPropagationEnabled', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setElementCollidableWith', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='withElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function can be used to set an element to collide with another element. An element with collisions disabled does not interact physically with the other element.<br>\n'''Note:''' You can only use this function with the element types listed below.\n*[[Player]]\n*[[Ped]]\n*[[Vehicle]]\n*[[Object]]", arguments={'theElement': 'The element which colliding you want to change', 'withElement': 'The other element you wish the first entity to collide with', 'enabled': 'A boolean to indicate whether elements should be able to collide with eachother (true) or not (false)'}, result="Returns ''true'' if the collisions were set succesfully, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setCollidableWith', field=None), url=FunctionUrl(url='/wiki/SetElementCollidableWith', name='setElementCollidableWith', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementCollisionsEnabled', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function can disable or enable an element's collisions. An element without collisions does not interact with the physical environment and remains static.", arguments={'theElement': 'The element you wish to set the collisions of', 'enabled': 'A boolean to indicate whether collisions are enabled (true) or disabled (false)'}, result="Returns ''true'' if the collisions were set succesfully, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setCollisionsEnabled', field='collisions'), url=FunctionUrl(url='/wiki/SetElementCollisionsEnabled', name='setElementCollisionsEnabled', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementCollisionsEnabled', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function can disable or enable an element's collisions. An element without collisions does not interact with the physical environment and remains static.", arguments={'theElement': 'The element you wish to set the collisions of', 'enabled': 'A boolean to indicate whether collisions are enabled (true) or disabled (false)'}, result="Returns ''true'' if the collisions were set succesfully, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setCollisionsEnabled', field='collisions'), url=FunctionUrl(url='/wiki/SetElementCollisionsEnabled', name='setElementCollisionsEnabled', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementData', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='var', default_value=None, optional=False), FunctionArgument(name='syncMode', argument_type='var', default_value='"broadcast"', optional=True)]), docs=FunctionDoc(description="This function stores [[element data]] under a certain key, attached to an element. Element data set using this is then synced with all clients and the server. The data can contain server created elements, but you should avoid passing data that is not able to be synced such as xmlnodes, acls, aclgroups etc.\nAs element data is synced to all clients, it can generate a lot of network traffic and be heavy on performance. Events are much more efficient for sending data from a client to the server only, or from the server to a specific client. <br/>\nUsage of element data should be disencouraged where your goal can be achieved with events like above, and [[table|tables]] for storing and retrieving data.\nNote this mode only works when setting element data serverside. Setting data clientside still sends the update to all clients if 'synchronize' is set to true.\n}}", arguments={'theElement': 'The element you wish to attach the data to.', 'key': 'The key you wish to store the data under. (Maximum 31 characters.)', 'value': 'The value you wish to store. See element data for a list of acceptable datatypes.', 'syncMode': 'Synchronisation mode.', '"broadcast"': '- Synchronise to all clients (default behavior). You can also parse true for this option.', '"local"': '- Dont synchronise. You can also parse false for this option.', '"subscribe"': '- Only synchronise to specific clients. See addElementDataSubscriber and removeElementDataSubscriber.'}, result="Returns ''true'' if the data was set succesfully, ''false'' otherwise.\n{{New items|5.0157|1.5.7-9.20477|"), oop=FunctionOOP(class_name='element', method_name='setData', field=None), url=FunctionUrl(url='/wiki/SetElementData', name='setElementData', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementData', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='var', default_value=None, optional=False), FunctionArgument(name='synchronize', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description="This function stores [[element data]] under a certain key, attached to an element. Element data set using this is then synced with all clients and the server. The data can contain server created elements, but you should avoid passing data that is not able to be synced such as xmlnodes, acls, aclgroups etc.\nAs element data is synced to all clients, it can generate a lot of network traffic and be heavy on performance. Events are much more efficient for sending data from a client to the server only, or from the server to a specific client. <br/>\nUsage of element data should be disencouraged where your goal can be achieved with events like above, and [[table|tables]] for storing and retrieving data.\nNote this mode only works when setting element data serverside. Setting data clientside still sends the update to all clients if 'synchronize' is set to true.\n}}", arguments={'theElement': 'The element you wish to attach the data to.', 'key': 'The key you wish to store the data under. (Maximum 31 characters.)', 'value': 'The value you wish to store. See element data for a list of acceptable datatypes.', 'synchronize': 'Determines whether or not the data will be synchronized with the server.'}, result="Returns ''true'' if the data was set succesfully, ''false'' otherwise.\n{{New items|5.0157|1.5.7-9.20477|"), oop=FunctionOOP(class_name='element', method_name='setData', field=None), url=FunctionUrl(url='/wiki/SetElementData', name='setElementData', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementDimension', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='dimension', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to set the [[dimension]] of any element. The dimension determines what/who the element is visible to.', arguments={'theElement': 'The element in which youd like to set the dimension of.', 'dimension': 'An integer representing the dimension ID. {{New feature/item|3.0154|1.5.3|11199|You can also use -1 to make the element visible in all dimensions (only valid to objects).}} Valid values are 0 to 65535.'}, result="Returns ''true'' if '''theElement''' and '''dimension''' are valid, ''false'' otherwise.\nAlso returns false if '''theElement''' is a player and it's not alive."), oop=FunctionOOP(class_name='element', method_name='setDimension', field='dimension'), url=FunctionUrl(url='/wiki/SetElementDimension', name='setElementDimension', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementDimension', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='dimension', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to set the [[dimension]] of any element. The dimension determines what/who the element is visible to.', arguments={'theElement': 'The element in which youd like to set the dimension of.', 'dimension': 'An integer representing the dimension ID. {{New feature/item|3.0154|1.5.3|11199|You can also use -1 to make the element visible in all dimensions (only valid to objects).}} Valid values are 0 to 65535.'}, result="Returns ''true'' if '''theElement''' and '''dimension''' are valid, ''false'' otherwise.\nAlso returns false if '''theElement''' is a player and it's not alive."), oop=FunctionOOP(class_name='element', method_name='setDimension', field='dimension'), url=FunctionUrl(url='/wiki/SetElementDimension', name='setElementDimension', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementDoubleSided', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='enable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows you to set the double-sidedness of an element's model. When an element's model is double-sided, it's back facing triangles become visible.\nPossible uses of double-sidedness are: Elimination of invisible walls, using buildings as enclosures, using inverted landmasses as large pits or to make cave networks. It can also remove the need to add extra triangles to custom models when trying to make them appear solid from all directions.", arguments={'theElement': 'The element in which youd like to set the double-sidedness of.', 'enable ': 'Set to true/false to enable/disable double-sidedness.'}, result="Returns ''true'' if '''theElement''' is valid, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setDoubleSided', field='doubleSided'), url=FunctionUrl(url='/wiki/SetElementDoubleSided', name='setElementDoubleSided', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementDoubleSided', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='enable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows you to set the double-sidedness of an element's model. When an element's model is double-sided, it's back facing triangles become visible.\nPossible uses of double-sidedness are: Elimination of invisible walls, using buildings as enclosures, using inverted landmasses as large pits or to make cave networks. It can also remove the need to add extra triangles to custom models when trying to make them appear solid from all directions.", arguments={'theElement': 'The element in which youd like to set the double-sidedness of.', 'enable ': 'Set to true/false to enable/disable double-sidedness.'}, result="Returns ''true'' if '''theElement''' is valid, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setDoubleSided', field='doubleSided'), url=FunctionUrl(url='/wiki/SetElementDoubleSided', name='setElementDoubleSided', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementFrozen', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='freezeStatus', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function freezes an element (stops it in its position and disables movement) or unfreezes it.', arguments={'theElement': 'The element whose freeze status we want to change.', 'freezeStatus': 'A boolean denoting whether we want to freeze (true) or unfreeze (false) it.'}, result="Returns ''true'' if the element was frozen, ''false'' if it wasn't or if invalid arguments are passed."), oop=FunctionOOP(class_name='element', method_name='setFrozen', field='frozen'), url=FunctionUrl(url='/wiki/SetElementFrozen', name='setElementFrozen', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementFrozen', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='freezeStatus', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function freezes an element (stops it in its position and disables movement) or unfreezes it.', arguments={'theElement': 'The element whose freeze status we want to change.', 'freezeStatus': 'A boolean denoting whether we want to freeze (true) or unfreeze (false) it.'}, result="Returns ''true'' if the element was frozen, ''false'' if it wasn't or if invalid arguments are passed."), oop=FunctionOOP(class_name='element', method_name='setFrozen', field='frozen'), url=FunctionUrl(url='/wiki/SetElementFrozen', name='setElementFrozen', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementHealth', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='newHealth', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the health for the specified [[element]]. This can be a [[ped]], [[object]] or a [[vehicle]].\n*'''650:''' white steam 0%, black smoke 0%\n*'''450:''' white steam 100%, black smoke 50%\n*'''250:''' white steam 0%, black smoke 100%\n*'''249:''' fire with big black smoke\n}}", arguments={'theElement': 'The ped, vehicle or object whose health you want to set.', 'newHealth': 'A float indicating the new health to set for the element.'}, result="Returns ''true'' if the new health was set successfully, or ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='element', method_name='setHealth', field='health'), url=FunctionUrl(url='/wiki/SetElementHealth', name='setElementHealth', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementHealth', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='newHealth', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the health for the specified [[element]]. This can be a [[ped]], [[object]] or a [[vehicle]].\n*'''650:''' white steam 0%, black smoke 0%\n*'''450:''' white steam 100%, black smoke 50%\n*'''250:''' white steam 0%, black smoke 100%\n*'''249:''' fire with big black smoke\n}}", arguments={'theElement': 'The ped, vehicle or object whose health you want to set.', 'newHealth': 'A float indicating the new health to set for the element.'}, result="Returns ''true'' if the new health was set successfully, or ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='element', method_name='setHealth', field='health'), url=FunctionUrl(url='/wiki/SetElementHealth', name='setElementHealth', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementID', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='name', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the ID of an element to a string. This can be anything from an identifying number, to a name.\nYou can only change the ID of an element clientside if that element has been created clientside as well.', arguments={'theElement': 'The element you want to set the ID of.', 'name': 'The new ID for theElement.'}, result="This returns ''true'' if successful. It will return ''false'' if '''theElement''' is invalid, or does not exist, or if '''name''' is invalid, or is not a string."), oop=FunctionOOP(class_name='element', method_name='setID', field='id'), url=FunctionUrl(url='/wiki/SetElementID', name='setElementID', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementID', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='name', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the ID of an element to a string. This can be anything from an identifying number, to a name.\nYou can only change the ID of an element clientside if that element has been created clientside as well.', arguments={'theElement': 'The element you want to set the ID of.', 'name': 'The new ID for theElement.'}, result="This returns ''true'' if successful. It will return ''false'' if '''theElement''' is invalid, or does not exist, or if '''name''' is invalid, or is not a string."), oop=FunctionOOP(class_name='element', method_name='setID', field='id'), url=FunctionUrl(url='/wiki/SetElementID', name='setElementID', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementInterior', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='interior', argument_type='int', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=True), FunctionArgument(name='y', argument_type='float', default_value=None, optional=True), FunctionArgument(name='z', argument_type='float', default_value=None, optional=True)]), docs=FunctionDoc(description='This function allows you to set the [[interior]] of any element. An interior is the current loaded place, 0 being outside.', arguments={'theElement': 'The element in which youd like to set the interior of.', 'interior': 'The interior you want to set the element to. Valid values are 0 to 255.\n{{OptionalArg}} ', 'x': 'A floating point number representing the X coordinate on the map.', 'y': 'A floating point number representing the Y coordinate on the map.', 'z': 'A floating point number representing the Z coordinate on the map.'}, result="Returns ''true'' if '''theElement''' and '''interior''' are valid arguments, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setInterior', field='interior'), url=FunctionUrl(url='/wiki/SetElementInterior', name='setElementInterior', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementInterior', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='interior', argument_type='int', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=True), FunctionArgument(name='y', argument_type='float', default_value=None, optional=True), FunctionArgument(name='z', argument_type='float', default_value=None, optional=True)]), docs=FunctionDoc(description='This function allows you to set the [[interior]] of any element. An interior is the current loaded place, 0 being outside.', arguments={'theElement': 'The element in which youd like to set the interior of.', 'interior': 'The interior you want to set the element to. Valid values are 0 to 255.\n{{OptionalArg}} ', 'x': 'A floating point number representing the X coordinate on the map.', 'y': 'A floating point number representing the Y coordinate on the map.', 'z': 'A floating point number representing the Z coordinate on the map.'}, result="Returns ''true'' if '''theElement''' and '''interior''' are valid arguments, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setInterior', field='interior'), url=FunctionUrl(url='/wiki/SetElementInterior', name='setElementInterior', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementMatrix', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theMatrix', argument_type='table', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets matrix to element.', arguments={'theElement': 'The element which you set matrix', 'theMatrix': 'The matrix.'}, result="Returns ''true'' if the matrix was set succesfully, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setMatrix', field='matrix'), url=FunctionUrl(url='/wiki/SetElementMatrix', name='setElementMatrix', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementMatrix', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theMatrix', argument_type='table', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets matrix to element.', arguments={'theElement': 'The element which you set matrix', 'theMatrix': 'The matrix.'}, result="Returns ''true'' if the matrix was set succesfully, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setMatrix', field='matrix'), url=FunctionUrl(url='/wiki/SetElementMatrix', name='setElementMatrix', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementModel', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='model', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the model of a given element. This allows you to change the model of a player (or ped), a vehicle or an object.', arguments={'theElement': 'the element you want to change.', 'model': 'the model ID to set.\n** For players/peds: A GTASA player model (skin) ID. See [[Character Skins]].\n** For vehicles: The [[Vehicle IDs|vehicle ID]] of the vehicle being changed.\n** For objects/projectiles/weapons: An [[int]] specifying the model id.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setModel', field='model'), url=FunctionUrl(url='/wiki/SetElementModel', name='setElementModel', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementModel', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='model', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the model of a given element. This allows you to change the model of a player (or ped), a vehicle or an object.', arguments={'theElement': 'the element you want to change.', 'model': 'the model ID to set.\n** For players/peds: A GTASA player model (skin) ID. See [[Character Skins]].\n** For vehicles: The [[Vehicle IDs|vehicle ID]] of the vehicle being changed.\n** For objects/projectiles/weapons: An [[int]] specifying the model id.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setModel', field='model'), url=FunctionUrl(url='/wiki/SetElementModel', name='setElementModel', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementParent', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used for setting an element as the parent of another element.', arguments={'theElement': 'The element that you wish to set the parent of.', 'parent': 'The element you wish to be the parent of theElement.'}, result="Returns ''true'' if both [[element]]s are valid, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setParent', field='parent'), url=FunctionUrl(url='/wiki/SetElementParent', name='setElementParent', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementParent', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used for setting an element as the parent of another element.', arguments={'theElement': 'The element that you wish to set the parent of.', 'parent': 'The element you wish to be the parent of theElement.'}, result="Returns ''true'' if both [[element]]s are valid, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setParent', field='parent'), url=FunctionUrl(url='/wiki/SetElementParent', name='setElementParent', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementPosition', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='warp', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description='This function sets the position of an element to the specified coordinates.', arguments={'theElement': 'A valid element to be moved.', 'x': 'The x coordinate of the destination.', 'y': 'The y coordinate of the destination.', 'z': 'The z coordinate of the destination.', 'warp': 'teleports players, resetting any animations they were doing. Setting this to false preserves the current animation.'}, result="Returns ''true'' if the function was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setPosition', field='position'), url=FunctionUrl(url='/wiki/SetElementPosition', name='setElementPosition', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementPosition', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='warp', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description='This function sets the position of an element to the specified coordinates.', arguments={'theElement': 'A valid element to be moved.', 'x': 'The x coordinate of the destination.', 'y': 'The y coordinate of the destination.', 'z': 'The z coordinate of the destination.', 'warp': 'teleports players, resetting any animations they were doing. Setting this to false preserves the current animation.'}, result="Returns ''true'' if the function was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setPosition', field='position'), url=FunctionUrl(url='/wiki/SetElementPosition', name='setElementPosition', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementRotation', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rotX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rotY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rotZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rotOrder', argument_type='string', default_value='"default"', optional=True), FunctionArgument(name='conformPedRotation', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='Sets the rotation of elements according to the world (does not work with players that are on the ground).', arguments={'theElement': 'The element whose rotation will be set', 'rotX': 'The elements rotation around the x axis in degrees', 'rotY': 'The elements rotation around the y axis in degrees', 'rotZ': 'The elements rotation around the z axis in degrees\n{{New feature|3.0110|1.1|', 'rotOrder': 'A string representing the rotation order desired when interpreting the provided http://en.wikipedia.org/wiki/Euler_angles euler angles. If omitted, default value is default. Allowed values are:', '"default"': 'default MTA behavior prior to 1.1, where rotation order depends on element type', '"ZXY"': 'rotation about the Z axis (up), then about the resulting X axis (right), and finally about the resulting Y axis (front). This is the default rotation order for object|objects', '"ZYX"': 'rotation about the Z axis (up), then about the resulting Y axis (front), and finally about the resulting X axis (right). This is the default rotation order for vehicle|vehicles\nThe default rotation order for peds/players is -Z-Y-X but this rotation order (set using \'\'"default"\'\' on peds) can not be set manually on other element types since it only exists due to historical and backward compatibility reasons.\nSpecifying a rotation order other than \'\'"default"\'\' allows the same angles to be uniformly used on several elements without having to consider their type.\n}}\n{{New feature/item|3.0152|1.3.2|4680|', 'conformPedRotation': 'Relevant only for peds and will be ignored for other element types. A bool which should be set to true to ensure the ped rotation is correctly set in all circumstances. Failing to set this argument may result in the ped rotation being inverted whilst it is in the air and other inconsistencies. The default value of false is for backward compatibility with scripts which may depend upon the incorrect behaviour.\n}}'}, result="Returns ''true'' if the element rotation was successfully set and ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setRotation', field='rotation'), url=FunctionUrl(url='/wiki/SetElementRotation', name='setElementRotation', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementRotation', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rotX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rotY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rotZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rotOrder', argument_type='string', default_value='"default"', optional=True), FunctionArgument(name='conformPedRotation', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='Sets the rotation of elements according to the world (does not work with players that are on the ground).', arguments={'theElement': 'The element whose rotation will be set', 'rotX': 'The elements rotation around the x axis in degrees', 'rotY': 'The elements rotation around the y axis in degrees', 'rotZ': 'The elements rotation around the z axis in degrees\n{{New feature|3.0110|1.1|', 'rotOrder': 'A string representing the rotation order desired when interpreting the provided http://en.wikipedia.org/wiki/Euler_angles euler angles. If omitted, default value is default. Allowed values are:', '"default"': 'default MTA behavior prior to 1.1, where rotation order depends on element type', '"ZXY"': 'rotation about the Z axis (up), then about the resulting X axis (right), and finally about the resulting Y axis (front). This is the default rotation order for object|objects', '"ZYX"': 'rotation about the Z axis (up), then about the resulting Y axis (front), and finally about the resulting X axis (right). This is the default rotation order for vehicle|vehicles\nThe default rotation order for peds/players is -Z-Y-X but this rotation order (set using \'\'"default"\'\' on peds) can not be set manually on other element types since it only exists due to historical and backward compatibility reasons.\nSpecifying a rotation order other than \'\'"default"\'\' allows the same angles to be uniformly used on several elements without having to consider their type.\n}}\n{{New feature/item|3.0152|1.3.2|4680|', 'conformPedRotation': 'Relevant only for peds and will be ignored for other element types. A bool which should be set to true to ensure the ped rotation is correctly set in all circumstances. Failing to set this argument may result in the ped rotation being inverted whilst it is in the air and other inconsistencies. The default value of false is for backward compatibility with scripts which may depend upon the incorrect behaviour.\n}}'}, result="Returns ''true'' if the element rotation was successfully set and ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setRotation', field='rotation'), url=FunctionUrl(url='/wiki/SetElementRotation', name='setElementRotation', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setElementStreamable', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='streamable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function can be used to disable streaming for an element. This will make sure the element is not virtualized (streamed out from GTA) when the player moves far away from it. This function only works in elements with a physical representation in the world (entities), such as [[player|players]], [[ped|peds]], [[vehicle|vehicles]] and [[object|objects]].\n* There is a limit of elements that can be streamed in safely for every GTA entity type. If you bypass said limit by using this function, the client can experience problems of disappearing objects and unstability when trying to stream in new elements of that type.\n* In general, if you disable too many elements (of the same type or not) to stream out, GTA will always try to render them, so it can cause a noticeable FPS drop.}}', arguments={'theElement': 'The element you wish to set the streaming of', 'streamable': 'true if this element should stream in/out like normal, false if it should always be streamed in.'}, result='Returns whether the element could be set to be streamable.'), oop=FunctionOOP(class_name='element', method_name='setStreamable', field='streamable'), url=FunctionUrl(url='/wiki/SetElementStreamable', name='setElementStreamable', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setElementVelocity', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='speedX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='speedY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='speedZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the velocity (movement speeds) along each axis, for an element.\nThis is not compatible with all elements. Only the following elements are compatible:\n* [[Ped]]s.\n* [[Vehicle]]s.\n* [[Object]]s.\n* [[Projectile]]s.\nObjects and projectiles velocity can only be set clientside.}}', arguments={'theElement': 'The element you wish to set the velocity of.', 'speedX': 'A floating point value determining the speed along the X axis.', 'speedY': 'A floating point value determining the speed along the Y axis.', 'speedZ': 'A floating point value determining the speed along the Z axis.'}, result="Returns ''true'' if the speed was set successfully, ''false'' if a bad element was specified or other bad arguments."), oop=FunctionOOP(class_name='element', method_name='setVelocity', field='velocity'), url=FunctionUrl(url='/wiki/SetElementVelocity', name='setElementVelocity', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setElementVelocity', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='speedX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='speedY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='speedZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the velocity (movement speeds) along each axis, for an element.\nThis is not compatible with all elements. Only the following elements are compatible:\n* [[Ped]]s.\n* [[Vehicle]]s.\n* [[Object]]s.\n* [[Projectile]]s.\nObjects and projectiles velocity can only be set clientside.}}', arguments={'theElement': 'The element you wish to set the velocity of.', 'speedX': 'A floating point value determining the speed along the X axis.', 'speedY': 'A floating point value determining the speed along the Y axis.', 'speedZ': 'A floating point value determining the speed along the Z axis.'}, result="Returns ''true'' if the speed was set successfully, ''false'' if a bad element was specified or other bad arguments."), oop=FunctionOOP(class_name='element', method_name='setVelocity', field='velocity'), url=FunctionUrl(url='/wiki/SetElementVelocity', name='setElementVelocity', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setLowLODElement', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='lowLODElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function assigns a low LOD element to an element. The low LOD element is displayed when its associated element is not fully visible. If a low LOD element is assigned to several elements, it will be displayed when any of these elements are not fully visible.', arguments={'theElement': 'The element whose low LOD version we want to change.', 'lowLODElement ': 'A low LOD element to display when the first element is not fully visible.'}, result="Returns ''true'' if the assignment was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setLowLOD', field='lowLOD'), url=FunctionUrl(url='/wiki/SetLowLODElement', name='setLowLODElement', category='Element functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setLowLODElement', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='lowLODElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function assigns a low LOD element to an element. The low LOD element is displayed when its associated element is not fully visible. If a low LOD element is assigned to several elements, it will be displayed when any of these elements are not fully visible.', arguments={'theElement': 'The element whose low LOD version we want to change.', 'lowLODElement ': 'A low LOD element to display when the first element is not fully visible.'}, result="Returns ''true'' if the assignment was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='element', method_name='setLowLOD', field='lowLOD'), url=FunctionUrl(url='/wiki/SetLowLODElement', name='setLowLODElement', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='updateElementRpHAnim', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='* [[Element/Player|Player]]\n* [[Element/Ped|Ped]]\nThis function must be called after [[setElementBoneRotation]] for changes to take effect. It should only be called once per frame, after you are done rotating bones on that element, as it is quite heavy.\n}}', arguments={'theElement': 'the element to update.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/UpdateElementRpHAnim', name='updateElementRpHAnim', category='Element functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineApplyShaderToWorldTexture', return_types=['bool'], arguments=[FunctionArgument(name='shader', argument_type='element', default_value=None, optional=False), FunctionArgument(name='textureName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='targetElement', argument_type='element', default_value='nil', optional=True), FunctionArgument(name='appendLayers', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description='This function applies a [[shader]] to one or more world textures.\n* The resource [[Shader_examples#Texture_names|shader_tex_names]] can help in finding the names of world textures.\n* When replacing the texture for a ped using the CJ skin, set \'\'\'textureName\'\'\' to "CJ"\n* The shader inherits the render states of the original when it is drawn, so texture stage 0 will already be set to the original texture.\n* When using with a \'ped\', ensure you have set \'ped\' or \'all\' in the elementTypes when calling [[dxCreateShader]]\n* CJ body parts textures can be replaced by using: "cj_ped_head", "cj_ped_hat", "cj_ped_torso", "cj_ped_legs", "cj_ped_feet", "cj_ped_glasses", "cj_ped_necklace", "cj_ped_watch" and "cj_ped_extra1". Latest version of [http://wiki.multitheftauto.com/wiki/Shader_examples#Texture_names shader_tex_names] will show what is being used.\n}}', arguments={'shader': 'The shader which is to be applied', 'textureName': 'The name of the world texture to apply the shader to. Wildcard matching e.g. ro?ds* can be used to apply to more than one texture at a time.\n{{New feature/item|3.0130|1.3.0|4140|', 'targetElement': 'The element to restrict applying the shader to. If this is not set the shader will be applied to everything using the texture name. Valid element types for targetElement are vehicle|vehicles, Object|objects and Ped|peds.\n}}', 'appendLayers': 'allows two or more layered shaders to be applied in the same texture. You may want to modify the DepthBias in the technique pass to avoid Z-fighting artifacts when using this.'}, result="Returns ''true'' if the shader was successfully applied, ''false'' otherwise."), oop=FunctionOOP(class_name='shader', method_name='applyToWorldTexture}}}}\n\n===Required Arguments=== \n*\'\'\'shader:\'\'\' The shader which is to be applied\n*\'\'\'textureName:\'\'\' The name of the world texture to apply the shader to. Wildcard matching e.g. "ro?ds*" can be used to apply to more than one texture at a time.\n\n===Optional Arguments=== \n{{New feature/item', field='3.0130'), url=FunctionUrl(url='/wiki/EngineApplyShaderToWorldTexture', name='engineApplyShaderToWorldTexture', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineGetModelIDFromName', return_types=['int'], arguments=[FunctionArgument(name='modelName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the model ID of an object model from object name. This function is the counterpart of [[engineGetModelNameFromID]].', arguments={'modelName': 'The model name of the object'}, result="Returns an ''int'' with the ID of the object model, false otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineGetModelIDFromName', name='engineGetModelIDFromName', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineGetModelLODDistance', return_types=['float'], arguments=[FunctionArgument(name='model', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the LOD distance for any object / model ID.', arguments={'model': 'The model / object ID number you want to get the LOD distance of.'}, result="Returns a float representing the LOD distance of the model, or ''false'' if the model argument is incorrect."), oop=None, url=FunctionUrl(url='/wiki/EngineGetModelLODDistance', name='engineGetModelLODDistance', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineGetModelNameFromID', return_types=['string'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the model name of an object model from model ID. This function is the counterpart of [[engineGetModelIDFromName]].', arguments={'modelID': 'The model ID of the object'}, result="Returns a ''string'' with the name of the object model, false otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineGetModelNameFromID', name='engineGetModelNameFromID', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineGetModelPhysicalPropertiesGroup', return_types=['int'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'modelID': ': the id of model which you wish to get physical properties group of.'}, result="Returns '''id''' of physical properties group that requested model uses, in range of ''0-160'', if the object doesn't have a group assigned, ''-1'' is returned. If passed arguments were wrong, error is triggered."), oop=None, url=FunctionUrl(url='/wiki/EngineGetModelPhysicalPropertiesGroup', name='engineGetModelPhysicalPropertiesGroup', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineRestoreModelPhysicalPropertiesGroup', return_types=['bool'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'modelID': ': the id of model which you wish to restore original physical properties group of.'}, result="Returns '''true''' if there were no issues, if passed arguments were invalid an error is raised."), oop=None, url=FunctionUrl(url='/wiki/EngineRestoreModelPhysicalPropertiesGroup', name='engineRestoreModelPhysicalPropertiesGroup', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineSetModelPhysicalPropertiesGroup', return_types=['bool'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='groupID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'modelID': ': the id of model which you wish to set physical properties group of.', 'groupID': ': the id of new physical properties group to be used by given model.'}, result="Returns '''true''' if there were no issues with group change, otherwise an error is raised"), oop=None, url=FunctionUrl(url='/wiki/EngineSetModelPhysicalPropertiesGroup', name='engineSetModelPhysicalPropertiesGroup', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineGetObjectGroupPhysicalProperty', return_types=['var'], arguments=[FunctionArgument(name='groupID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='modifiable', argument_type='objectgroup', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'groupID': ': the id of physical properties group which you wish to get a property from.', 'objectgroup-modifiable': ': the property which you wish to get, as per table below.'}, result='Returns the value contained in given property if everything went well, error is raised otherwise.'), oop=None, url=FunctionUrl(url='/wiki/EngineGetObjectGroupPhysicalProperty', name='engineGetObjectGroupPhysicalProperty', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineRestoreObjectGroupPhysicalProperties', return_types=['bool'], arguments=[FunctionArgument(name='groupID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='modifiable', argument_type='objectgroup', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'groupID': ': the id of physical properties group which you wish to restore a property of.', 'objectgroup-modifiable': ': the property which you wish to restore, as per table below.'}, result="Returns '''true''' if everything went well, error is raised otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineRestoreObjectGroupPhysicalProperties', name='engineRestoreObjectGroupPhysicalProperties', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineSetObjectGroupPhysicalProperty', return_types=['bool'], arguments=[FunctionArgument(name='groupID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='modifiable', argument_type='objectgroup', default_value=None, optional=False), FunctionArgument(name='newValue', argument_type='var', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'groupID': ': the id of physical properties group which you wish to set a property of.', 'objectgroup-modifiable': ': the property which you wish to set, as per table below.', 'newValue': ': new value of the property, with proper type as specified in table below'}, result="Returns '''true''' if everything went well, error is raised otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineSetObjectGroupPhysicalProperty', name='engineSetObjectGroupPhysicalProperty', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineRequestModel', return_types=['int'], arguments=[FunctionArgument(name='elementType', argument_type='str', default_value=None, optional=False), FunctionArgument(name='parentID', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='*before release 1.5.8-20716 this must be "ped".\n}}', arguments={'elementType': ': ped, vehicle and object.', 'parentID': ': The Vehicle IDs|vehicle ID of the vehicle being allocated. (By default this is: 1337 - objects, 400 - vehicles, 7 or PSYCHO for peds)'}, result="{{New feature/item|3.0158|1.5.7|20147| Returns an ''integer'' of the model ID that was available to be assigned to the element type, ''false'' if no free model ID available or invalid element type.}}\nDo not rely on the model numbers returned being consistent across multiple clients or multiple runs of resources. There is no guarantee for the order of the numbers or that the same numbers will always correspond to the same element type. Any patterns are coincidental"), oop=None, url=FunctionUrl(url='/wiki/EngineRequestModel', name='engineRequestModel', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineFreeModel', return_types=['bool'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'modelID': ': the model ID you want to have un-assigned.'}, result="Returns ''true'' if the model was successfully freed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineFreeModel', name='engineFreeModel', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineGetModelTextures', return_types=['table'], arguments=[FunctionArgument(name='int', argument_type='string', default_value=None, optional=False), FunctionArgument(name='table', argument_type='string', default_value=None, optional=True)]), docs=FunctionDoc(description='', arguments={'model': ': either the model ID or model name.', 'textureNames': ': Only return textures with specified name(s). You can provide a single string or a table of strings. Wildcard matching e.g. ro?ds* can be used.'}, result="Returns a table of texture elements [textureName, texture], '''false''' otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineGetModelTextures', name='engineGetModelTextures', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineGetModelTextureNames', return_types=['table'], arguments=[FunctionArgument(name='modelId', argument_type='string', default_value='""', optional=False)]), docs=FunctionDoc(description='This function returns a table of the world textures which are applied to the specified model.', arguments={'modelId ': 'You can either use the model id or the model name.'}, result='Returns a table if this function succeeds, false if it fails for some reason.'), oop=None, url=FunctionUrl(url='/wiki/EngineGetModelTextureNames', name='engineGetModelTextureNames', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineGetVisibleTextureNames', return_types=['table'], arguments=[FunctionArgument(name='nameFilter', argument_type='string', default_value='"*"', optional=False), FunctionArgument(name='modelId', argument_type='string', default_value='""', optional=False)]), docs=FunctionDoc(description='This function returns a list of the world textures which are being used to draw the current scene.', arguments={'nameFilter': 'Only include textures that match the wildcard string.', 'modelId ': 'Only include textures that are used by the model id (or model name)'}, result='Returns a table of texture names.'), oop=None, url=FunctionUrl(url='/wiki/EngineGetVisibleTextureNames', name='engineGetVisibleTextureNames', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineGetModelVisibleTime', return_types=['int,', 'int'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'modelID': ': ID of the model'}, result="Returns '''timeOn''', '''timeOff'''"), oop=None, url=FunctionUrl(url='/wiki/EngineGetModelVisibleTime', name='engineGetModelVisibleTime', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineSetModelVisibleTime', return_types=['bool'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='timeOn', argument_type='int', default_value=None, optional=False), FunctionArgument(name='timeOff', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'modelID': ': ID of the model', 'timeOn': ': value between 23 and 0 that states when the model should appear', 'timeOff': ': value between 23 and 0 that states when the model should disappear'}, result="Returns '''true''' if the change was successful, '''false''' otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineSetModelVisibleTime', name='engineSetModelVisibleTime', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineRestreamWorld', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='', arguments={}, result="Returns ''true'' if the world was restreamed successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineRestreamWorld', name='engineRestreamWorld', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineImportTXD', return_types=['bool'], arguments=[FunctionArgument(name='texture', argument_type='txd', default_value=None, optional=False), FunctionArgument(name='model', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function imports (adds) a loaded RenderWare Texture Dictionary into a specific model. This is necessary in order for the DFF loader to find any new textures. Please '''call this function before loading the DFF model file''', in order to allow the DFF loading process to find the new textures. This function can also replace default GTA textures, so that it becomes possible to e.g. put custom images on existing billboards. Ped and weapon textures are also supported.\nSee here for [[Optimize_Custom_TXD|tips on reducing the size of TXD files]].\n* CJ clothing component textures can be replaced by using the ids listed on [[Clothing Component IDs|this page]]\n}}", arguments={'texture': 'The TXD that was loaded with engineLoadTXD', 'model_id': 'The model id to import the TXD into'}, result="Returns ''true'' if the function executed succesfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineImportTXD', name='engineImportTXD', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineLoadCOL', return_types=['col'], arguments=[FunctionArgument(name='col', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function loads a RenderWare Collision (COL 1/2/3) file into GTA. The collisions can then be used to provide collisions for in-game objects.\nFor vehicles, please omit this function by embedding your [[COL]] file into your [[DFF]] file. This way, you can be sure that the COL file is correctly (and automatically) loaded when calling [[engineLoadDFF]].\nThis is a client side function. Be sure to transfer your COL file by including it in the meta file.', arguments={'col_file / raw_data': 'The filepath to the COL file you want to load or whole data buffer of the COL file.'}, result="Returns a [[COL]] if the file was loaded, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineLoadCOL', name='engineLoadCOL', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineLoadDFF', return_types=['dff'], arguments=[FunctionArgument(name='dff', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function loads a RenderWare Model (DFF) file into GTA.\nTo successfully load your model with textures, be sure to use [[engineLoadTXD]] and [[engineImportTXD]] before calling this function. If some error occurs while loading the DFF, MTA will output a message - check out [[DFF error messages]] to know what they mean.\nThis is a client side function. Be sure to transfer your DFF file by including it in the meta file.\nThe returned [[DFF]] element is an element in the element tree, just like vehicles and objects. When the dff is destroyed, ie on resource unload or using [[destroyElement]], any elements that use the DFF, such as vehicles or objects will be reset.', arguments={'dff_file / raw_data': 'The filepath to the DFF file you want to load or whole data buffer of the DFF file.'}, result="Returns a [[DFF]] element if the dff file loaded, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineLoadDFF', name='engineLoadDFF', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineLoadIFP', return_types=['ifp'], arguments=[FunctionArgument(name='ifp', argument_type='string', default_value=None, optional=False), FunctionArgument(name='custom', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function loads an animation library (IFP) file into GTA with a custom block name. All three IFP formats are supported ANPK, ANP2, and ANP3. Unfortunately, GTA 3 animations are not supported, however, you can load GTA:VC IFP files using this function. You don't have to replace any animation to play a custom one, to play a custom animation, load the IFP file using this function, then use [[SetPedAnimation|setPedAnimation]].\nIf you wish to replace a GTA internal animation with a custom one, you can use [[EngineReplaceAnimation|engineReplaceAnimation]]. To unload the IFP file, use [[DestroyElement|destroyElement]], restarting or stopping the resource can also unload the IFP file automatically.}}", arguments={'ifp_file / raw_data': 'the filepath|filepath to the IFP file you want to load or whole data buffer of the IFP file.', 'custom_block_name': 'the new block name for the IFP file. You cannot use the GTA default Animations|internal block names. You should namespace this name using a string like resource.blockname'}, result="Returns an [[IFP]] element if the IFP file loaded, ''false'' otherwise.\n{{Tip|If you want to synchronize animations, you can check [[https://drive.google.com/open?id=1L2NkQYuLS0YdoHECvxVRMdPBbEgaYUfH ifp_demo]] resource}}"), oop=None, url=FunctionUrl(url='/wiki/EngineLoadIFP', name='engineLoadIFP', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineLoadTXD', return_types=['txd'], arguments=[FunctionArgument(name='txd', argument_type='string', default_value=None, optional=False), FunctionArgument(name='filteringEnabled', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description='This function loads a RenderWare Texture Dictionary (TXD) file into GTA. The texture dictionary can then be used to provide textures.\nThis is a client side function. Be sure to transfer your TXD file by including it in the meta file.', arguments={'txd_file / raw_data': 'The filepath to the TXD file you want to load or whole data buffer of the TXD file.', 'filteringEnabled': 'Whether to enable texture filtering.'}, result="Returns a [[TXD]] if the file was loaded, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineLoadTXD', name='engineLoadTXD', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineRemoveShaderFromWorldTexture', return_types=['bool'], arguments=[FunctionArgument(name='shader', argument_type='element', default_value=None, optional=False), FunctionArgument(name='textureName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='targetElement', argument_type='element', default_value='nil', optional=True)]), docs=FunctionDoc(description='This function removes a [[shader]] from one or more world textures.', arguments={'shader': 'The shader which is to be removed', 'textureName': 'The name of the world texture to remove the shader from. It should be exactly the same string as used with engineApplyShaderToWorldTexture when the shader was initially applied.\n{{New feature/item|3.0130|1.3.0|4140|', 'targetElement': 'The element to remove the shader from. It should be the same element as used with engineApplyShaderToWorldTexture when the shader was initially applied.\n}}'}, result="Returns ''true'' if the shader was successfully removed, ''false'' otherwise."), oop=FunctionOOP(class_name='shader', method_name="removeFromWorldTexture}}}}\n\n===Required Arguments=== \n*'''shader:''' The shader which is to be removed\n*'''textureName:''' The name of the world texture to remove the shader from. It should be exactly the same string as used with [[engineApplyShaderToWorldTexture]] when the shader was initially applied.\n\n===Optional Arguments=== \n{{New feature/item", field='3.0130'), url=FunctionUrl(url='/wiki/EngineRemoveShaderFromWorldTexture', name='engineRemoveShaderFromWorldTexture', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineReplaceAnimation', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='InternalBlockName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='InternalAnimName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='CustomBlockName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='CustomAnimName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function replaces a specific internal (default) animation with a custom one that has been loaded using [[EngineLoadIFP|engineLoadIFP]] function. This function only affects a specific [[player]] or [[ped]], the [[Animations|internal animation]] is not replaced for everyone, for instance, different players and peds are able to have completely different crouching, walking, and fighting etc., animations running simultaneously at the same time. Also, it\'s not synchronized, you\'ll need to execute this function on every client in Lua to synchronize it.\nInternal animations replaced using this function can still be played with [[SetPedAnimation|setPedAnimation]]. You can restore replaced animations back with [[EngineRestoreAnimation|engineRestoreAnimation]].\nIt should be noted that partial animations are not supported, you can still replace them, but they won\'t work as intended, for example, "FightA_block" animation from "ped" block is a partial animation, you can\'t replace it properly, only a few animations are partial, rest of them are not, so it shouldn\'t be a problem.}}', arguments={'thePed': 'the player or ped you want to replace an animation for.', 'InternalBlockName': 'the Animations|internal block name.', 'InternalAnimName': 'the Animations|internal animation name inside InternalBlockName.', 'CustomBlockName': 'the custom block name of the loaded IFP file that you passed to EngineLoadIFP|engineLoadIFP as second parameter.', 'CustomAnimName': 'the custom animation name inside the loaded IFP file with CustomBlockName.'}, result="Returns ''true'' on success, ''false'' in case of failure."), oop=None, url=FunctionUrl(url='/wiki/EngineReplaceAnimation', name='engineReplaceAnimation', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineReplaceCOL', return_types=['bool'], arguments=[FunctionArgument(name='theCol', argument_type='col', default_value=None, optional=False), FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function replaces the collision file of the given model id to the collision file passed. Use [[engineLoadCOL]] to load the collision file first.', arguments={'theCol': 'The collision file to replace with', 'modelID': 'The model ID whose collision file you want to replace'}, result="Returns ''true'' if the collision was successfully replaced, ''false'' or ''nil'' if the collision could not be replaced for a reason."), oop=None, url=FunctionUrl(url='/wiki/EngineReplaceCOL', name='engineReplaceCOL', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineReplaceModel', return_types=['bool'], arguments=[FunctionArgument(name='theModel', argument_type='dff', default_value=None, optional=False), FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='alphaTransparency', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function replaces the given model ID with the model contained in a DFF file loaded by [[engineLoadDFF]]. This function supports [[vehicle|vehicles]], [[object|objects]], [[ped|peds]] and [[player|players]] but not CJ clothing and body parts.\nTo replace weapon models you must use their object IDs, not weapon IDs. There is a weapon model list available at [[weapons]].\n* Default GTA map objects behave inconsistently when using this function on them. If you want to replace models in the original GTA map, use one of the [[EngineReplaceModel notes|methods shown here]].}}', arguments={'theModel': 'The model to replace the given model ID with', 'modelID': 'The model it to replace the model of', 'alphaTransparency': 'Set to true if model uses semi-transparent textures, e.g. windows. This will ensure other objects behind the semi-transparent textures are rendered correctly. (Can slightly impact performance, so only set when required)'}, result="Returns ''true'' if the model was successfully replaced, ''false'' if it failed for some reason, ie. the DFF or the model ID is not valid."), oop=None, url=FunctionUrl(url='/wiki/EngineReplaceModel', name='engineReplaceModel', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineResetModelLODDistance', return_types=['bool'], arguments=[FunctionArgument(name='model', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'model': 'The model / object ID number you want to reset the LOD distance of.'}, result="Returns ''true'' if the LOD distance was reset to default, or ''false'' if the model argument is incorrect, or the LOD distance hasn't been changed."), oop=None, url=FunctionUrl(url='/wiki/EngineResetModelLODDistance', name='engineResetModelLODDistance', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineRestoreAnimation', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='InternalBlockName', argument_type='string', default_value=None, optional=True), FunctionArgument(name='InternalAnimName', argument_type='string', default_value=None, optional=True)]), docs=FunctionDoc(description='This function restores internal (default) animations that were replaced using [[EngineReplaceAnimation|engineReplaceAnimation]] function. This function only affects a specific [[player]] or [[ped]] just like [[EngineReplaceAnimation|engineReplaceAnimation]]. \nIf only 1st parameter ([[Ped|ped]]) is provided to this function, all replaced animations are restored. \nIf block name is also provided for 2nd parameter, then replaced animations within that block are restored.\nIf 3rd parameter (animation name) is provided, then only that specific animation within that specific block is restored.}}', arguments={'thePed': 'the player or ped you want to restore an animation(s) for.\n{{OptionalArg}}', 'InternalBlockName': 'the Animations|internal block name.', 'InternalAnimName': 'the Animations|internal animation name inside InternalBlockName.'}, result="Returns ''true'' on success, ''false'' in case of failure."), oop=None, url=FunctionUrl(url='/wiki/EngineRestoreAnimation', name='engineRestoreAnimation', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineRestoreCOL', return_types=['bool'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function restores the original collision model of the given model ID. Reverses the effect of [[engineReplaceCOL]].", arguments={'modelID': 'The ID of the model to restore the model of'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if this function succeeds, ''false'' or ''nil'' if it fails for some reason."), oop=None, url=FunctionUrl(url='/wiki/EngineRestoreCOL', name='engineRestoreCOL', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineRestoreModel', return_types=['bool'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function restores the visual DFF model of the given model ID. This restores the result of [[engineReplaceModel]].", arguments={'modelID': 'The model ID to restore the visuals of'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the model was successfully restored, ''false'' or ''nil'' if it failed for some reason."), oop=None, url=FunctionUrl(url='/wiki/EngineRestoreModel', name='engineRestoreModel', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineSetAsynchronousLoading', return_types=['bool'], arguments=[FunctionArgument(name='enable', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='force', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function enables or disables asynchronous model loading. Enabling asynchronous model loading may reduce the small pauses that occur when a new model is displayed for the first time. However, it can cause the new models to appear slightly later than they might have otherwise.', arguments={'enable': 'Set to true/false to enable/disable asynchronous loading. Only works if the clients preferences has Asynchronous Loading set to Auto.', 'force': 'If set to true, ignores the clients preferences.'}, result="Returns ''true'' if the function executed successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineSetAsynchronousLoading', name='engineSetAsynchronousLoading', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineSetModelLODDistance', return_types=['bool'], arguments=[FunctionArgument(name='model', argument_type='int', default_value=None, optional=False), FunctionArgument(name='distance', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets a custom LOD distance for any object / model ID. This is the distance at which objects of that model ID are switched to their LOD model, or (if there is no LOD model) become invisible.\n'''Notes:'''\nThe actual draw distance used is modified by the draw distance slider in the settings 'Video' tab of the MTA client.\n*When the 'Video' tab draw distance slider is 0%, the engineSetModelLODDistance setting approximately matches the draw distance used.\n:''e.g. engineSetModelLODDistance(1337,100) will mean model 1337 will be visible up to a distance of '''100''' units.''\n*When the 'Video' tab draw distance slider is 100%, the engineSetModelLODDistance setting is approximately doubled before use.\n:''e.g. engineSetModelLODDistance(1337,100) will mean model 1337 will be visible up to a distance of '''200''' units.''\nHowever, there is a general draw distance limit of 300 units. So engineSetModelLODDistance(1337,400) will mean model 1337 will be visible up to a distance of 300 units no matter what the 'Video' tab says.\nTherefore, unless it's really important, engineSetModelLODDistance should not be set to anything greater than 170.<br>\n170 will still give the maximum draw distance (of 300 units) on clients that have a 'Video' tab draw distance setting of 100%, and it will help reduce lag for players who chose a lower draw distance in their settings.\nFor low LOD elements, engineSetModelLODDistance still has a limit of 300 units, but the actual draw distance used is 5 times the setting value. Also, low LOD elements ignore the 'Video' tab draw distance slider. So a setting of 200 will mean a low LOD element will always have a draw distance of '''1000''' units.\n}}", arguments={'model': 'The model / object ID number you want to change the LOD distance of.', 'distance': 'New LOD distance value in San Andreas units.'}, result="Returns ''true'' if the function executed succesfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineSetModelLODDistance', name='engineSetModelLODDistance', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineSetSurfaceProperties', return_types=['bool'], arguments=[FunctionArgument(name='surfaceID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='mixed', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'surfaceID': 'Material IDs|Material ID from 0 to 178', 'property': 'Property name', 'value': 'New value from table below'}, result="Returns ''true'' if the function executed succesfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineSetSurfaceProperties', name='engineSetSurfaceProperties', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineGetSurfaceProperties', return_types=['mixed'], arguments=[FunctionArgument(name='surfaceID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'surfaceID': 'Material IDs|Material ID from 0 to 178', 'property': 'Property name'}, result='Returns the current property value. See the table below for possible values.'), oop=None, url=FunctionUrl(url='/wiki/EngineGetSurfaceProperties', name='engineGetSurfaceProperties', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='engineResetSurfaceProperties', return_types=['mixed'], arguments=[FunctionArgument(name='surfaceID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'surfaceID': 'Material IDs|Material ID from 0 to 178'}, result="Returns ''true'' if the function executed succesfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/EngineResetSurfaceProperties', name='engineResetSurfaceProperties', category='Engine functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='addEvent', return_types=['bool'], arguments=[FunctionArgument(name='eventName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='allowRemoteTrigger', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function allows you to register a custom [[event]]. Custom events function exactly like the built-in events. See [[event system]] for more information on the event system.', arguments={'eventName': 'The name of the event you wish to create.', 'allowRemoteTrigger': 'A boolean specifying whether this event can be called remotely using triggerClientEvent / triggerServerEvent or not.'}, result="Returns ''true'' if the event was added successfully, ''false'' if the event was already added."), oop=None, url=FunctionUrl(url='/wiki/AddEvent', name='addEvent', category='Event functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='addEvent', return_types=['bool'], arguments=[FunctionArgument(name='eventName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='allowRemoteTrigger', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function allows you to register a custom [[event]]. Custom events function exactly like the built-in events. See [[event system]] for more information on the event system.', arguments={'eventName': 'The name of the event you wish to create.', 'allowRemoteTrigger': 'A boolean specifying whether this event can be called remotely using triggerClientEvent / triggerServerEvent or not.'}, result="Returns ''true'' if the event was added successfully, ''false'' if the event was already added."), oop=None, url=FunctionUrl(url='/wiki/AddEvent', name='addEvent', category='Event functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='addEventHandler', return_types=['bool'], arguments=[FunctionArgument(name='eventName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='attachedTo', argument_type='element', default_value=None, optional=False), FunctionArgument(name='handlerFunction', argument_type='function', default_value=None, optional=False), FunctionArgument(name='propagate', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='priority', argument_type='string', default_value='"normal"', optional=True)]), docs=FunctionDoc(description="This function will add an [[event]] handler. An event handler is a function that will be called when the event it's attached to is triggered. See [[event system]] for more information on how the event system works.\nEvent handlers are functions that are called when a particular event happens. Each event specifies a specific set of variables that are passed to the event handler and can be read by your function. The following global variables are available for use in handler functions:\n*'''source''': the element that triggered the event\n*'''this''': the element that the event handler is attached to\n*'''sourceResource''': the resource that triggered the event\n*'''sourceResourceRoot''': the root element of the resource that triggered the event\n*'''client''': the client that triggered the event using [[triggerServerEvent]]. Not set if the event was not triggered from a client.\n*'''eventName''': the name of the event which triggered the handler function.\n}}\nIt is important to remember that events pass up and down the [[element tree]]. An event triggered on the root element is triggered on every element in the tree. An event triggered on any other element is triggered on its ancestors (its parent element and its parent's parent etc) and its children, grandchildren and great-grandchildren. You can use the ''getPropagated'' argument to specify if you wish your handler to receive events that have propagated up or down the tree.\nThe order in which event handlers are triggered is undefined, you should not rely on one event handler being executed before another.", arguments={'eventName': 'The name of the event you want to attach the handler function to. Note: The maximum allowed length is 100 ASCII characters (that is, English letters and numerals)```', 'attachedTo': 'The element you wish to attach the handler to. The handler will only be called when the event it is attached to is triggered for this element, or one of its children. Often, this can be the root element (meaning the handler will be called when the event is triggered for any element).', 'handlerFunction': 'The handler function you wish to call when the event is triggered. This function will be passed all of the events parameters as arguments, but it isnt required that it takes all of them.', 'propagate': 'A boolean representing whether the handler will be triggered if the event was propagated down or up the element tree (starting from the source), and not triggered directly on attachedTo (that is, handlers attached with this argument set to false will only be triggered if source == this). In GUI events you will probably want to set this to false.\n{{New_feature|3.0131|1.3.1|', 'priority ': 'A string representing the trigger order priority relative to other event handlers of the same name. Possible values are:', '"high"': '', '"normal"': '', '"low"': '\n\'\'It is also possible to add finer priority control by appending a positive or negative number to the priority string. For example (in priority order for reference): "high+4" "high" "high-1" "normal-6" "normal-7" "low+1" "low" "low-1"\'\'\n{{Important Note|Anything bound to a specific element will be run before other handlers that are bound to something higher in the element tree (like root) This means that "high+10" bound to root \'\'\'won\'t\'\'\' trigger before "normal" bound directly to an element.}}\n}}'}, result="Returns ''true'' if the event handler was attached successfully. Returns ''false'' if the specified event could not be found or any parameters were invalid."), oop=None, url=FunctionUrl(url='/wiki/AddEventHandler', name='addEventHandler', category='Event functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='addEventHandler', return_types=['bool'], arguments=[FunctionArgument(name='eventName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='attachedTo', argument_type='element', default_value=None, optional=False), FunctionArgument(name='handlerFunction', argument_type='function', default_value=None, optional=False), FunctionArgument(name='propagate', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='priority', argument_type='string', default_value='"normal"', optional=True)]), docs=FunctionDoc(description="This function will add an [[event]] handler. An event handler is a function that will be called when the event it's attached to is triggered. See [[event system]] for more information on how the event system works.\nEvent handlers are functions that are called when a particular event happens. Each event specifies a specific set of variables that are passed to the event handler and can be read by your function. The following global variables are available for use in handler functions:\n*'''source''': the element that triggered the event\n*'''this''': the element that the event handler is attached to\n*'''sourceResource''': the resource that triggered the event\n*'''sourceResourceRoot''': the root element of the resource that triggered the event\n*'''client''': the client that triggered the event using [[triggerServerEvent]]. Not set if the event was not triggered from a client.\n*'''eventName''': the name of the event which triggered the handler function.\n}}\nIt is important to remember that events pass up and down the [[element tree]]. An event triggered on the root element is triggered on every element in the tree. An event triggered on any other element is triggered on its ancestors (its parent element and its parent's parent etc) and its children, grandchildren and great-grandchildren. You can use the ''getPropagated'' argument to specify if you wish your handler to receive events that have propagated up or down the tree.\nThe order in which event handlers are triggered is undefined, you should not rely on one event handler being executed before another.", arguments={'eventName': 'The name of the event you want to attach the handler function to. Note: The maximum allowed length is 100 ASCII characters (that is, English letters and numerals)```', 'attachedTo': 'The element you wish to attach the handler to. The handler will only be called when the event it is attached to is triggered for this element, or one of its children. Often, this can be the root element (meaning the handler will be called when the event is triggered for any element).', 'handlerFunction': 'The handler function you wish to call when the event is triggered. This function will be passed all of the events parameters as arguments, but it isnt required that it takes all of them.', 'propagate': 'A boolean representing whether the handler will be triggered if the event was propagated down or up the element tree (starting from the source), and not triggered directly on attachedTo (that is, handlers attached with this argument set to false will only be triggered if source == this). In GUI events you will probably want to set this to false.\n{{New_feature|3.0131|1.3.1|', 'priority ': 'A string representing the trigger order priority relative to other event handlers of the same name. Possible values are:', '"high"': '', '"normal"': '', '"low"': '\n\'\'It is also possible to add finer priority control by appending a positive or negative number to the priority string. For example (in priority order for reference): "high+4" "high" "high-1" "normal-6" "normal-7" "low+1" "low" "low-1"\'\'\n{{Important Note|Anything bound to a specific element will be run before other handlers that are bound to something higher in the element tree (like root) This means that "high+10" bound to root \'\'\'won\'t\'\'\' trigger before "normal" bound directly to an element.}}\n}}'}, result="Returns ''true'' if the event handler was attached successfully. Returns ''false'' if the specified event could not be found or any parameters were invalid."), oop=None, url=FunctionUrl(url='/wiki/AddEventHandler', name='addEventHandler', category='Event functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='cancelEvent', return_types=['bool'], arguments=[FunctionArgument(name='cancel', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='reason', argument_type='string', default_value='""', optional=False)]), docs=FunctionDoc(description="This function is used to stop the automatic internal handling of events, for example this can be used to prevent an item being given to a player when they walk over a pickup, by canceling the [[onPickupUse]] event. \n[[cancelEvent]] does not have an effect on all events, see the individual event's pages for information on what happens when the event is canceled. [[cancelEvent]] does not stop further event handlers from being called, as the order of event handlers being called is undefined in many cases. Instead, you can see if the currently active event has been cancelled using [[wasEventCancelled]].\nThe use of cancelEvent outside of an event handler has no effect.\nIf you implement your own custom events and want to handle them being cancelled, you should call [[wasEventCancelled]] to check after your call to [[triggerEvent]].", arguments={}, result="Always returns ''true''."), oop=None, url=FunctionUrl(url='/wiki/CancelEvent', name='cancelEvent', category='Event functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='cancelEvent', return_types=['bool'], arguments=[]), docs=FunctionDoc(description="This function is used to stop the automatic internal handling of events, for example this can be used to prevent an item being given to a player when they walk over a pickup, by canceling the [[onPickupUse]] event. \n[[cancelEvent]] does not have an effect on all events, see the individual event's pages for information on what happens when the event is canceled. [[cancelEvent]] does not stop further event handlers from being called, as the order of event handlers being called is undefined in many cases. Instead, you can see if the currently active event has been cancelled using [[wasEventCancelled]].\nThe use of cancelEvent outside of an event handler has no effect.\nIf you implement your own custom events and want to handle them being cancelled, you should call [[wasEventCancelled]] to check after your call to [[triggerEvent]].", arguments={}, result="Always returns ''true''."), oop=None, url=FunctionUrl(url='/wiki/CancelEvent', name='cancelEvent', category='Event functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='cancelLatentEvent', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='handle', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Stops a latent event from completing', arguments={'thePlayer': 'The player who is receiving the event.', 'handle': 'A handle previous got from getLatentEventHandles.'}, result='Returns a true if the latent event was successfully cancelled, or false if it was not'), oop=None, url=FunctionUrl(url='/wiki/CancelLatentEvent', name='cancelLatentEvent', category='Event functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='cancelLatentEvent', return_types=['bool'], arguments=[FunctionArgument(name='handle', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Stops a latent event from completing', arguments={'handle': 'A handle previous got from getLatentEventHandles.'}, result='Returns a true if the latent event was successfully cancelled, or false if it was not'), oop=None, url=FunctionUrl(url='/wiki/CancelLatentEvent', name='cancelLatentEvent', category='Event functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getEventHandlers', return_types=['table'], arguments=[FunctionArgument(name='eventName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='attachedTo', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the attached functions from the event and attached element from current lua script.\n}}', arguments={'eventName': 'The name of the event. For example ( onPlayerWasted ).', 'attachedTo': 'The element attached to.'}, result='Returns table with attached functions, empty table otherwise.'), oop=None, url=FunctionUrl(url='/wiki/GetEventHandlers', name='getEventHandlers', category='Event functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getEventHandlers', return_types=['table'], arguments=[FunctionArgument(name='eventName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='attachedTo', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the attached functions from the event and attached element from current lua script.\n}}', arguments={'eventName': 'The name of the event. For example ( onPlayerWasted ).', 'attachedTo': 'The element attached to.'}, result='Returns table with attached functions, empty table otherwise.'), oop=None, url=FunctionUrl(url='/wiki/GetEventHandlers', name='getEventHandlers', category='Event functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getLatentEventHandles', return_types=['table'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the currently queued latent events. The last one in the table is always the latest event queued. Each returned handle can be used with [[getLatentEventStatus]] or [[cancelLatentEvent]]', arguments={'thePlayer': 'The player who is receiving the events.'}, result='Returns a table of handles or false if invalid arguments were passed.'), oop=None, url=FunctionUrl(url='/wiki/GetLatentEventHandles', name='getLatentEventHandles', category='Event functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getLatentEventHandles', return_types=['table'], arguments=[]), docs=FunctionDoc(description='Gets the currently queued latent events. The last one in the table is always the latest event queued. Each returned handle can be used with [[getLatentEventStatus]] or [[cancelLatentEvent]]', arguments={}, result='Returns a table of handles or false if invalid arguments were passed.'), oop=None, url=FunctionUrl(url='/wiki/GetLatentEventHandles', name='getLatentEventHandles', category='Event functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getLatentEventStatus', return_types=['table'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='handle', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the status of one queued latent event.', arguments={'thePlayer': 'The player who is receiving the event.', 'handle': 'A handle previous got from getLatentEventHandles.'}, result="Returns a table with the following info or false if invalid arguments were passed:\n*'''tickStart:''' A number estimating how many ticks until the data transfer starts (Negative means the transfer has already started)\n*'''tickEnd:''' A number estimating how many ticks until the data transfer completes\n*'''totalSize:''' A number representing how many bytes in total this transfer will transfer\n*'''percentComplete:''' A number between 0-100 saying how much is done"), oop=None, url=FunctionUrl(url='/wiki/GetLatentEventStatus', name='getLatentEventStatus', category='Event functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getLatentEventStatus', return_types=['table'], arguments=[FunctionArgument(name='handle', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the status of one queued latent event.', arguments={'handle': 'A handle previous got from getLatentEventHandles.'}, result="Returns a table with the following info or false if invalid arguments were passed:\n*'''tickStart:''' A number estimating how many ticks until the data transfer starts (Negative means the transfer has already started)\n*'''tickEnd:''' A number estimating how many ticks until the data transfer completes\n*'''totalSize:''' A number representing how many bytes in total this transfer will transfer\n*'''percentComplete:''' A number between 0-100 saying how much is done"), oop=None, url=FunctionUrl(url='/wiki/GetLatentEventStatus', name='getLatentEventStatus', category='Event functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removeEventHandler', return_types=['bool'], arguments=[FunctionArgument(name='eventName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='attachedTo', argument_type='element', default_value=None, optional=False), FunctionArgument(name='functionVar', argument_type='function', default_value=None, optional=False)]), docs=FunctionDoc(description='This functions removes a handler function from an [[event]], so that the function is not called anymore when the event is triggered. See [[event system]] for more information on how the event system works.', arguments={'eventName': 'The name of the event you want to detach the handler function from.', 'attachedTo': 'The element the handler was attached to.', 'functionVar': 'The handler function that was attached.'}, result="Returns ''true'' if the event handler was removed successfully. Returns ''false'' if the specified event handler could not be found or invalid parameters were passed."), oop=None, url=FunctionUrl(url='/wiki/RemoveEventHandler', name='removeEventHandler', category='Event functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='removeEventHandler', return_types=['bool'], arguments=[FunctionArgument(name='eventName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='attachedTo', argument_type='element', default_value=None, optional=False), FunctionArgument(name='functionVar', argument_type='function', default_value=None, optional=False)]), docs=FunctionDoc(description='This functions removes a handler function from an [[event]], so that the function is not called anymore when the event is triggered. See [[event system]] for more information on how the event system works.', arguments={'eventName': 'The name of the event you want to detach the handler function from.', 'attachedTo': 'The element the handler was attached to.', 'functionVar': 'The handler function that was attached.'}, result="Returns ''true'' if the event handler was removed successfully. Returns ''false'' if the specified event handler could not be found or invalid parameters were passed."), oop=None, url=FunctionUrl(url='/wiki/RemoveEventHandler', name='removeEventHandler', category='Event functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='triggerEvent', return_types=['bool'], arguments=[FunctionArgument(name='eventName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='baseElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='argument1', argument_type='var', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description="This function will trigger a named [[event]] on a specific [[element]] in the [[element tree]]. See [[event system]] for more information on how the event system works.\nYou can use the value returned from this function to determine if the event was cancelled by one of the event handlers. You should determine what your response (if any) to this should be based on the event's purpose. Generally, cancelling an event should prevent any further code being run that is dependent on whatever triggered that event. For example, if you have an ''onFlagCapture'' event, cancelling it would be expected to prevent the flag being able to be captured. Similarly, if you have ''onPlayerKill'' as an event you trigger, canceling it would either be expected to prevent the player being killed from dying or at least prevent the player from getting a score for it.", arguments={'eventName': 'The name of the event you wish to trigger', 'baseElement': 'The element you wish to trigger the event on. See event system for information on how this works.\n{{OptionalArg}} ', 'argument1': 'The first argument that the event handler expects should be added after the baseElement variable.', 'NOTE': 'This function can have more than one of these arguments specified, once for each argument the event handler is expecting.'}, result="* Returns '''nil''' if the arguments are invalid or the event could not be found.  \n* Returns '''true''' if the event was triggered successfully, and ''was not'' cancelled using [[cancelEvent]].\n* Returns '''false''' if the event was triggered successfully, and ''was'' cancelled using [[cancelEvent]]."), oop=None, url=FunctionUrl(url='/wiki/TriggerEvent', name='triggerEvent', category='Event functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='triggerEvent', return_types=['bool'], arguments=[FunctionArgument(name='eventName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='baseElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='argument1', argument_type='var', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description="This function will trigger a named [[event]] on a specific [[element]] in the [[element tree]]. See [[event system]] for more information on how the event system works.\nYou can use the value returned from this function to determine if the event was cancelled by one of the event handlers. You should determine what your response (if any) to this should be based on the event's purpose. Generally, cancelling an event should prevent any further code being run that is dependent on whatever triggered that event. For example, if you have an ''onFlagCapture'' event, cancelling it would be expected to prevent the flag being able to be captured. Similarly, if you have ''onPlayerKill'' as an event you trigger, canceling it would either be expected to prevent the player being killed from dying or at least prevent the player from getting a score for it.", arguments={'eventName': 'The name of the event you wish to trigger', 'baseElement': 'The element you wish to trigger the event on. See event system for information on how this works.\n{{OptionalArg}} ', 'argument1': 'The first argument that the event handler expects should be added after the baseElement variable.', 'NOTE': 'This function can have more than one of these arguments specified, once for each argument the event handler is expecting.'}, result="* Returns '''nil''' if the arguments are invalid or the event could not be found.  \n* Returns '''true''' if the event was triggered successfully, and ''was not'' cancelled using [[cancelEvent]].\n* Returns '''false''' if the event was triggered successfully, and ''was'' cancelled using [[cancelEvent]]."), oop=None, url=FunctionUrl(url='/wiki/TriggerEvent', name='triggerEvent', category='Event functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='triggerLatentServerEvent', return_types=['bool'], arguments=[FunctionArgument(name='event', argument_type='string', default_value=None, optional=False), FunctionArgument(name='bandwidth', argument_type='int', default_value='5000', optional=False), FunctionArgument(name='persist', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function is the same as [[triggerServerEvent]] except the transmission rate of the data contained in the arguments can be limited and other network traffic is not blocked while the data is being transferred.', arguments={'event': 'The name of the event to trigger server-side. You should register this event with addEvent and add at least one event handler using addEventHandler.', 'theElement': 'The element that is the Event system#Event handlers|source of the event. This could be another player, or if this isnt relevant, use the root element.', 'bandwidth': 'The bytes per second rate to send the data contained in the arguments.', 'persist': 'A bool indicating whether the transmission should be allowed to continue even after the resource that triggered it has since stopped.', 'arguments...': 'A list of arguments to trigger with the event. You can pass any Lua data type (except functions). You can also pass elements. The total amount of data should not exceed 100MB.'}, result="Returns ''true'' if the event trigger has been sent, ''false'' if invalid arguments were specified."), oop=None, url=FunctionUrl(url='/wiki/TriggerLatentServerEvent', name='triggerLatentServerEvent', category='Event functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='triggerServerEvent', return_types=['bool'], arguments=[FunctionArgument(name='event', argument_type='string', default_value=None, optional=False), FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description="<!--{{Needs_Checking|Something needs to be said about the steps required to help keep an event inside a resource. i.e. Setting 'theElement' to resourceRoot here, and setting the matching event handler's 'attachedTo' also to resourceRoot.}}-->__NOTOC__\nThis function triggers an event previously registered on the server. This is the primary means of passing information between the client and the server. Servers have a similar [[triggerClientEvent]] function that can do the reverse. You can treat this function as if it was an asynchronous function call, using [[triggerClientEvent]] to pass back any returned information if necessary.\nAlmost any data types can be passed as expected, including [[element]]s and complex nested [[table]]s. Non-element MTA data types like xmlNodes or resource pointers will not be able to be passed as they do not necessarily have a valid representation on the client. '''Elements of the Vector or Matrix classes cannot be passed!'''\nEvents are sent reliably, so the server will receive them, but there may be (but shouldn't be) a significant delay before they are received. You should take this into account when using them.\nKeep in mind the bandwidth issues when using events - don't pass a large list of arguments unless you really need to. '''It is marginally more efficient to pass one large event than two smaller ones'''.", arguments={'event': 'The name of the event to trigger server-side. You should register this event with addEvent and add at least one event handler using addEventHandler.', 'theElement': "The element that is the Event system#Event handlers|source of the event.\n{{Note|To save server CPU, you should avoid setting '''theElement''' to the [[root element]] where possible. Using [[GetThisResource|resourceRoot]] is usually sufficient if the event is handled by the same resource on the server.}}", 'arguments...': 'A list of arguments to trigger with the event. You can pass any lua data type (except functions). You can also pass elements.'}, result="Returns ''true'' if the event trigger has been sent, ''false'' if invalid arguments were specified or a client side element was a parameter."), oop=None, url=FunctionUrl(url='/wiki/TriggerServerEvent', name='triggerServerEvent', category='Event functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='wasEventCancelled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function checks if the last completed event was cancelled. This is mainly useful for custom events created by scripts. \nEvents can be cancelled using [[cancelEvent]], this indicates that the resource which triggered the event should do whatever it can to reverse any changes made by whatever caused the event. See [[triggerEvent]] for a more detailed explanation of this.', arguments={}, result="Returns ''true'' if the event was cancelled, ''false'' if it wasn't or doesn't exist."), oop=None, url=FunctionUrl(url='/wiki/WasEventCancelled', name='wasEventCancelled', category='Event functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='wasEventCancelled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function checks if the last completed event was cancelled. This is mainly useful for custom events created by scripts. \nEvents can be cancelled using [[cancelEvent]], this indicates that the resource which triggered the event should do whatever it can to reverse any changes made by whatever caused the event. See [[triggerEvent]] for a more detailed explanation of this.', arguments={}, result="Returns ''true'' if the event was cancelled, ''false'' if it wasn't or doesn't exist."), oop=None, url=FunctionUrl(url='/wiki/WasEventCancelled', name='wasEventCancelled', category='Event functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createExplosion', return_types=['bool'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='theType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='creator', argument_type='player', default_value='nil', optional=True)]), docs=FunctionDoc(description='Creates an explosion of a certain type at a specified point in the world. If creator is specified, the explosion will occur only in its dimension.', arguments={'x': 'a float value that specifies the X world coordinate where the explosion is created at.', 'y': 'a float value that specifies the Y world coordinate where the explosion is created at.', 'z': 'a float value that specifies the Z world coordinate where the explosion is created at.', 'theType': 'an integer specifying the explosion type. Valid types are:\n{{Explosions}}', 'creator': 'the explosions simulated creator, the player responsible for it.'}, result="*''true'' if the explosion was created.\n* ''false'' if invalid parameters were passed."), oop=None, url=FunctionUrl(url='/wiki/CreateExplosion', name='createExplosion', category='Explosion functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createExplosion', return_types=['bool'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='theType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='makeSound', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='camShake', argument_type='float', default_value='-1.0', optional=True), FunctionArgument(name='damaging', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description='Creates an explosion of a certain type at a specified point in the world. If creator is specified, the explosion will occur only in its dimension.', arguments={'x': 'a float value that specifies the X world coordinate where the explosion is created at.', 'y': 'a float value that specifies the Y world coordinate where the explosion is created at.', 'z': 'a float value that specifies the Z world coordinate where the explosion is created at.', 'theType': 'a integer specifying the explosion type. Valid types are:\n{{Explosions}}', 'makeSound': 'a boolean specifying whether the explosion should be heard or not.', 'camShake': 'a float specifying the camera shakes intensity.', 'damaging': 'a boolean specifying whether the explosion should cause damage or not.'}, result="*''true'' if the explosion was created.\n* ''false'' if invalid parameters were passed."), oop=None, url=FunctionUrl(url='/wiki/CreateExplosion', name='createExplosion', category='Explosion functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileClose', return_types=['bool'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False)]), docs=FunctionDoc(description='Closes a file handle obtained by [[fileCreate]] or [[fileOpen]].', arguments={'theFile': 'The file handle to close.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/FileClose', name='fileClose', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileClose', return_types=['bool'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False)]), docs=FunctionDoc(description='Closes a file handle obtained by [[fileCreate]] or [[fileOpen]].', arguments={'theFile': 'The file handle to close.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/FileClose', name='fileClose', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileCopy', return_types=['bool'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='copyToFilePath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='overwrite', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function copies a file.{{Note|The file functions should not be used to implement configuration files. It is encouraged to use the XML functions for this instead.}}', arguments={'filePath': ': The path of the file you want to copy.', 'copyToFilePath': ': Where to copy the specified file to.', 'overwrite': ': If set to true it will overwrite a file that already exists at copyToFilePath.'}, result="Return true if the file was copied, else false if the 'filePath' doesn't exist."), oop=None, url=FunctionUrl(url='/wiki/FileCopy', name='fileCopy', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileCopy', return_types=['bool'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='copyToFilePath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='overwrite', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function copies a file.{{Note|The file functions should not be used to implement configuration files. It is encouraged to use the XML functions for this instead.}}', arguments={'filePath': ': The path of the file you want to copy.', 'copyToFilePath': ': Where to copy the specified file to.', 'overwrite': ': If set to true it will overwrite a file that already exists at copyToFilePath.'}, result="Return true if the file was copied, else false if the 'filePath' doesn't exist."), oop=None, url=FunctionUrl(url='/wiki/FileCopy', name='fileCopy', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileCreate', return_types=['file'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Creates a new file in a directory of a resource. If there already exists a file with the specified name, it is overwritten with an empty file.', arguments={'filePath': 'The filepath of the file to be created in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file.\n:For example, if you want to create a file named \'myfile.txt\' in the resource \'mapcreator\', it can be created from another resource this way: \'\'fileCreate(":mapcreator/myfile.txt")\'\'.\n:If the file is in the current resource, only the file path is necessary, e.g. \'\'fileCreate("myfile.txt")\'\'.'}, result="If successful, returns a file handle which can be used with other file functions ([[fileWrite]], [[fileClose]]...). Returns ''false'' if an error occured."), oop=FunctionOOP(class_name='File', method_name='new}}\n\n{{New feature/item', field='9.0156'), url=FunctionUrl(url='/wiki/FileCreate', name='fileCreate', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileCreate', return_types=['file'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Creates a new file in a directory of a resource. If there already exists a file with the specified name, it is overwritten with an empty file.', arguments={'filePath': 'The filepath of the file to be created in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file.\n:For example, if you want to create a file named \'myfile.txt\' in the resource \'mapcreator\', it can be created from another resource this way: \'\'fileCreate(":mapcreator/myfile.txt")\'\'.\n:If the file is in the current resource, only the file path is necessary, e.g. \'\'fileCreate("myfile.txt")\'\'.'}, result="If successful, returns a file handle which can be used with other file functions ([[fileWrite]], [[fileClose]]...). Returns ''false'' if an error occured."), oop=FunctionOOP(class_name='File', method_name='new}}\n\n{{New feature/item', field='9.0156'), url=FunctionUrl(url='/wiki/FileCreate', name='fileCreate', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileDelete', return_types=['bool'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Deletes the specified file.', arguments={'filePath': 'The filepath of the file to delete in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file.\n:For example, if you want to delete a file name "myFile.txt" in the resource \'fileres\', it can be deleted from another resource this way: \'\'fileDelete(":fileres/myFile.txt")\'\'.\n:If the file is in the current resource, only the file path is necessary, e.g. \'\'fileDelete("myFile.txt")\'\'.'}, result="Returns ''true'' if successful, ''false'' otherwise (for example if there exists no file with the given name, or it does exist but is in use)."), oop=None, url=FunctionUrl(url='/wiki/FileDelete', name='fileDelete', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileDelete', return_types=['bool'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Deletes the specified file.', arguments={'filePath': 'The filepath of the file to delete in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file.\n:For example, if you want to delete a file name "myFile.txt" in the resource \'fileres\', it can be deleted from another resource this way: \'\'fileDelete(":fileres/myFile.txt")\'\'.\n:If the file is in the current resource, only the file path is necessary, e.g. \'\'fileDelete("myFile.txt")\'\'.'}, result="Returns ''true'' if successful, ''false'' otherwise (for example if there exists no file with the given name, or it does exist but is in use)."), oop=None, url=FunctionUrl(url='/wiki/FileDelete', name='fileDelete', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileExists', return_types=['bool'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This functions checks whether a specified file exists inside a resource.', arguments={'filePath': 'The filepath of the file, whose existence is going to be checked, in the following format: :resourceName/path. resourceName is the name of the resource the file is checked to be in, and path is the path from the root directory of the resource to the file.\n:For example, if you want to check whether a file named \'myfile.txt\' exists in the resource \'mapcreator\', it can be done from another resource this way: \'\'fileExists(":mapcreator/myfile.txt")\'\'.\n:If the file, whose existence is going to be checked, is in the current resource, only the file path is necessary, e.g. \'\'fileExists("myfile.txt")\'\'. Note that you must use forward slashes \'/\' for the folders, backslashes \'\\\' will return false.'}, result="Returns ''true'' if the file exists, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/FileExists', name='fileExists', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileExists', return_types=['bool'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This functions checks whether a specified file exists inside a resource.', arguments={'filePath': 'The filepath of the file, whose existence is going to be checked, in the following format: :resourceName/path. resourceName is the name of the resource the file is checked to be in, and path is the path from the root directory of the resource to the file.\n:For example, if you want to check whether a file named \'myfile.txt\' exists in the resource \'mapcreator\', it can be done from another resource this way: \'\'fileExists(":mapcreator/myfile.txt")\'\'.\n:If the file, whose existence is going to be checked, is in the current resource, only the file path is necessary, e.g. \'\'fileExists("myfile.txt")\'\'. Note that you must use forward slashes \'/\' for the folders, backslashes \'\\\' will return false.'}, result="Returns ''true'' if the file exists, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/FileExists', name='fileExists', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileFlush', return_types=['bool'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False)]), docs=FunctionDoc(description="Forces pending disk writes to be executed. [[fileWrite]] doesn't directly write to the hard disk but places the data in a temporary buffer; only when there is enough data in the buffer it is actually written to disk. Call this function if you need the data written right now without closing the file. This is useful for log files that might want to be read while the resource is still executing. [[fileFlush]] can be called after each log entry is written. Without this, the file may appear empty or outdated to the user.", arguments={'theFile': 'The file handle of the file you wish to flush.'}, result="Returns ''true'' if succeeded, ''false'' in case of failure (e.g. the file handle is invalid)."), oop=None, url=FunctionUrl(url='/wiki/FileFlush', name='fileFlush', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileFlush', return_types=['bool'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False)]), docs=FunctionDoc(description="Forces pending disk writes to be executed. [[fileWrite]] doesn't directly write to the hard disk but places the data in a temporary buffer; only when there is enough data in the buffer it is actually written to disk. Call this function if you need the data written right now without closing the file. This is useful for log files that might want to be read while the resource is still executing. [[fileFlush]] can be called after each log entry is written. Without this, the file may appear empty or outdated to the user.", arguments={'theFile': 'The file handle of the file you wish to flush.'}, result="Returns ''true'' if succeeded, ''false'' in case of failure (e.g. the file handle is invalid)."), oop=None, url=FunctionUrl(url='/wiki/FileFlush', name='fileFlush', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileGetPath', return_types=['string'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the path of the given file.\n}}', arguments={'theFile': 'The file you want to get the path.'}, result="Returns a ''string'' representing the file path, ''false'' if invalid file was provided."), oop=None, url=FunctionUrl(url='/wiki/FileGetPath', name='fileGetPath', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileGetPath', return_types=['string'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the path of the given file.\n}}', arguments={'theFile': 'The file you want to get the path.'}, result="Returns a ''string'' representing the file path, ''false'' if invalid file was provided."), oop=None, url=FunctionUrl(url='/wiki/FileGetPath', name='fileGetPath', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileGetPos', return_types=['int'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the current read/write position in the given file.', arguments={'theFile': 'the file handle you wish to get the position of.'}, result="Returns the file position if successful, or ''false'' if an error occured (e.g. an invalid handle was passed)."), oop=FunctionOOP(class_name='file', method_name='getPos', field='pos'), url=FunctionUrl(url='/wiki/FileGetPos', name='fileGetPos', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileGetPos', return_types=['int'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the current read/write position in the given file.', arguments={'theFile': 'the file handle you wish to get the position of.'}, result="Returns the file position if successful, or ''false'' if an error occured (e.g. an invalid handle was passed)."), oop=FunctionOOP(class_name='file', method_name='getPos', field='pos'), url=FunctionUrl(url='/wiki/FileGetPos', name='fileGetPos', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileGetSize', return_types=['int'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the total size in bytes of the given file.', arguments={'theFile': 'the file handle you wish to get the size of.'}, result="Returns the file size if successful, or ''false'' if an error occured (e.g. an invalid file handle was passed)."), oop=FunctionOOP(class_name='file', method_name='getSize', field="size}}\n\n===Required Arguments===\n*'''theFile:''' the file handle you wish to get the size of.\n\n===Returns===\nReturns the file size if successful, or ''false'' if an error occured (e.g. an invalid file handle was passed).\n\n"), url=FunctionUrl(url='/wiki/FileGetSize', name='fileGetSize', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileGetSize', return_types=['int'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the total size in bytes of the given file.', arguments={'theFile': 'the file handle you wish to get the size of.'}, result="Returns the file size if successful, or ''false'' if an error occured (e.g. an invalid file handle was passed)."), oop=FunctionOOP(class_name='file', method_name='getSize', field="size}}\n\n===Required Arguments===\n*'''theFile:''' the file handle you wish to get the size of.\n\n===Returns===\nReturns the file size if successful, or ''false'' if an error occured (e.g. an invalid file handle was passed).\n\n"), url=FunctionUrl(url='/wiki/FileGetSize', name='fileGetSize', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileIsEOF', return_types=['bool'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False)]), docs=FunctionDoc(description='Checks if the file position is at the end of the file.', arguments={'theFile': 'A handle to the file you wish to check.'}, result="Returns ''true'' if the file position of the specified file is at the end of the file, ''false'' otherwise."), oop=FunctionOOP(class_name='file', method_name='isEOF', field="eof}}\n\n===Required Arguments===\n*'''theFile:''' A handle to the file you wish to check.\n\n===Returns===\nReturns ''true'' if the file position of the specified file is at the end of the file, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/FileIsEOF', name='fileIsEOF', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileIsEOF', return_types=['bool'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False)]), docs=FunctionDoc(description='Checks if the file position is at the end of the file.', arguments={'theFile': 'A handle to the file you wish to check.'}, result="Returns ''true'' if the file position of the specified file is at the end of the file, ''false'' otherwise."), oop=FunctionOOP(class_name='file', method_name='isEOF', field="eof}}\n\n===Required Arguments===\n*'''theFile:''' A handle to the file you wish to check.\n\n===Returns===\nReturns ''true'' if the file position of the specified file is at the end of the file, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/FileIsEOF', name='fileIsEOF', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileOpen', return_types=['file'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='readOnly', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='Opens an existing file for reading and writing.', arguments={'filePath': 'The filepath of the file in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file.\n:For example, if there is a file named \'coolObjects.txt\' in the resource \'objectSearch\', it can be opened from another resource this way: \'\'fileOpen(":objectSearch/coolObjects.txt")\'\'.\n:If the file is in the current resource, only the file path is necessary, e.g. \'\'fileOpen("coolObjects.txt")\'\'.', 'readOnly': 'By default, the file is opened with reading and writing access. You can specify true for this parameter if you only need reading access.'}, result="If successful, returns a file handle for the file. Otherwise returns ''false'' (f.e. if the file doesn't exist)."), oop=None, url=FunctionUrl(url='/wiki/FileOpen', name='fileOpen', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileOpen', return_types=['file'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='readOnly', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='Opens an existing file for reading and writing.', arguments={'filePath': 'The filepath of the file in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file.\n:For example, if there is a file named \'coolObjects.txt\' in the resource \'objectSearch\', it can be opened from another resource this way: \'\'fileOpen(":objectSearch/coolObjects.txt")\'\'.\n:If the file is in the current resource, only the file path is necessary, e.g. \'\'fileOpen("coolObjects.txt")\'\'.', 'readOnly': 'By default, the file is opened with reading and writing access. You can specify true for this parameter if you only need reading access.'}, result="If successful, returns a file handle for the file. Otherwise returns ''false'' (f.e. if the file doesn't exist)."), oop=None, url=FunctionUrl(url='/wiki/FileOpen', name='fileOpen', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileRead', return_types=['string'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False), FunctionArgument(name='count', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Reads the specified number of bytes from the given file starting at its current read/write position, and returns them as a string.', arguments={'theFile': 'A handle to the file you wish to read from. Use fileOpen to obtain this handle.', 'count': 'The number of bytes you wish to read.'}, result='Returns the bytes that were read in a string. Note that this string might not contain as many bytes as you specified if an error occured, i.e. end of file.'), oop=None, url=FunctionUrl(url='/wiki/FileRead', name='fileRead', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileRead', return_types=['string'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False), FunctionArgument(name='count', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Reads the specified number of bytes from the given file starting at its current read/write position, and returns them as a string.', arguments={'theFile': 'A handle to the file you wish to read from. Use fileOpen to obtain this handle.', 'count': 'The number of bytes you wish to read.'}, result='Returns the bytes that were read in a string. Note that this string might not contain as many bytes as you specified if an error occured, i.e. end of file.'), oop=None, url=FunctionUrl(url='/wiki/FileRead', name='fileRead', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileRename', return_types=['bool'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='newFilePath', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Renames the specified file.', arguments={'filePath': 'The filepath of the source file in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file. If the file is in the current resource, only the file path is necessary.', 'newFilePath': 'Destination filepath for the specified source file in the same format.'}, result="If successful, returns ''true''. Otherwise returns ''false''."), oop=None, url=FunctionUrl(url='/wiki/FileRename', name='fileRename', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileRename', return_types=['bool'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='newFilePath', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Renames the specified file.', arguments={'filePath': 'The filepath of the source file in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file. If the file is in the current resource, only the file path is necessary.', 'newFilePath': 'Destination filepath for the specified source file in the same format.'}, result="If successful, returns ''true''. Otherwise returns ''false''."), oop=None, url=FunctionUrl(url='/wiki/FileRename', name='fileRename', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileSetPos', return_types=['int'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False), FunctionArgument(name='offset', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the current read/write position in the file.', arguments={'theFile': 'The file handle of which you want to change the read/write position.', 'offset': 'The new position. This is the number of bytes from the beginning of the file. If this value is larger than the file size, it is limited to 52,428,800 bytes (50 MB).'}, result="Returns where the offset was actually set at. I.e. if '''offset''' was past the end of the file, it will be set at the end of the file, and this position will be returned. Returns ''false'' in case of failure (e.g. the specified file handle is invalid)."), oop=FunctionOOP(class_name='file', method_name='setPos', field='pos'), url=FunctionUrl(url='/wiki/FileSetPos', name='fileSetPos', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileSetPos', return_types=['int'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False), FunctionArgument(name='offset', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the current read/write position in the file.', arguments={'theFile': 'The file handle of which you want to change the read/write position.', 'offset': 'The new position. This is the number of bytes from the beginning of the file. If this value is larger than the file size, it is limited to 52,428,800 bytes (50 MB).'}, result="Returns where the offset was actually set at. I.e. if '''offset''' was past the end of the file, it will be set at the end of the file, and this position will be returned. Returns ''false'' in case of failure (e.g. the specified file handle is invalid)."), oop=FunctionOOP(class_name='file', method_name='setPos', field='pos'), url=FunctionUrl(url='/wiki/FileSetPos', name='fileSetPos', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fileWrite', return_types=['int'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False), FunctionArgument(name='string1', argument_type='string', default_value=None, optional=False), FunctionArgument(name='string2', argument_type='string', default_value=None, optional=True), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='Writes one or more strings to a given file, starting at the current read/write position. Advances the position over the number of bytes that were written.', arguments={'theFile': 'A handle to the file you wish to write to. The file must have been opened with write access, i.e. the file handle must be a result of fileCreate or fileOpen with the readonly parameter set to false.', 'string1': "The string to write.\n*You can provide any number of additional strings to write after '''string1'''. These will be written in the order in which they are specified."}, result="Returns the number of bytes successfully written to the file, returns ''false'' if invalid arguments were specified."), oop=None, url=FunctionUrl(url='/wiki/FileWrite', name='fileWrite', category='File functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fileWrite', return_types=['int'], arguments=[FunctionArgument(name='theFile', argument_type='file', default_value=None, optional=False), FunctionArgument(name='string1', argument_type='string', default_value=None, optional=False), FunctionArgument(name='string2', argument_type='string', default_value=None, optional=True), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='Writes one or more strings to a given file, starting at the current read/write position. Advances the position over the number of bytes that were written.', arguments={'theFile': 'A handle to the file you wish to write to. The file must have been opened with write access, i.e. the file handle must be a result of fileCreate or fileOpen with the readonly parameter set to false.', 'string1': "The string to write.\n*You can provide any number of additional strings to write after '''string1'''. These will be written in the order in which they are specified."}, result="Returns the number of bytes successfully written to the file, returns ''false'' if invalid arguments were specified."), oop=None, url=FunctionUrl(url='/wiki/FileWrite', name='fileWrite', category='File functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='createFire', return_types=['bool'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='size', argument_type='float', default_value='1.8', optional=True)]), docs=FunctionDoc(description="[[Image:Fire.png|thumb|200px|Fire with default size (1.8)]]\nCreates a patch of fire that will spread a bit and die out after a while. Because it's a client side only function, other players won't see it, so custom events or custom objects will be needed to make a fire visible to some players.", arguments={'x, y, z': 'the coordinates when the initial patch of fire will be created.', 'size': 'a float value indicating the size of the initial patch of fire. It will also make the fire to stay alive more or less time.'}, result="Returns ''true'' if successful, ''false'' if bad arguments were passed or the limit of active fires was reached. There can be a maximum of 60 active fires."), oop=None, url=FunctionUrl(url='/wiki/CreateFire', name='createFire', category='Fire functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='extinguishFire', return_types=['bool'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='radius', argument_type='float', default_value='1.0', optional=True)]), docs=FunctionDoc(description='', arguments={'x, y, z': 'the coordinates at which any fire will be extinguished.', 'radius': 'a float value indicating the radius in which to extinguish fire.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ExtinguishFire', name='extinguishFire', category='Fire functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiBringToFront', return_types=['bool'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function brings a GUI element on top of others.', arguments={'guiElement': 'the GUI element that you want to move to the front.'}, result="Returns ''true'' if the function was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiElement', method_name='bringToFront', field=None), url=FunctionUrl(url='/wiki/GuiBringToFront', name='guiBringToFront', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getChatboxLayout', return_types=['bool/int/table'], arguments=[FunctionArgument(name='CVar', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="Returns information about how the chatbox looks.\nThese values come from the file called: [[Chatboxpresets.xml]] but it depends on what type of preset you currently have, which is chosen from your settings in the 'Interface' tab.", arguments={'CVar': 'the name of the property you want returned. Can be the following values:', 'chat_font': '- Returns the chatbox font', 'chat_lines': '- Returns how many lines the chatbox has', 'chat_color': '- Returns the background color of the chatbox', 'chat_text_color': '- Returns the chatbox text color', 'chat_input_color': '- Returns the background color of the chatbox input', 'chat_input_prefix_color': '- Returns the color of the input prefix text', 'chat_input_text_color': '- Returns the color of the text in the chatbox input', 'chat_scale': '- Returns the scale of the text in the chatbox', 'chat_position_offset_x': '- Returns the x position offset setting', 'chat_position_offset_y': '- Returns the y position offset setting', 'chat_position_horizontal': '- Returns the horizontal alignment setting', 'chat_position_vertical': '- Returns the vertical alignment setting', 'chat_text_alignment': '- Returns the text alignment setting', 'chat_width': '- Returns the scale of the background width', 'chat_css_style_text': '- Returns whether text fades out over time', 'chat_css_style_background': '- Returns whether the background fades out over time', 'chat_line_life': '- Returns how long it takes for text to start fading out', 'chat_line_fade_out': '- Returns how long takes for text to fade out', 'chat_use_cegui': '- Returns whether CEGUI is used to render the chatbox', 'text_scale': '- Returns text scale'}, result='*4 numbers if the CVar contains "color"\n*2 numbers if \'\'\'chat_scale\'\'\' was entered\n*1 number if any other CVar was specified\n*a table of all CVar values, if CVar was not specified\n*\'\'false\'\' if an invalid CVar was specified'), oop=None, url=FunctionUrl(url='/wiki/GetChatboxLayout', name='getChatboxLayout', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateFont', return_types=['element'], arguments=[FunctionArgument(name='filepath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='size', argument_type='int', default_value='9', optional=True)]), docs=FunctionDoc(description="This function creates a [[GUI font]] element that can be used in [[guiSetFont]]. Successful font creation is not guaranteed, and may fail due to hardware or memory limitations.\nTo see if creation is likely to fail, use [[dxGetStatus]]. (When '''VideoMemoryFreeForMTA''' is zero, failure ''is'' guaranteed.)", arguments={'filepath': 'the name of the file containing the font', 'size': 'size of the font'}, result="Returns a [[GUI font]] element if successful, ''false'' if invalid arguments were passed to the function, or there is insufficient resources available.\n'''You should always check to see if this function has returned false.'''"), oop=None, url=FunctionUrl(url='/wiki/GuiCreateFont', name='guiCreateFont', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiBlur', return_types=['bool'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'guiElement': 'the GUI element that you want to defocus'}, result="Returns ''true'' if the function was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiElement', method_name='blur', field=None), url=FunctionUrl(url='/wiki/GuiBlur', name='guiBlur', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiFocus', return_types=['bool'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'guiElement': 'the GUI element that you want to focus'}, result="Returns ''true'' if the function was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiElement', method_name='focus', field=None), url=FunctionUrl(url='/wiki/GuiFocus', name='guiFocus', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetAlpha', return_types=['float'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="Alpha represents the transparency of a gui element.  This function allows retrieval of a gui element's current alpha.", arguments={'guiElement': 'The gui element in which you want to retrieve the alpha of.'}, result="This function returns a positive integer in between 0 and 1 of the gui element's current alpha, or false if it could not be retrieved."), oop=FunctionOOP(class_name='GuiElement', method_name='getAlpha', field='alpha'), url=FunctionUrl(url='/wiki/GuiGetAlpha', name='guiGetAlpha', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetCursorType', return_types=['string'], arguments=[]), docs=FunctionDoc(description='This function is used to get the type of the current cursor image.\n}}', arguments={}, result='Returns a string containing the cursor type:\n* \'\'\'"none"\'\'\'            // cursor has no image\n* \'\'\'"arrow"\'\'\'           // default cursor\n* \'\'\'"sizing_ns"\'\'\'       // N-S (up-down) sizing cursor\n* \'\'\'"sizing_ew"\'\'\'       // E-W (left-right) sizing cursor\n* \'\'\'"sizing_nwse"\'\'\'     // NW-SE diagonal sizing cursor\n* \'\'\'"sizing_nesw"\'\'\'     // NE-SW diagonal sizing cursor\n* \'\'\'"sizing_eswe"\'\'\'     // ES-WE horizontal sizing cursor\n* \'\'\'"move"\'\'\'            // move cursor\n* \'\'\'"container_drag"\'\'\'  // drag container cursor (note: not in use)\n* \'\'\'"segment_moving"\'\'\'  // segment moving cursor (note: not in use)\n* \'\'\'"segment_sizing"\'\'\'  // segment sizing cursor (note: not in use)'), oop=FunctionOOP(class_name='GuiElement', method_name='getCursorType', field='cursorType'), url=FunctionUrl(url='/wiki/GuiGetCursorType', name='guiGetCursorType', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetEnabled', return_types=['bool'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function determines if a GUI element is enabled.', arguments={'guiElement': 'the GUI element to be checked.'}, result="Returns ''true'' if the element is enabled, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiElement', method_name='getEnabled', field='enabled'), url=FunctionUrl(url='/wiki/GuiGetEnabled', name='guiGetEnabled', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetFont', return_types=['string,', 'element'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function is used to get the current font that is used to draw text in GUI elements.", arguments={'guiElement': 'element you wish to get the font of.'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\n*'''string''' A string containing the name of the element's current font, or false if the gui element passed to the function is invalid.\n*'''element ''' The custom [[GUI font]] that is used, or nil otherwise"), oop=FunctionOOP(class_name='GuiElement', method_name='getFont', field='font'), url=FunctionUrl(url='/wiki/GuiGetFont', name='guiGetFont', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetInputEnabled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function checks whether user input is focused on the GUI or the game.', arguments={}, result="Returns ''true'' if input is focused on GUI, ''false'' if it's focused on the game."), oop=FunctionOOP(class_name='GuiElement', method_name='isInputEnabled', field='inputEnabled'), url=FunctionUrl(url='/wiki/GuiGetInputEnabled', name='guiGetInputEnabled', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetInputMode', return_types=['string'], arguments=[]), docs=FunctionDoc(description='This function returns the current input mode as set by [[guiSetInputMode]].\nDefault mode is \'\'"allow_binds"\'\'.', arguments={}, result='Returns a string defining the current input mode, potential values are:\n* \'\'\'"allow_binds":\'\'\' binds are enabled, hence using a key such as t in an editbox will still activate the chatbox\n* \'\'\'"no_binds":\'\'\' binds are disabled, hence using a key such as t in an editbox will not activate the chatbox\n* \'\'\'"no_binds_when_editing":\'\'\' binds are always enabled except when an editable editbox or memo has input focus'), oop=FunctionOOP(class_name='GuiElement', method_name='getInputMode', field='inputMode'), url=FunctionUrl(url='/wiki/GuiGetInputMode', name='guiGetInputMode', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetPosition', return_types=['float,', 'float'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows retrieval of a GUI element's current position, relative to its parent.", arguments={'guiElement': 'The gui element of which you wish to retrieve the position.', 'relative': 'A boolean representing whether the position should be relative to the elements parent width, or the number of offset pixels from the parents origin.'}, result="Returns floats representing the ''x'' and ''y'' position of the element, or false if the position could not be retrieved."), oop=FunctionOOP(class_name='GuiElement', method_name='getPosition', field='position'), url=FunctionUrl(url='/wiki/GuiGetPosition', name='guiGetPosition', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetProperties', return_types=['table'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets a list of the CEGUI property names and values of a GUI element. To find out what the different properties mean, check out the [http://static.cegui.org.uk/static/WindowsLookProperties.html CEGUI properties page].', arguments={'guiElement': 'the GUI element you wish to get the properties of.'}, result="If the function succeeds, the return value is a table. Its keys are property names, the corresponding values are the values of the properties (both names and values are always strings). If the function fails, it returns ''false''."), oop=FunctionOOP(class_name='GuiElement', method_name='getProperties', field='properties'), url=FunctionUrl(url='/wiki/GuiGetProperties', name='guiGetProperties', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetProperty', return_types=['string'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the value of a specific CEGUI property of a GUI element. For a list of properties and their meaning, see the [http://static.cegui.org.uk/static/WindowsLookProperties.html CEGUI properties page].', arguments={'guiElement': 'the GUI element you wish to get a property of.', 'property': 'the name of of property you want the value of.'}, result="If the function succeeds, it returns a string with the value of the property. If it fails, it returns ''false''."), oop=FunctionOOP(class_name='GuiElement', method_name='getProperty', field=None), url=FunctionUrl(url='/wiki/GuiGetProperty', name='guiGetProperty', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetScreenSize', return_types=['float', 'float'], arguments=[]), docs=FunctionDoc(description='This function retrieves the local screen size according to the resolution they are using.', arguments={}, result="This returns two floats representing the player's screen resolution, ''width'' and ''height''."), oop=FunctionOOP(class_name='GuiElement', method_name='getScreenSize', field=None), url=FunctionUrl(url='/wiki/GuiGetScreenSize', name='guiGetScreenSize', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetSize', return_types=['float', 'float'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the size of a GUI element.', arguments={'theElement': 'The GUI element to get size of.', 'relative': 'A boolean representing whether the size should be relative to the elements parent width, or an absolute size in pixels.'}, result="Returns the GUI element size ''x'' and ''y'' if the function has been successful, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiElement', method_name='getSize', field=None), url=FunctionUrl(url='/wiki/GuiGetSize', name='guiGetSize', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetText', return_types=['string'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function is used to get the text of GUI elements like edit boxes, labels, buttons etc.", arguments={'guiElement': 'element you wish to get text of.'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns a string containing the requested element's text, or false if the gui element passed to the function is invalid."), oop=FunctionOOP(class_name='GuiElement', method_name='getText', field='text'), url=FunctionUrl(url='/wiki/GuiGetText', name='guiGetText', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetVisible', return_types=['bool'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function determines if a GUI element is visible.', arguments={'guiElement': 'the GUI element to be checked'}, result="Returns ''true'' if the element is visible, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiElement', method_name='getVisible', field='visible'), url=FunctionUrl(url='/wiki/GuiGetVisible', name='guiGetVisible', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiMoveToBack', return_types=['bool'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function moves a GUI element to the very back of all other GUI elements.', arguments={'guiElement': 'the GUI element that you want to move to the back'}, result="Returns ''true'' if the function was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiElement', method_name='moveToBack', field=None), url=FunctionUrl(url='/wiki/GuiMoveToBack', name='guiMoveToBack', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiSetAlpha', return_types=['bool'], arguments=[FunctionArgument(name='guielement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='alpha', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This changes the alpha level (the visibleness/transparency) of a GUI element', arguments={'guiElement': 'the GUI element whose visibility is to be changed', 'alpha': 'The visibility/transparency of the GUI element. Ranges from 0 (fully transparent) to 1 (fully opaque). Default value is 0.80.'}, result="Returns ''true'' if the gui element's alpha was successfully changed, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiElement', method_name='setAlpha', field='alpha'), url=FunctionUrl(url='/wiki/GuiSetAlpha', name='guiSetAlpha', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiSetEnabled', return_types=['bool'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function enables/disables a GUI element. A disabled GUI element can't be used, gets a gray aspect and doesn't receive any events.", arguments={'guiElement': 'the GUI element you wish to enable or disable', 'enabled': 'the new state'}, result="If the function succeeds it returns ''true'', if it fails it returns ''false''."), oop=FunctionOOP(class_name='GuiElement', method_name='setEnabled', field='enabled'), url=FunctionUrl(url='/wiki/GuiSetEnabled', name='guiSetEnabled', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiSetFont', return_types=['bool'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='font', argument_type='mixed', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the font of a [[GUI_widgets|GUI element]] to be used when drawing text.', arguments={'guiElement': 'The GUI element you wish to change the font of', 'font': 'Either a custom GUI font element or the name of a built-in GUI font. See Standard GUI Font Names'}, result="Returns ''true'' if the font has been successfully set on the gui element, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiElement', method_name='setFont', field='font'), url=FunctionUrl(url='/wiki/GuiSetFont', name='guiSetFont', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiSetInputEnabled', return_types=['bool'], arguments=[FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function enables or disables input focus for the GUI.  This means that any keybinds or MTA binds are overidden so that text can be input into an editbox, for example.  In other words, keys such as ''t'' and ''y'' which activate the chatbox are disabled.\n[[guiSetInputMode]] can be used as an extended version of ''guiSetInputEnabled'' since it provides the same functionality with one added feature.\n}}", arguments={'enabled': 'true if input should go to GUI, false if it should go to the game.'}, result="Returns ''true'' if input mode could be changed, ''false'' if invalid parameters are passed."), oop=FunctionOOP(class_name='GuiElement', method_name='setInputEnabled', field='inputEnabled'), url=FunctionUrl(url='/wiki/GuiSetInputEnabled', name='guiSetInputEnabled', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiSetInputMode', return_types=['bool'], arguments=[FunctionArgument(name='mode', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function controls the input mode to define whether or not (and when) keybinds or MTA binds are overridden (disabled) so that text can be input into an editbox, for example.\nThe binds can be either: \n* never disabled (hence using a key such as t in an editbox will still activate the chatbox)\n* always disabled (hence using a key such as t in an editbox will not activate the chatbox)\n* only disabled when actually editing an editbox or a memo (binds are always enabled except when an editbox or memo has input focus)', arguments={'mode': 'a string representing the desired input mode. Accepted values are:', '"allow_binds"': 'binds are enabled, hence using a key such as t in an editbox will still activate the chatbox (default)', '"no_binds"': 'binds are disabled, hence using a key such as t in an editbox will not activate the chatbox', '"no_binds_when_editing"': 'binds are always enabled except when an editable editbox or memo has input focus'}, result="Returns ''true'' if input mode could be changed, ''false'' if invalid parameters are passed."), oop=FunctionOOP(class_name='GuiElement', method_name='setInputMode', field='inputMode'), url=FunctionUrl(url='/wiki/GuiSetInputMode', name='guiSetInputMode', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiSetPosition', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the position of a GUI element.', arguments={'theElement': 'The GUI element to change position for', 'x': 'Position over the X axis', 'y': 'Position over the Y axis', 'relative': 'Bool that indicates if the x/y positions are relative to the elements parent element.'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the position has been successfully set, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiElement', method_name='setPosition', field='position'), url=FunctionUrl(url='/wiki/GuiSetPosition', name='guiSetPosition', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiSetProperty', return_types=['bool'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the value of a specific CEGUI property of a GUI element. For a list of properties and their meaning, see the [http://static.cegui.org.uk/static/WindowsLookProperties.html CEGUI properties page].', arguments={'guiElement': 'the GUI element you wish to get a property of.', 'property': 'the name of of property you want the value of.', 'value': 'the new value for the property.'}, result="If the function succeeds it returns ''true'', if it fails it returns ''false''."), oop=FunctionOOP(class_name='GuiElement', method_name='setProperty', field=None), url=FunctionUrl(url='/wiki/GuiSetProperty', name='guiSetProperty', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiSetSize', return_types=['bool'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the dimensions (size) of a GUI element. It refers to the bounding box size for GUI elements. It does not make GUI elements smaller or larger in appearance.', arguments={'guiElement': 'the GUI element whose visibility is to be changed', 'width': 'The desired width setting for the gui element', 'height': 'The desired height setting for the gui element', 'relative': 'This is whether sizes and positioning are relative.  If this is true, then all x,y,width,height floats must be between 0 and 1, representing sizes relative to the parent.'}, result="Returns ''true'' if the gui element's size was set successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiElement', method_name='setSize', field=None), url=FunctionUrl(url='/wiki/GuiSetSize', name='guiSetSize', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiSetText', return_types=['bool'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='text', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the text of a GUI element.', arguments={'guiElement': 'The GUI element you wish to change the text of', 'text': 'The new text'}, result="Returns ''true'' if text has been successfully set on the gui element, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiElement', method_name='setText', field='text'), url=FunctionUrl(url='/wiki/GuiSetText', name='guiSetText', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiSetVisible', return_types=['bool'], arguments=[FunctionArgument(name='guiElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='state', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the visibility state of a GUI element.', arguments={'guiElement': 'the GUI element whose visibility is to be changed', 'state': 'the new visibility state'}, result="Returns ''true'' if the element's visibility could be changed, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiElement', method_name='setVisible', field='visible'), url=FunctionUrl(url='/wiki/GuiSetVisible', name='guiSetVisible', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isChatBoxInputActive', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function returns whether the ingame chatbox is being used (accepting chatbox input) or not.', arguments={}, result="Returns ''true'' if the chatbox is receiving input, ''false'' if not active."), oop=FunctionOOP(class_name='GuiElement', method_name='isChatBoxInputActive', field='chatBoxInputActive'), url=FunctionUrl(url='/wiki/IsChatBoxInputActive', name='isChatBoxInputActive', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isConsoleActive', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function returns whether the ingame console window is visible or not.', arguments={}, result="Returns ''true'' if the console is visible, ''false'' if not."), oop=FunctionOOP(class_name='GuiElement', method_name='isConsoleActive', field='consoleActive'), url=FunctionUrl(url='/wiki/IsConsoleActive', name='isConsoleActive', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isDebugViewActive', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function returns whether the ingame debug window is visible or not. This is the debugwindow visible using the "debugscript <level>" command.', arguments={}, result="Returns ''true'' if the debug view is visible, ''false'' if not."), oop=FunctionOOP(class_name='GuiElement', method_name='isDebugViewActive', field='debugViewActive'), url=FunctionUrl(url='/wiki/IsDebugViewActive', name='isDebugViewActive', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isMainMenuActive', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function returns whether the user is in the mainmenu or not.', arguments={}, result="Returns ''true'' if the mainmenu is visible, ''false'' if not."), oop=None, url=FunctionUrl(url='/wiki/IsMainMenuActive', name='isMainMenuActive', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isMTAWindowActive', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function returns whether any system windows that take focus are active. This includes:\n* Chatbox input\n* Console window\n* Main menu\n* Transferbox\nTo get the status of the debug view, see [[isDebugViewActive]].', arguments={}, result="Returns ''true'' if the focus is on the MTA window, ''false'' if it isn't."), oop=None, url=FunctionUrl(url='/wiki/IsMTAWindowActive', name='isMTAWindowActive', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isTransferBoxActive', return_types=['bool'], arguments=[]), docs=FunctionDoc(description="This function returns whether the file downloading dialog box is active or not. This appears when a resource is started and the client doesn't have all the files that resource requires the client to have.\nIt's important to note that resources aren't started on the client until they're completely downloaded, so a resource cannot use this function to detect if it's own files are downloaded. A client-side resource triggers the [[onClientResourceStart]] event when the files it requires are downloaded.", arguments={}, result="Returns ''true'' if the file transfer box is visible, ''false'' if not."), oop=FunctionOOP(class_name='GuiElement', method_name='isTransferBoxActive', field=None), url=FunctionUrl(url='/wiki/IsTransferBoxActive', name='isTransferBoxActive', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setDebugViewActive', return_types=['bool'], arguments=[FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function enables or disables the debug window.', arguments={'enabled': 'true if debug window should be visible, false otherwise.'}, result="Returns ''true'', ''false'' if invalid parameters are passed."), oop=FunctionOOP(class_name='GuiElement', method_name='setDebugViewActive', field='debugViewActive'), url=FunctionUrl(url='/wiki/SetDebugViewActive', name='setDebugViewActive', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateBrowser', return_types=['gui-browser'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='isLocal', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='isTransparent', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='isRelative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value='nil', optional=True)]), docs=FunctionDoc(description='This function creates a new CEGUI web [[Element/Browser|browser]] element.\nThe difference between this, and createBrowser is that, this handles inputs internally, and it can be attached to GUI windows. So this one is more suitable for custom dx based interfaces.\nYou can learn more about the differences [https://forum.mtasa.com/topic/80422-dx-browser-vs-gui-browser/?do=findComment&comment=737334 here].\n}}', arguments={'x': 'A float of the 2D x position of the browser on a players screen.  This is affected by the relative argument.', 'y': 'A float of the 2D y position of the browser on a players screen. This is affected by the relative argument.', 'width': 'The browsers native width. This should be greater than or equal to 1.', 'height': 'The browsers native height. This should be greater than or equal to 1.', 'isLocal': 'Sets whether the browser can only show local content or content from the internet (see examples over CreateBrowser|here for more information)', 'isTransparent': 'true if you want the browser to support transparency, false otherwise', 'isRelative': 'This is whether sizes and positioning are relative.  If this is true, then all x,y,width,height floats must be between 0 and 1, representing sizes/positions as a fraction of the screen size. If false, then the size and co-ordinates are based on clients resolution, accessible using guiGetScreenSize.\n{{New feature/item|3.0160|1.6||Providing a size of (0,0) will be a hard error.}}', 'parent': 'This is the parent that the radio button is attached to. If the relative argument is true, sizes and positioning will be made relative to this parent. If the relative argument is false, positioning will be the number of offset pixels from the parents origin. If no parent is passed, the parent will become the screen - causing positioning and sizing according to screen positioning.'}, result="Returns a [[gui-browser]] element if it was created successfully, ''false'' otherwise. Returns also ''false'', if the user disabled remote pages and ''isLocal'' was set to ''false''."), oop=None, url=FunctionUrl(url='/wiki/GuiCreateBrowser', name='guiCreateBrowser', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetBrowser', return_types=['browser'], arguments=[FunctionArgument(name='browser', argument_type='gui', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the browser element behind a gui-browser (a browser that has been created via [[guiCreateBrowser]]).\n}}', arguments={'theBrowser': 'The gui-browser'}, result="Returns the [[Element/Browser|Browser]] element if a correct [[Element/gui-browser|gui-browser]] has been passed, ''false'' otherwise."), oop=FunctionOOP(class_name='guiBrowser', method_name='getBrowser', field='browser'), url=FunctionUrl(url='/wiki/GuiGetBrowser', name='guiGetBrowser', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateButton', return_types=['element'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value='nil', optional=False)]), docs=FunctionDoc(description='This function allows creation of a GUI Button, which is a clickable item as part of GUI.', arguments={'x': 'A float of the 2D x position of the GUI button on a players screen.  This is affected by the relative argument.', 'y': 'A float of the 2D y position of the GUI button on a players screen. This is affected by the relative argument.', 'width': 'A float of the width of the GUI button. This is affected by the relative argument.', 'height': 'A float of the height of the GUI button. This is affected by the relative argument.', 'text': 'A string of the text that will be displayed as a label on the button.', 'relative': 'This is whether sizes and positioning are relative.  If this is true, then all x, y, width and height floats must be between 0 and 1, representing sizes relative to the parent.\n{{OptionalArg}} ', 'parent': 'This is the parent that the gui button is attached to.  If the relative argument is true, sizes and positioning will be made relative to this parent. If the relative argument is false, positioning will be the number of offset pixels from the parents origin. If no parent is passed, the parent will become the screen - causing positioning and sizing according to screen positioning.'}, result='Returns an [[element]] of the created [[Element/GUI/Button|button]] if it was successfully created, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/GuiCreateButton', name='guiCreateButton', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCheckBoxGetSelected', return_types=['bool'], arguments=[FunctionArgument(name='theCheckbox', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets a checkbox's selection state.", arguments={'theCheckbox ': 'The checkbox you wish to retrieve the selection state of.'}, result="Returns ''true'' if the checkbox is selected, ''false'' if it is not."), oop=FunctionOOP(class_name='GuiCheckBox', method_name='getSelected', field='selected'), url=FunctionUrl(url='/wiki/GuiCheckBoxGetSelected', name='guiCheckBoxGetSelected', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCheckBoxSetSelected', return_types=['bool'], arguments=[FunctionArgument(name='theCheckbox', argument_type='element', default_value=None, optional=False), FunctionArgument(name='state', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function selects (ticks) or unselects a checkbox.', arguments={'theCheckbox': 'The GUI element in which you wish to change the selection state of', 'state': 'The state of the checkbox, where true indicates selected, and false indicates unselected.'}, result="Returns ''true'' if the checkbox's selection state was successfully set, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiCheckBox', method_name='setSelected', field='selected'), url=FunctionUrl(url='/wiki/GuiCheckBoxSetSelected', name='guiCheckBoxSetSelected', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateCheckBox', return_types=['element'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='selected', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value='nil', optional=False)]), docs=FunctionDoc(description='This function creates a [[Element/GUI/Checkbox|checkbox]].', arguments={'x': 'A float of the 2D x position of the checkbox on a players screen. This is affected by the relative argument.', 'y': 'A float of the 2D y position of the checkbox on a players screen. This is affected by the relative argument.', 'width': 'A float of the width of the text field next to the checkbox. This is affected by the relative argument.', 'height': 'A float of the height of the text field next to the checkbox. This is affected by the relative argument.', 'text': 'The text to be displayed next to the checkbox.', 'selected': 'A boolean representing whether the checkbox created should be selected by default.', 'relative': 'This is whether sizes and positioning are relative. If this is true, then all x,y,width,height floats must be between 0 and 1, representing measures relative to the parent.\n{{OptionalArg}} ', 'parent': 'This is the parent that the checkbox is attached to. If the relative argument is true, sizes and positioning will be made relative to this parent. If the relative argument is false, positioning will be the number of offset pixels from the parents origin. If no parent is passed, the parent will become the screen - causing positioning and sizing according to screen positioning.'}, result="Returns [[element]] of the checkbox if it was created succesfully, ''false'' otherwise. "), oop=None, url=FunctionUrl(url='/wiki/GuiCreateCheckBox', name='guiCreateCheckBox', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateComboBox', return_types=['element'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='caption', argument_type='string', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value='nil', optional=False)]), docs=FunctionDoc(description='This function creates a combobox GUI element, which you can compare to a gridlist with a dropdown feature.', arguments={'x': 'A float of the 2D x position of the GUI combobox on a players screen.  This is affected by the relative argument.', 'y': 'A float of the 2D y position of the GUI combobox on a players screen. This is affected by the relative argument.', 'width': 'A float of the width of the GUI combobox. This is affected by the relative argument.', 'height': 'A float of the height of the GUI combobox. This is affected by the relative argument. Note: height must be enough to fit the drop down menu, else the drop down wont appear.', 'caption': 'A string for what the title of your combobox will be. This will be shown if no item is selected.', 'relative': 'This is whether sizes and positioning are relative.  If this is true, then all x,y,width,height floats must be between 0 and 1, representing sizes relative to the parent.\n{{OptionalArg}} ', 'parent': 'This is the parent that the GUI combobox is attached to.  If the relative argument is true, sizes and positioning will be made relative to this parent. If the relative argument is false, positioning will be the number of offset pixels from the parents origin. If no parent is passed, the parent will become the screen - causing positioning and sizing according to screen positioning.'}, result='Returns an element of the created combobox if it was successfully created, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/GuiCreateComboBox', name='guiCreateComboBox', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiComboBoxAddItem', return_types=['int'], arguments=[FunctionArgument(name='comboBox', argument_type='element', default_value=None, optional=False), FunctionArgument(name='value', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Adds an item to a combobox.', arguments={'comboBox': 'The combobox you want to add a row to', 'value': 'The text that the item will contain.'}, result="Returns the item ID if it has been created, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiComboBoxAddItem', name='guiComboBoxAddItem', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiComboBoxClear', return_types=['bool'], arguments=[FunctionArgument(name='comboBox', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function removes all the items from a combobox.', arguments={'comboBox': 'The combobox element to be cleared'}, result="Returns ''true'' if the combobox element is valid and has been cleared successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiComboBoxClear', name='guiComboBoxClear', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiComboBoxGetItemCount', return_types=['int'], arguments=[FunctionArgument(name='comboBox', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'comboBox': 'The combo box to get the number of items from.'}, result="Returns the number of items if the function is successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiComboBoxGetItemCount', name='guiComboBoxGetItemCount', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiComboBoxGetItemText', return_types=['string'], arguments=[FunctionArgument(name='comboBox', argument_type='element', default_value=None, optional=False), FunctionArgument(name='itemId', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the text from a specific combobox item.', arguments={'comboBox': 'The combobox containing the item youre interested in', 'itemId': 'The index of the item'}, result="Returns the text of the item if the arguments are right, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiComboBoxGetItemText', name='guiComboBoxGetItemText', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiComboBoxGetSelected', return_types=['int'], arguments=[FunctionArgument(name='comboBox', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the index of the selected combobox item.', arguments={'comboBox': 'the combobox you want to know the selected item index of'}, result="Returns the index of the selected item if the specified combobox is valid and has a selected item, ''-1'' if no item is selected, ''nil'' otherwise."), oop=FunctionOOP(class_name='GuiComboBox', method_name='getSelected', field='selected'), url=FunctionUrl(url='/wiki/GuiComboBoxGetSelected', name='guiComboBoxGetSelected', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiComboBoxIsOpen', return_types=['bool'], arguments=[FunctionArgument(name='comboBox', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'comboBox': 'The combo box to get the state.'}, result="Returns ''true'' if combobox is opened, ''false'' if combobox is closed, ''nil'' otherwise."), oop=FunctionOOP(class_name='GuiComboBox', method_name='isOpen', field='open'), url=FunctionUrl(url='/wiki/GuiComboBoxIsOpen', name='guiComboBoxIsOpen', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiComboBoxRemoveItem', return_types=['bool'], arguments=[FunctionArgument(name='comboBox', argument_type='element', default_value=None, optional=False), FunctionArgument(name='itemId', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function removes an item from a combobox.', arguments={'comboBox': 'The combobox containing the item youre interested in', 'itemId': 'The index of the item to remove'}, result="Returns ''true'' if the item was removes successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiComboBoxRemoveItem', name='guiComboBoxRemoveItem', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiComboBoxSetItemText', return_types=['bool'], arguments=[FunctionArgument(name='comboBox', argument_type='element', default_value=None, optional=False), FunctionArgument(name='itemId', argument_type='int', default_value=None, optional=False), FunctionArgument(name='text', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the text of a combobox item.', arguments={'comboBox': 'The combobox containing the item youre interested in', 'itemId': 'The index of the item', 'text': 'The text you want to put in (does NOT accept numbers, use tostring() for that)'}, result="Returns ''true'' if the text was set successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiComboBoxSetItemText', name='guiComboBoxSetItemText', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiComboBoxSetOpen', return_types=['bool'], arguments=[FunctionArgument(name='comboBox', argument_type='element', default_value=None, optional=False), FunctionArgument(name='state', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'comboBox': 'The combobox to be opened or closed.', 'state': 'The state of combobox. true, if the combobox is to be opened. false if the combobox is to be closed.'}, result="Returns true if is successful, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiComboBox', method_name='setOpen', field='open'), url=FunctionUrl(url='/wiki/GuiComboBoxSetOpen', name='guiComboBoxSetOpen', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiComboBoxSetSelected', return_types=['bool'], arguments=[FunctionArgument(name='comboBox', argument_type='element', default_value=None, optional=False), FunctionArgument(name='itemIndex', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the selected item from a combobox.', arguments={'comboBox': 'the combobox you want to select an item from', 'itemIndex': 'the item you want to select (item 0 is the first item). If -1 is specified, then the combo box text is set to its caption.'}, result="Returns ''true'' if the selected item has been changed successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiComboBox', method_name='setSelected', field='selected'), url=FunctionUrl(url='/wiki/GuiComboBoxSetSelected', name='guiComboBoxSetSelected', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateEdit', return_types=['element'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value='nil', optional=True)]), docs=FunctionDoc(description='[[Image:Gui-edit.png|frame|Example GUI edit field.]]\nThis function is for creating a new GUI edit box. This is a text box in which the user can input text. Edit boxes only allow a single line of text. If you want to allow multiple lines of text create a memo box using [[guiCreateMemo]].', arguments={'x': 'A float of the 2D x position of the GUI edit box on a players screen.  This is affected by the relative argument.', 'y': 'A float of the 2D y position of the GUI edit box on a players screen. This is affected by the relative argument.', 'width': 'A float of the width of the GUI edit box. This is affected by the relative argument.', 'height': 'A float of the height of the GUI edit box. This is affected by the relative argument.', 'text': 'A string of the text that will be displayed by default in the edit box.', 'relative': 'This is whether sizes and positioning are relative.  If this is true, then all x,y,width,height floats must be between 0 and 1, representing measures relative to the parent.\n{{OptionalArg}} ', 'parent': 'This is the parent that the GUI edit box is attached to.  If the relative argument is true, sizes and positioning will be made relative to this parent. If the relative argument is false, positioning will be the number of offset pixels from the parents origin. If no parent is passed, the parent will become the screen - causing positioning and sizing according to screen positioning.'}, result='Returns a gui-edit element of the created edit box if it was successfully created, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/GuiCreateEdit', name='guiCreateEdit', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiEditGetCaretIndex', return_types=['int'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the caret (the text cursor) position within the editbox.\n}}', arguments={'theElement': 'The edit box you want to get the caret position from'}, result="Returns the caret index on success, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiEdit', method_name='getCaretIndex', field='caretIndex'), url=FunctionUrl(url='/wiki/GuiEditGetCaretIndex', name='guiEditGetCaretIndex', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiEditGetMaxLength', return_types=['int'], arguments=[FunctionArgument(name='edit', argument_type='gui', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'guiEdit': 'The edit box you want to get the maximum text length of.'}, result="Returns the maximum text length on success, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiEdit', method_name='getMaxLength', field='maxLength'), url=FunctionUrl(url='/wiki/GuiEditGetMaxLength', name='guiEditGetMaxLength', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiEditIsMasked', return_types=['bool'], arguments=[FunctionArgument(name='edit', argument_type='gui', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'guiEdit': 'the edit box to check masked flag of.'}, result="Returns ''true'' if the edit box is masked, ''false'' if not, ''nil'' if an invalid edit box was provided."), oop=None, url=FunctionUrl(url='/wiki/GuiEditIsMasked', name='guiEditIsMasked', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiEditIsReadOnly', return_types=['bool'], arguments=[FunctionArgument(name='edit', argument_type='gui', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'guiEdit': 'The edit box to check read-only status of.'}, result="Returns ''true'' if the edit box is read-only, ''false'' if not, ''nil'' if an invalid edit box was provided."), oop=None, url=FunctionUrl(url='/wiki/GuiEditIsReadOnly', name='guiEditIsReadOnly', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiEditSetCaretIndex', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the current position of the caret (the text cursor) within the edit box.', arguments={'theElement': 'The edit box to be changed.', 'index': 'An integer referring to the desired position within the box.'}, result="Returns ''true'' if the index was successfully set, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiEdit', method_name='setCaretIndex', field='caretIndex'), url=FunctionUrl(url='/wiki/GuiEditSetCaretIndex', name='guiEditSetCaretIndex', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiEditSetMasked', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='status', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets or removes masking (covering up the text being typed) for password text fields.', arguments={'theElement': 'The edit box to be changed.', 'status': 'A boolean value indicating whether masking is to be enabled or disabled.'}, result="Returns ''true'' if the function is successful, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiEdit', method_name='setMasked', field='masked'), url=FunctionUrl(url='/wiki/GuiEditSetMasked', name='guiEditSetMasked', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiEditSetMaxLength', return_types=['bool'], arguments=[FunctionArgument(name='guiEdit', argument_type='element', default_value=None, optional=False), FunctionArgument(name='length', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the maximum text length that can be typed into an edit box.', arguments={'theElement': 'The edit box to be changed.', 'length': 'An integer indicating the maximum number of characters that can be typed into the box.'}, result="Returns ''true'' if the max length was set successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiEdit', method_name='setMaxLength', field='maxLength'), url=FunctionUrl(url='/wiki/GuiEditSetMaxLength', name='guiEditSetMaxLength', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiEditSetReadOnly', return_types=['bool'], arguments=[FunctionArgument(name='editField', argument_type='element', default_value=None, optional=False), FunctionArgument(name='status', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows you to set or remove read-only status for an edit box. If read-only is set to ''true'', the box is not editable.", arguments={'editField': 'The element of the Element/GUI/Edit field|edit field to be modified.', 'status': 'A boolean value indicating whether read-only is to be enabled or disabled.'}, result="Returns ''true'' if edit field's read-only status was changed successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiEdit', method_name='setReadOnly', field='readOnly'), url=FunctionUrl(url='/wiki/GuiEditSetReadOnly', name='guiEditSetReadOnly', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateGridList', return_types=['element'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value='nil', optional=False)]), docs=FunctionDoc(description="This function creates a grid list GUI element.  These are menu's which are designed in lists and can have multiple columns.  A good example of a gridlist element can be found in MTA's settings box, under ''Controls''.", arguments={'x': 'A float of the 2D x position of the GUI gridlist on a players screen.  This is affected by the relative argument.', 'y': 'A float of the 2D y position of the GUI gridlist on a players screen. This is affected by the relative argument.', 'width': 'A float of the width of the GUI gridlist. This is affected by the relative argument.', 'height': 'A float of the height of the GUI gridlist. This is affected by the relative argument.', 'relative': 'This is whether sizes and positioning are relative.  If this is true, then all x,y,width,height floats must be between 0 and 1, representing sizes relative to the parent.\n{{OptionalArg}} ', 'parent': 'This is the parent that the gui gridlist is attached to.  If the relative argument is true, sizes and positioning will be made relative to this parent. If the relative argument is false, positioning will be the number of offset pixels from the parents origin. If no parent is passed, the parent will become the screen - causing positioning and sizing according to screen positioning.'}, result='Returns an element of the created gridlist if it was successfully created, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/GuiCreateGridList', name='guiCreateGridList', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListAddColumn', return_types=['int'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='title', argument_type='string', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to create columns in grid lists.', arguments={'gridList': 'The grid list you want to add a column to', 'title': 'Title of the column', 'width': 'Column width, relative to the grid list width'}, result="Returns the column id if it was created, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiGridListAddColumn', name='guiGridListAddColumn', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListAddRow', return_types=['int'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='string', argument_type='int', default_value=None, optional=True), FunctionArgument(name='string', argument_type='int', default_value=None, optional=True), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description="Adds a row to a grid list, and optionally add simple text items with your rows.  Use [[guiGridListSetItemText]] to add row headers.\nATTENTION: Without [[guiGridListSetItemText]] there is no row added to the grid. \nLook at the example, first you give the row a name with '''[[row =]]''' guiGridListAddRow ( playerList ), and then you use [[guiGridListSetItemText]]. }}", arguments={'gridList': 'The grid list you want to add a row to\n{{New feature/item|3.0153|1.5.3||', 'itemText1': 'The text for the first column item in the row.  Either a string or a number can be passed (use numbers for sorting purposes).', 'itemText2': 'The text for the second column item in the row.  Either a string or a number can be passed (use numbers for sorting purposes).', '...': 'Item text for any other columns\n}}'}, result="Returns the row id if it has been created, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiGridList', method_name="addRow}}\n\n===Required Arguments=== \n*'''gridList:''' The grid list you want to add a row to\n\n===Optional Arguments===\n{{New feature/item", field='3.0153'), url=FunctionUrl(url='/wiki/GuiGridListAddRow', name='guiGridListAddRow', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListAutoSizeColumn', return_types=['bool'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='columnIndex', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis allows you to automatically size a column to display everything in it correctly, with the most minimal width.", arguments={'gridList': 'The Element/GUI/Gridlist|grid list element where the column is located.', 'columnIndex': 'The ID of the column you want to be auto-sized.'}, result="Returns ''true'' if the column was auto-sized, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiGridList', method_name="autoSizeColumn}}\n\n===Required Arguments=== \n<!-- List each argument one per line. This should be the argument's name as in the argument list above, NOT the argument's data type -->\n*'''gridList:''' The [[Element/GUI/Gridlist", field="grid list]] element where the column is located.\n*'''columnIndex:''' The ID of the column you want to be auto-sized.\n\n===Returns===\nReturns ''true'' if the column was auto-sized, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/GuiGridListAutoSizeColumn', name='guiGridListAutoSizeColumn', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListClear', return_types=['bool'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function clears all the data from a grid list.', arguments={'gridList': 'The grid list element to be cleared'}, result="Returns ''true'' if the grid list element is valid and has been cleared successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiGridListClear', name='guiGridListClear', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListGetColumnCount', return_types=['int'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This allows you to get the count of existing columns in a gridlist.', arguments={'gridList': 'The grid list you want to add a column to'}, result='Returns an integer with the amount of columns in the gridlist, false otherwise.'), oop=FunctionOOP(class_name='GuiGridList', method_name='getColumnCount', field="columnCount}}\n\n===Required Arguments=== \n*'''gridList:''' The grid list you want to add a column to\n\n===Returns===\nReturns an integer with the amount of columns in the gridlist, false otherwise.\n\n"), url=FunctionUrl(url='/wiki/GuiGridListGetColumnCount', name='guiGridListGetColumnCount', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListGetColumnTitle', return_types=['string'], arguments=[FunctionArgument(name='guiGridlist', argument_type='element', default_value=None, optional=False), FunctionArgument(name='columnIndex', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the column title of a gridlist column.', arguments={'guiGridlist': ': The grid list you want to get the column title from', 'columnIndex': ': Column ID'}, result="Returns a string containing the column title, or ''false'' otherwise."), oop=FunctionOOP(class_name='GuiGridList', method_name="getColumnTitle}}\n\n===Required Arguments===\n*'''guiGridlist''': The grid list you want to get the column title from\n*'''columnIndex''': Column ID\n\n===Returns===\nReturns a string containing the column title, or ''false'' otherwise.\n\n==Requirements==\n{{Requirements", field='n/a'), url=FunctionUrl(url='/wiki/GuiGridListGetColumnTitle', name='guiGridListGetColumnTitle', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListGetColumnWidth', return_types=['float'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='columnIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This allows you to get the width of an existing column in a gridlist.', arguments={'gridList': 'The grid list you want to add a column to', 'columnIndex': 'Column ID of the Get size', 'relative': 'A boolean defining whether width measurements will be relative to the Gridlist size, or absolute pixels.'}, result="Returns the width of the gridlist column, ''false'' if bad arguments were given."), oop=None, url=FunctionUrl(url='/wiki/GuiGridListGetColumnWidth', name='guiGridListGetColumnWidth', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListGetHorizontalScrollPosition', return_types=['float'], arguments=[FunctionArgument(name='guiGridlist', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the horizontal scroll position from a grid list', arguments={'guiGridlist': ': The grid list you want to get the horizontal scroll position from'}, result="Returns a integer between 0 and 100 indicating the horizontal scroll position, or ''false'' otherwise."), oop=FunctionOOP(class_name='GuiGridList', method_name='getHorizontalScrollPosition', field='horizontalScrollPosition'), url=FunctionUrl(url='/wiki/GuiGridListGetHorizontalScrollPosition', name='guiGridListGetHorizontalScrollPosition', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListGetItemColor', return_types=['int', 'int', 'int', 'int'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rowIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='columnIndex', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the color of a gridlist item.', arguments={'gridList': 'The grid list element', 'rowIndex': 'Row ID', 'columnIndex': 'Column ID'}, result="Returns four ''int'' values, representing the amount of red, green, blue and alpha if successful. ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiGridListGetItemColor', name='guiGridListGetItemColor', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListGetItemData', return_types=['var'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rowIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='columnIndex', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="With this function you can retrieve the [[string]] data associated with an item in a [[Element/GUI/Gridlist|grid list]]. This is not the text that is displayed on the item, but an internal string that you can use to hold extra information about the item.<br/>\n'''Note:''' This function will only work '''after''' you set the item's text using [[guiGridListSetItemText]]!", arguments={'gridList': 'the grid list containing the item youre interested in', 'rowIndex': 'the row index of the item', 'columnIndex': 'the column index of the item'}, result="Returns the item data of the specified item if succesful, ''false'' if one of the arguments was invalid."), oop=None, url=FunctionUrl(url='/wiki/GuiGridListGetItemData', name='guiGridListGetItemData', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListGetItemText', return_types=['string'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rowIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='columnIndex', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the text from a specific grid list item.', arguments={'gridList': 'the gridlist containing the item youre interested in', 'rowIndex': 'row id of the item', 'columnIndex': 'column id of the item'}, result="Returns the text of the item if the arguments are right, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiGridListGetItemText', name='guiGridListGetItemText', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListGetRowCount', return_types=['int'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the number of rows in a grid list.', arguments={'gridList': 'The grid list to get the number of rows from.'}, result="Returns the number of rows if the function is successful, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiGridList', method_name='getRowCount', field="rowCount}}\n\n===Required Arguments=== \n*'''gridList:''' The grid list to get the number of rows from.\n\n===Returns===\nReturns the number of rows if the function is successful, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/GuiGridListGetRowCount', name='guiGridListGetRowCount', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListGetSelectedCount', return_types=['int'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the amount of options selected in the specified [[Element/GUI/Gridlist|grid list]].', arguments={'gridList': 'The Element/GUI/Gridlist|grid list which amount of selected items you want to retrieve.'}, result="Returns an [[int]]eger representing the amount of selected options if everything was successful or ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='GuiGridList', method_name='getSelectedCount', field="selectedCount}}\n\n===Required Arguments=== \n*'''gridList:''' The [[Element/GUI/Gridlist"), url=FunctionUrl(url='/wiki/GuiGridListGetSelectedCount', name='guiGridListGetSelectedCount', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListGetSelectedItem', return_types=['int,', 'int'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the row and column indexes of the selected item in a grid list. First selected row and column is (0, 0).', arguments={'gridList': 'the grid list you want to know the selected row index of'}, result="Returns the row and column indexes of the selected item if the specified grid list is valid and has a selected item, (-1, -1) if no item is selected, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiGridListGetSelectedItem', name='guiGridListGetSelectedItem', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListGetSelectedItems', return_types=['table'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the items selected in the specified [[Element/GUI/Gridlist|grid list]].\nNote that for some reason the column ID is 1 lower than it should be, for example 0 is returned but if you try and get the text for column 0 there is nothing, but column 1 has what you clicked on.', arguments={'gridList': 'The Element/GUI/Gridlist|grid list which selected items you want to retrieve.'}, result='Returns a table over the selected items in the [[Element/GUI/Gridlist|grid list]] in this format:\n<syntaxhighlight lang="lua">\ntable = {\n    [1] = {\n        ["column"], -- has the first selected item\'s column ID\n        ["row"] -- has the first selected item\'s row ID\n    },\n    [2] = {\n        ["column"],-- has the second selected item\'s column ID\n        ["row"] -- has the second selected item\'s row ID\n    },\n    ...\n}\n</syntaxhighlight>\nif everything was successful or \'\'false\'\' if invalid arguments were passed.'), oop=FunctionOOP(class_name='GuiGridList', method_name='getSelectedItems', field="selectedItems}}\n\n===Required Arguments=== \n*'''gridList:''' The [[Element/GUI/Gridlist"), url=FunctionUrl(url='/wiki/GuiGridListGetSelectedItems', name='guiGridListGetSelectedItems', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListGetSelectionMode', return_types=['int'], arguments=[FunctionArgument(name='Element', argument_type='gui', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'gridlist': 'The gridlist you want to get the selection mode of.'}, result="Returns the ID of the current gridlist's selection mode.\n{{GUI_gridList_selection_modes_IDs}}"), oop=FunctionOOP(class_name='GuiGridList', method_name='getSelectionMode', field="selectionMode}}\n\n===Required Arguments=== \n*'''gridlist:''' The gridlist you want to get the selection mode of.\n\n===Returns===\nReturns the ID of the current gridlist's selection mode.\n{{GUI_gridList_selection_modes_IDs}}\n\n"), url=FunctionUrl(url='/wiki/GuiGridListGetSelectionMode', name='guiGridListGetSelectionMode', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListIsSortingEnabled', return_types=['bool'], arguments=[FunctionArgument(name='guiGridlist', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'guiGridlist': 'The GUI gridlist you wish to check if sorting is enabled or not.'}, result="Returns ''true'' if sorting is enabled, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiGridList', method_name='isSortingEnabled', field="sortingEnabled}}\n\n===Required Arguments=== \n*'''guiGridlist:''' The GUI gridlist you wish to check if sorting is enabled or not.\n\n===Returns===\nReturns ''true'' if sorting is enabled, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/GuiGridListIsSortingEnabled', name='guiGridListIsSortingEnabled', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListGetVerticalScrollPosition', return_types=['float'], arguments=[FunctionArgument(name='guiGridlist', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the vertical scroll position from a grid list', arguments={'guiGridlist': ': The grid list you want to get the vertical scroll position from'}, result="Returns a integer between 0 and 100 indicating the vertical scroll position, or ''false'' otherwise."), oop=FunctionOOP(class_name='GuiGridList', method_name='getVerticalScrollPosition', field='verticalScrollPosition'), url=FunctionUrl(url='/wiki/GuiGridListGetVerticalScrollPosition', name='guiGridListGetVerticalScrollPosition', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListInsertRowAfter', return_types=['int'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rowIndex', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This allows you to insert a new row after a specified row, and simultaneously set text. Good for inserting new rows in the middle of existing rows. To insert at the top use -1 as row index.', arguments={'gridList': 'The grid list you want to add a row to', 'rowIndex': 'Row ID of the row you want to insert the new row after.\n{{New feature/item|3.0153|1.5.3||', 'itemText1': 'The text for the first column item in the row.  Either a string or a number can be passed (use numbers for sorting purposes).', 'itemText2': 'The text for the second column item in the row.  Either a string or a number can be passed (use numbers for sorting purposes).', '...': 'Item text for any other columns\n}}'}, result="Returns ''true'' if the row was successfully added, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiGridList', method_name="insertRowAfter}}\n\n===Required Arguments=== \n*'''gridList:''' The grid list you want to add a row to\n*'''rowIndex:''' Row ID of the row you want to insert the '''new row''' after.\n\n===Optional Arguments===\n{{New feature/item", field='3.0153'), url=FunctionUrl(url='/wiki/GuiGridListInsertRowAfter', name='guiGridListInsertRowAfter', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListRemoveColumn', return_types=['bool'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='columnIndex', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This allows you to delete columns that exist in grid lists.', arguments={'gridList': 'The grid list you want to remove a column from', 'columnIndex': 'Column ID'}, result="Returns ''true'' if the grid list column was successfully removed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiGridListRemoveColumn', name='guiGridListRemoveColumn', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListRemoveRow', return_types=['bool'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rowIndex', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This allows you to delete rows that exist in grid lists.', arguments={'gridList': 'The grid list you want to remove a row from', 'rowIndex': 'The row ID which you want to remove'}, result="Returns ''true'' if the grid list row was successfully removed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiGridListRemoveRow', name='guiGridListRemoveRow', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListSetColumnTitle', return_types=['bool'], arguments=[FunctionArgument(name='guiGridlist', argument_type='element', default_value=None, optional=False), FunctionArgument(name='columnIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='title', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to change the column title of a gridlist column.', arguments={'guiGridlist': ': The grid list you want to change the column title from', 'columnIndex': ': Column ID', 'title': ': The title of the column'}, result="Returns ''true'' if the new title was set, or ''false'' otherwise."), oop=FunctionOOP(class_name='GuiGridList', method_name="setColumnTitle}}\n\n===Required Arguments===\n*'''guiGridlist''': The grid list you want to change the column title from\n*'''columnIndex''': Column ID\n*'''title''': The title of the column\n\n===Returns===\nReturns ''true'' if the new title was set, or ''false'' otherwise.\n\n==Requirements==\n{{Requirements", field='n/a'), url=FunctionUrl(url='/wiki/GuiGridListSetColumnTitle', name='guiGridListSetColumnTitle', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListSetColumnWidth', return_types=['bool'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='columnIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='width', argument_type='number', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This allows you to set the width of an existing column in a gridlist.', arguments={'gridList': 'The grid list you want to add a column to', 'columnIndex': 'Column ID of the size you want to change', 'width': 'A float or integer of the width of the column depending on the relative argument.', 'relative': 'A boolean defining whether width measurements will be relative to the Gridlist size, or absolute pixels.'}, result="Returns ''true'' if the gridlist column width was successfully set, ''false'' if bad arguments were given."), oop=None, url=FunctionUrl(url='/wiki/GuiGridListSetColumnWidth', name='guiGridListSetColumnWidth', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListSetHorizontalScrollPosition', return_types=['bool'], arguments=[FunctionArgument(name='guiGridlist', argument_type='element', default_value=None, optional=False), FunctionArgument(name='fPosition', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the horizontal scroll position from a grid list', arguments={'guiGridlist': ': The grid list you want to set the horizontal scroll position from', 'fPosition': ': A float representing the horizontal scroll position (0-100)'}, result="Returns ''true'' if the horizontal scroll position was set, or ''false'' otherwise."), oop=FunctionOOP(class_name='GuiGridList', method_name='setHorizontalScrollPosition', field='horizontalScrollPosition'), url=FunctionUrl(url='/wiki/GuiGridListSetHorizontalScrollPosition', name='guiGridListSetHorizontalScrollPosition', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListSetItemColor', return_types=['bool'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rowIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='columnIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='red', argument_type='int', default_value=None, optional=False), FunctionArgument(name='green', argument_type='int', default_value=None, optional=False), FunctionArgument(name='blue', argument_type='int', default_value=None, optional=False), FunctionArgument(name='alpha', argument_type='int', default_value='255', optional=True)]), docs=FunctionDoc(description='This function changes the color of a gridlist item.', arguments={'gridList': 'The grid list element', 'rowIndex': 'Row ID', 'columnIndex': 'Column ID', 'red': 'The amount of red in the color (0-255)', 'green': 'The amount of green in the color (0-255)', 'blue': 'The amount of blue in the color (0-255)', 'alpha': 'The amount of alpha in the color (0-255).'}, result="Returns ''true'' if the item color was set successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiGridListSetItemColor', name='guiGridListSetItemColor', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListSetItemData', return_types=['bool'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rowIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='columnIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='data', argument_type='var', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets a Item Data associated to a grid list item.<br/>\n'''Note:''' This function will only work '''after''' you set the item's text using [[guiGridListSetItemText]]!", arguments={'gridList': 'A gridlist element of the data you wish to set to', 'rowIndex': 'The row of the item you wish to set to', 'columnIndex': 'The column of the item you wish to set to', 'data': 'The data you wish to set to the item.'}, result="Returns ''true'' if the data was set successfully, false otherwise"), oop=None, url=FunctionUrl(url='/wiki/GuiGridListSetItemData', name='guiGridListSetItemData', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListSetItemText', return_types=['bool'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rowIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='columnIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='section', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='number', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function changes the text of a gridlist item.\nNotice: This function doesn't work well with Sorting. If you are using sorting, please use the optional arguments of [[guiGridListAddRow]] as much as possible.", arguments={'gridList': 'The grid list element', 'rowIndex': 'Row ID', 'columnIndex': 'Column ID', 'text': 'The text you want to put in (does NOT accept numbers, use tostring() for that)', 'section': 'Determines if the item is a section', 'number': 'Tells whether the text item is a number value or not (used for sorting)'}, result="Returns ''true'' if the item text was set successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiGridListSetItemText', name='guiGridListSetItemText', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListSetScrollBars', return_types=['bool'], arguments=[FunctionArgument(name='guiGridlist', argument_type='element', default_value=None, optional=False), FunctionArgument(name='horizontalBar', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='verticalBar', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows a gridlist's scrollbar to be forced '''on''', or returned to default.", arguments={'guiGridlist': 'The GUI gridlist you wish to change the state of scrollbars', 'horizontalBar': 'A bool where true forces the horizontal scrollbar on, and false returns them to default.', 'verticalBar': 'A bool where true forces the verical scrollbar on, and false returns them to default.'}, result="Returns ''true'' if the scrollbars were successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiGridListSetScrollBars', name='guiGridListSetScrollBars', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListSetSelectedItem', return_types=['bool'], arguments=[FunctionArgument(name='gridList', argument_type='element', default_value=None, optional=False), FunctionArgument(name='rowIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='columnIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='bReset', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description="This function selects an item from a gridlist. If you wish to deselect whatever item is selected, pass ''0'' as both the ''rowIndex'' and  ''columnIndex'' arguments.", arguments={'gridList': 'the grid list you want to select an item from', 'rowIndex': 'the row you want to select (index 0 is the first row)', 'columnIndex': 'the column you want to select (index 1 is the first column)\n{{New feature|3.0111|1.1.1|\n{{OptionalArg}}', 'bReset': 'set to false for multiple selections\n}}'}, result="Returns ''true'' if the passed arguments are correct and the item has been selected, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiGridList', method_name="setSelectedItem}}\n\n===Required Arguments=== \n*'''gridList:''' the grid list you want to select an item from\n*'''rowIndex:''' the row you want to select (index 0 is the first row)\n*'''columnIndex:''' the column you want to select (index 1 is the first column)\n{{New feature", field='3.0111'), url=FunctionUrl(url='/wiki/GuiGridListSetSelectedItem', name='guiGridListSetSelectedItem', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListSetSelectionMode', return_types=['bool'], arguments=[FunctionArgument(name='Element', argument_type='gui', default_value=None, optional=False), FunctionArgument(name='mode', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the selection mode of a gui gridlist.  For example, the MTA ''server browser'' selects a whole row, while the ''Controls'' dialog selects a single cell. To select multiple items you must be holding down 'ctrl'.", arguments={'gridlist': 'The gridlist in which you wish to set the selection mode.', 'mode': 'The mode of the selection.  Can be the following values:', '0': 'Single row selection', '1': 'Multiple row selection', '2': 'Single cell selection', '3': 'Multiple cell selection', '4': 'Nominated(First) single column selection', '5': 'Nominated(First) multiple column selection', '6': 'Single column selection', '7': 'Multiple column selection', '8': 'Nominated(First) single row selection', '9': 'Nominated(First) multiple row selection'}, result="Returns ''true'' if the selection mode was successfully set, false otherwise."), oop=FunctionOOP(class_name='GuiGridList', method_name='setSelectionMode', field="selectionMode}}\n\n===Required Arguments=== \n*'''gridlist:''' The gridlist in which you wish to set the selection mode.\n*'''mode:''' The mode of the selection.  Can be the following values:\n**'''0:''' Single row selection\n**'''1:''' Multiple row selection\n**'''2:''' Single cell selection\n**'''3:''' Multiple cell selection\n**'''4:''' Nominated(First) single column selection\n**'''5:''' Nominated(First) multiple column selection\n**'''6:''' Single column selection\n**'''7:''' Multiple column selection\n**'''8:''' Nominated(First) single row selection\n**'''9:''' Nominated(First) multiple row selection\n\n===Returns===\nReturns ''true'' if the selection mode was successfully set, false otherwise.\n\n"), url=FunctionUrl(url='/wiki/GuiGridListSetSelectionMode', name='guiGridListSetSelectionMode', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListSetSortingEnabled', return_types=['bool'], arguments=[FunctionArgument(name='guiGridlist', argument_type='element', default_value=None, optional=False), FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows the disabling or enabling of ''sorting'' within a gridlist.  Sorting is achieved by clicking a column header.  Gridlist items will be sorted according to the clicked column.  By default, gridlists have sorting enabled.  This function will allow you to toggle this.", arguments={'guiGridlist': 'The GUI gridlist you wish to toggle the sorting of.', 'enabled': 'A boolean representing whether the sorting is enabled, or disabled.'}, result="Returns ''true'' if sorting was successfully toggled., ''false'' otherwise."), oop=FunctionOOP(class_name='GuiGridList', method_name='setSortingEnabled', field="sortingEnabled}}\n\n===Required Arguments=== \n*'''guiGridlist:''' The GUI gridlist you wish to toggle the sorting of.\n*'''enabled:''' A boolean representing whether the sorting is enabled, or disabled.\n\n===Returns===\nReturns ''true'' if sorting was successfully toggled., ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/GuiGridListSetSortingEnabled', name='guiGridListSetSortingEnabled', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGridListSetVerticalScrollPosition', return_types=['bool'], arguments=[FunctionArgument(name='guiGridlist', argument_type='element', default_value=None, optional=False), FunctionArgument(name='fPosition', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the vertical scroll position from a grid list', arguments={'guiGridlist': ': The grid list you want to set the vertical scroll position from', 'fPosition': ': A float representing the vertical scroll position (0-100)'}, result="Returns ''true'' if the vertical scroll position was set, or ''false'' otherwise."), oop=FunctionOOP(class_name='GuiGridList', method_name='setVerticalScrollPosition', field='verticalScrollPosition'), url=FunctionUrl(url='/wiki/GuiGridListSetVerticalScrollPosition', name='guiGridListSetVerticalScrollPosition', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateMemo', return_types=['gui-memo'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value='nil', optional=True)]), docs=FunctionDoc(description='This function creates a new GUI memo.  This is a multiline edit box in which the user can input text.', arguments={'x': 'A float of the 2D x position of the GUI memo on a players screen.  This is affected by the relative argument.', 'y': 'A float of the 2D y position of the GUI memo on a players screen. This is affected by the relative argument.', 'width': 'A float of the width of the GUI memo. This is affected by the relative argument.', 'height': 'A float of the height of the GUI memo. This is affected by the relative argument.', 'text': 'A string of the text that will be displayed by default in the memo.', 'relative': 'This is whether sizes and positioning are relative.  If this is true, then all x,y,width,height floats must be between 0 and 1, representing measures relative to the parent.\n{{OptionalArg}} ', 'parent': 'This is the parent that the GUI memo is attached to.  If the relative argument is true, sizes and positioning will be made relative to this parent. If the relative argument is false, positioning will be the number of offset pixels from the parents origin. If no parent is passed, the parent will become the screen - causing positioning and sizing according to screen positioning.'}, result='Returns a gui-memo element of the created memo if it was successfully created, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/GuiCreateMemo', name='guiCreateMemo', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiMemoGetCaretIndex', return_types=['int'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the caret (the text cursor) position within the memo box.\n}}', arguments={'theElement': 'The memo box you want to get the caret position from'}, result="Returns the caret index on success, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiMemoGetCaretIndex', name='guiMemoGetCaretIndex', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiMemoGetVerticalScrollPosition', return_types=['float'], arguments=[FunctionArgument(name='memo', argument_type='gui', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theMemo': ': the guiCreateMemo|memo you want to know the vertical scroll position of.'}, result="Returns a [[float]] ranging between 0 and 100, or '''false''' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiMemoGetVerticalScrollPosition', name='guiMemoGetVerticalScrollPosition', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiMemoSetVerticalScrollPosition', return_types=['bool'], arguments=[FunctionArgument(name='memo', argument_type='gui', default_value=None, optional=False), FunctionArgument(name='position', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theMemo': ': the guiCreateMemo|memo you want to change the vertical scroll position of.', 'position': ': a float ranging between 0 and 100.'}, result="Returns '''true''' if the position was set, '''false''' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiMemoSetVerticalScrollPosition', name='guiMemoSetVerticalScrollPosition', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiMemoIsReadOnly', return_types=['bool'], arguments=[FunctionArgument(name='memo', argument_type='gui', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theMemo': 'The memo to check read-only status of.'}, result="Returns ''true'' if the memo is read only, ''false'' if the memo isn't read only, ''nil'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiMemoIsReadOnly', name='guiMemoIsReadOnly', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiMemoSetCaretIndex', return_types=['bool'], arguments=[FunctionArgument(name='memo', argument_type='gui', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the current position of the caret (the text cursor) within the memo.', arguments={'theMemo': 'The memo edit box where the caret position is to be changed.', 'index': 'An integer referring to the desired character position within the box. 0 would be before the first character in the box, 1 before the second, etc.'}, result="Returns ''true'' if the caret was successfully moved, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiMemoSetCaretIndex', name='guiMemoSetCaretIndex', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiMemoSetReadOnly', return_types=['bool'], arguments=[FunctionArgument(name='memo', argument_type='gui', default_value=None, optional=False), FunctionArgument(name='status', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows you to set or remove read-only status for a GUI memo. If read-only is set to ''true'', the contents are not editable.", arguments={'theMemo': 'The memo to change read-only status of.', 'status': 'A boolean value indicating whether read-only is to be enabled or disabled.'}, result="Returns ''true'' if the status was successfully changed, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiMemo', method_name='setReadOnly', field='readOnly'), url=FunctionUrl(url='/wiki/GuiMemoSetReadOnly', name='guiMemoSetReadOnly', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateProgressBar', return_types=['element'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value='nil', optional=False)]), docs=FunctionDoc(description='This function creates a [[Element/GUI/Progress bar|progress bar]].', arguments={'x': 'A float of the 2D x position of the progress bar on a players screen. This is affected by the relative argument.', 'y': 'A float of the 2D y position of the progress bar on a players screen. This is affected by the relative argument.', 'width': 'A float of the width of the progress bar. This is affected by the relative argument.', 'height': 'A float of the height of the progress bar. This is affected by the relative argument.', 'relative': 'This is whether sizes and positioning are relative. If this is true, then all x,y,width,height floats must be between 0 and 1, representing measures relative to the parent.\n{{OptionalArg}}', 'parent': 'This is the parent that the progress bar is attached to. If the relative argument is true, sizes and positioning will be made relative to this parent. If the relative argument is false, positioning will be the number of offset pixels from the parents origin. If no parent is passed, the parent will become the screen - causing positioning and sizing according to screen positioning.'}, result="Returns [[element]] of the progress bar if it was created succesfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiCreateProgressBar', name='guiCreateProgressBar', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiProgressBarGetProgress', return_types=['float'], arguments=[FunctionArgument(name='theProgressbar', argument_type='progressBar', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the progress of a progress bar as a percentage.', arguments={'theProgressbar': ': The progressbar you want to check.'}, result='Returns a [[float]] ranging between 0 and 100.'), oop=None, url=FunctionUrl(url='/wiki/GuiProgressBarGetProgress', name='guiProgressBarGetProgress', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiProgressBarSetProgress', return_types=['bool'], arguments=[FunctionArgument(name='theProgressbar', argument_type='progressBar', default_value=None, optional=False), FunctionArgument(name='progress', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the progress of a progressbar as a percentage.', arguments={'theProgressbar': ': The progressbar you want to change the progress of', 'progress': ': a float ranging from 0 - 100'}, result='Returns true if the progress was set, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/GuiProgressBarSetProgress', name='guiProgressBarSetProgress', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateRadioButton', return_types=['element'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value='nil', optional=False)]), docs=FunctionDoc(description='This function creates a [[Element/GUI/Radio button|radio button]].', arguments={'x': 'A float of the 2D x position of the radio button on a players screen. This is affected by the relative argument.', 'y': 'A float of the 2D y position of the radio button on a players screen. This is affected by the relative argument.', 'width': 'A float of the width of the text field next to the radio button. This is affected by the relative argument.', 'height': 'A float of the height of the text field next to the radio button. This is affected by the relative argument.', 'text': 'The text to be displayed next to the radio button.', 'relative': 'This is whether sizes and positioning are relative. If this is true, then all x,y,width,height floats must be between 0 and 1, representing measures relative to the parent.\n{{OptionalArg}} ', 'parent': "This is the parent that the radio button is attached to. If the relative argument is true, sizes and positioning will be made relative to this parent. If the relative argument is false, positioning will be the number of offset pixels from the parents origin. If no parent is passed, the parent will become the screen - causing positioning and sizing according to screen positioning.\n''NOTE:'' All radio buttons become grouped together with their parent item.  Only ONE radio button per group/parent will be able to be selected at the same time."}, result="Returns [[element]] of the radio button if it was created succesfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiCreateRadioButton', name='guiCreateRadioButton', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiRadioButtonGetSelected', return_types=['bool'], arguments=[FunctionArgument(name='guiRadioButton', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets a radio button's selection state.", arguments={'guiRadioButton': 'The radio button you wish to retrieve the selection state of.'}, result="Returns ''true'' if the radio button is selected, ''false'' if it is not."), oop=None, url=FunctionUrl(url='/wiki/GuiRadioButtonGetSelected', name='guiRadioButtonGetSelected', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiRadioButtonSetSelected', return_types=['bool'], arguments=[FunctionArgument(name='guiRadioButton', argument_type='element', default_value=None, optional=False), FunctionArgument(name='state', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function selects or unselects a radio button.', arguments={'guiRadioButton': 'The GUI radio button in which you wish to change the selection state of', 'state': 'The state of the radio button, where true indicates selected, and false indicates unselected.'}, result="Returns ''true'' if the radio button's selection state was successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiRadioButtonSetSelected', name='guiRadioButtonSetSelected', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateScrollBar', return_types=['gui-scrollbar'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='horizontal', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='element', argument_type='gui', default_value=None, optional=False)]), docs=FunctionDoc(description="This function creates a GUI scrollbar. You can use the functions [[guiScrollPaneSetHorizontalScrollPosition]], [[guiScrollPaneSetVerticalScrollPosition]], [[guiScrollPaneGetHorizontalScrollPosition]] and [[guiScrollPaneGetVerticalScrollPosition]] to read and modify the scrollbar's scroll.", arguments={'x': 'the 2D x offset of the GUI scrollbar from its parent.  This is affected by the relative argument.', 'y': 'the 2D y offset of the GUI scrollbar from its parent. This is affected by the relative argument.', 'width': 'the width of the GUI scrollbar. This is affected by the relative argument.', 'height': 'the height of the GUI scrollbar. This is affected by the relative argument.', 'horizontal': 'whether this scrollbar is horizontal (true) or vertical (false).', 'relative': 'whether sizes and positions are relative to their parents.  If this is true, then all measures must be between 0 and 1, representing sizes/positions as a fraction of the parent widgets size.', 'parent': 'the gui-element this scrollbar is attached to. By default, it is nil, meaning the widget is attached to the background.'}, result="Returns a ''gui-scrollbar'' if it was created successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiCreateScrollBar', name='guiCreateScrollBar', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiScrollBarGetScrollPosition', return_types=['float'], arguments=[FunctionArgument(name='scrollBar', argument_type='gui', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the scroll amount of a scrollbar as a percentage.', arguments={'theScrollBar ': ': The scrollbar you want to check.'}, result='Returns a [[float]] ranging between 0 and 100, representing the amount the scrollbar has been scrolled.'), oop=None, url=FunctionUrl(url='/wiki/GuiScrollBarGetScrollPosition', name='guiScrollBarGetScrollPosition', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiScrollBarSetScrollPosition', return_types=['bool'], arguments=[FunctionArgument(name='scrollBar', argument_type='gui', default_value=None, optional=False), FunctionArgument(name='amount', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the scroll amount of a scrollbar as a percentage.', arguments={'theScrollBar': ': The scrollbar you want to change the progress of', 'amount': ': a float ranging from 0 - 100 representing the amount you wish to set the scroll bar.'}, result='Returns true if the scroll position was successfully set, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/GuiScrollBarSetScrollPosition', name='guiScrollBarSetScrollPosition', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateScrollPane', return_types=['element'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='element', argument_type='gui', default_value=None, optional=False)]), docs=FunctionDoc(description='This creates a GUI scroll pane.\n[[Image:gui-scrollpane.png|frame|Example GUI ScrollPane.]]', arguments={'x': 'the 2D x offset of the GUI scrollpane from its parent. This is affected by the relative argument.', 'y': 'the 2D y offset of the GUI scrollpane from its parent. This is affected by the relative argument.', 'width': 'the width of the GUI scrollpane. This is affected by the relative argument.', 'height': 'the height of the GUI scrollpane. This is affected by the relative argument.', 'relative': 'whether sizes and positions are relative to their parents. If this is true, then all measures must be between 0 and 1, representing sizes/positions as a fraction of the parent widgets size.', 'parent': 'the gui-element this scrollpane is attached to. By default, it is nil, meaning the widget is attached to the background.'}, result='The gui-element if created, otherwise false.'), oop=None, url=FunctionUrl(url='/wiki/GuiCreateScrollPane', name='guiCreateScrollPane', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiScrollPaneGetHorizontalScrollPosition', return_types=['float'], arguments=[FunctionArgument(name='horizontalScrollPane', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the position of a horizontal scroll pane as a percentage.', arguments={'horizontalScrollPane': ': The scroll pane you want to know the position of'}, result="Returns a [[float]] ranging between 0 and 100, or '''false''' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiScrollPaneGetHorizontalScrollPosition', name='guiScrollPaneGetHorizontalScrollPosition', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiScrollPaneGetVerticalScrollPosition', return_types=['float'], arguments=[FunctionArgument(name='verticalScrollPane', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the position of a vertical scroll pane as a percentage.', arguments={'verticalScrollPane': ': The scroll pane you want to know the position of'}, result="Returns a [[float]] ranging between 0 and 100, or '''false''' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiScrollPaneGetVerticalScrollPosition', name='guiScrollPaneGetVerticalScrollPosition', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiScrollPaneSetHorizontalScrollPosition', return_types=['bool'], arguments=[FunctionArgument(name='horizontalScrollPane', argument_type='element', default_value=None, optional=False), FunctionArgument(name='position', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the position of a horizontal scroll pane as a percentage.', arguments={'horizontalScrollPane': ': The scroll pane you want to change the position of', 'position': ': a float ranging from 0 - 100'}, result="Returns '''true''' if the position was set, '''false''' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiScrollPaneSetHorizontalScrollPosition', name='guiScrollPaneSetHorizontalScrollPosition', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiScrollPaneSetScrollBars', return_types=['bool'], arguments=[FunctionArgument(name='scrollPane', argument_type='element', default_value=None, optional=False), FunctionArgument(name='horizontal', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='vertical', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows a scrollpane's scrollbars to be forced '''on''', or returned to default.", arguments={'scrollPane': 'the GUI scrollpane element you want to set the scrollbars of.', 'horizontal': 'A bool where true forces the horizontal scrollbar on, and false returns them to default.', 'vertical': 'A bool where true forces the vertical scrollbar on, and false returns them to default.'}, result="Returns ''true'' if the call was successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiScrollPaneSetScrollBars', name='guiScrollPaneSetScrollBars', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiScrollPaneSetVerticalScrollPosition', return_types=['bool'], arguments=[FunctionArgument(name='verticalScrollPane', argument_type='element', default_value=None, optional=False), FunctionArgument(name='position', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the position of a vertical scroll pane as a percentage.', arguments={'verticalScrollPane': ': The scroll pane you want to change the position of', 'position': ': a float ranging from 0 - 100'}, result="Returns '''true''' if the position was set, '''false''' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiScrollPaneSetVerticalScrollPosition', name='guiScrollPaneSetVerticalScrollPosition', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateStaticImage', return_types=['element'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='path', argument_type='string', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value='nil', optional=False)]), docs=FunctionDoc(description='This function creates a static image using a .png image in the resource.', arguments={'x': 'A float of the 2D x position of the image on a players screen. This is affected by the relative argument.', 'y': 'A float of the 2D y position of the image on a players screen. This is affected by the relative argument.', 'width': 'A float of the width of the image. This is affected by the relative argument.', 'height': 'A float of the height of the image. This is affected by the relative argument.', 'path': 'The filepath of the image file that is being loaded.', 'relative': 'This is whether sizes and positioning are relative. If this is true, then all x,y,width,height floats must be between 0 and 1, representing measures relative to the parent.\n{{OptionalArg}} ', 'parent': 'This is the parent that the image is attached to. If the relative argument is true, sizes and positioning will be made relative to this parent. If the relative argument is false, positioning will be the number of offset pixels from the parents origin. If no parent is passed, the parent will become the screen - causing positioning and sizing according to screen positioning.'}, result="Returns [[element]] if image was created successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiCreateStaticImage', name='guiCreateStaticImage', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiStaticImageGetNativeSize', return_types=['int,', 'int'], arguments=[FunctionArgument(name='theImage', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the native size of image. That means the original size in pixels of the image file.', arguments={'theImage': 'The static image element to get the original size of.'}, result="Returns two integers where first is the width and second the height of the image in pixels, ''false'' if the image element was invalid."), oop=None, url=FunctionUrl(url='/wiki/GuiStaticImageGetNativeSize', name='guiStaticImageGetNativeSize', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiStaticImageLoadImage', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='filename', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows you to change the image in GUI static image element to another one. '''Tip''': If you set other images as children you will have to use [[setElementCallPropagationEnabled]] to only affect the parent image.", arguments={'theElement': 'The static image element to be changed.', 'filename': 'A string specifying the filepath of the image file being loaded in current resource.'}, result="Returns ''true'' if the the image in the static image element was successfully changed, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiStaticImage', method_name='loadImage', field="image}}\n===Required Arguments=== \n*'''theElement:''' The static image element to be changed.\n*'''filename:''' A string specifying the [[filepath]] of the image file being loaded in current resource. \n\n===Returns===\nReturns ''true'' if the the image in the static image element was successfully changed, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/GuiStaticImageLoadImage', name='guiStaticImageLoadImage', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateTabPanel', return_types=['element'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value='nil', optional=False)]), docs=FunctionDoc(description='This function creates a Tab Panel, which acts as a template to create Tabs upon.', arguments={'x': 'A float of the 2D x position of the GUI tab panel on a players screen.  This is affected by the relative argument.', 'y': 'A float of the 2D y position of the GUI tab panel on a players screen. This is affected by the relative argument.', 'width': 'A float of the width of the GUI tab panel. This is affected by the relative argument.', 'height': 'A float of the height of the GUI tab panel. This is affected by the relative argument.', 'relative': 'This is whether sizes and positioning are relative.  If this is true, then all x,y,width,height floats must be between 0 and 1, representing sizes relative to the parent.\n{{OptionalArg}} ', 'parent': 'This is the parent that the tab panel is attached to.  If the relative argument is true, sizes and positioning will be made relative to this parent. If the relative argument is false, positioning will be the number of offset pixels from the parents origin. If no parent is passed, the parent will become the screen - causing positioning and sizing according to screen positioning.'}, result="Returns a GUI tab panel element if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiCreateTabPanel', name='guiCreateTabPanel', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiGetSelectedTab', return_types=['element'], arguments=[FunctionArgument(name='tabPanel', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the currently selected tab in the specified [[Element/GUI/Tab panel|tab panel]].', arguments={'tabPanel': 'The Element/GUI/Tab panel|tab panel which current tab you want to retrieve.'}, result="Returns an [[element]] of the [[Element/GUI/Tab|tab]] if a tab was selected or [[nil]] if no tab was selected. If passed arguments were invalid or something went wrong, the function will return ''false''."), oop=FunctionOOP(class_name='GuiTabPanel', method_name='getSelectedTab', field='selectedTab'), url=FunctionUrl(url='/wiki/GuiGetSelectedTab', name='guiGetSelectedTab', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiSetSelectedTab', return_types=['bool'], arguments=[FunctionArgument(name='tabPanel', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theTab', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to change the currently selected [[Element/GUI/Tab|tab]] in a [[Element/GUI/Tab panel|tab panel]].', arguments={'tabPanel': 'The Element/GUI/Tab panel|tab panel which current tab you want to change.', 'theTab': 'The Element/GUI/Tab|tab which will be the new active tab.'}, result="Returns ''true'' if the selected tab was changed to a new one successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiSetSelectedTab', name='guiSetSelectedTab', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateTab', return_types=['element'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description="This function creates a tab on a pre-existing tab panel. A tab is a button as well as a 'dimension' that can be used to switch between information by clicking on the tabs.  Tabs are sorted on a tab panel in the order that they are created.", arguments={'text': 'The caption for the tab', 'parent': 'The parent tab panel, as a tab panel element type'}, result="Returns a tab element if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GuiCreateTab', name='guiCreateTab', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiDeleteTab', return_types=['bool'], arguments=[FunctionArgument(name='tabToDelete', argument_type='element', default_value=None, optional=False), FunctionArgument(name='tabPanel', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function deletes a tab from a tab panel.', arguments={'tabToDelete': 'This is an element representing the tab that you want to delete.', 'tabPanel': 'This is the guiCreateTabPanel|tab panel parent that the tab is attached to.'}, result="Returns ''true'' the tab was successfully deleted, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiTab', method_name="delete}} \n===Required Arguments=== \n*'''tabToDelete:''' This is an element representing the tab that you want to delete.\n*'''tabPanel:''' This is the [[guiCreateTabPanel", field="tab panel]] parent that the tab is attached to.\n\n===Returns===\nReturns ''true'' the tab was successfully deleted, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/GuiDeleteTab', name='guiDeleteTab', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateLabel', return_types=['element'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='parent', argument_type='element', default_value='nil', optional=False)]), docs=FunctionDoc(description="[[Image:gui-label.png|frame|Example GUI label.]]\n<table><tr><td valign=top height=100>\nThis function is for creating a new GUI label.  A label is simply a piece of text that cannot be edited by the user. If you would like to have a bigger text you'd have to change its font because font size is not supported.\n</td></tr></table>", arguments={'x': 'A float of the 2D x position of the GUI label on a players screen.  This is affected by the relative argument.', 'y': 'A float of the 2D y position of the GUI label on a players screen. This is affected by the relative argument.', 'width': 'A float of the width of the GUI label. This is affected by the relative argument.', 'height': 'A float of the height of the GUI label. This is affected by the relative argument.', 'text': 'A string of the text that will be displayed by the label.', 'relative': 'This is whether sizes and positioning are relative.  If this is true, then all x,y,width,height floats must be between 0 and 1, representing sizes relative to the parent.\n{{OptionalArg}} ', 'parent': 'This is the parent that the gui label is attached to.  If the relative argument is true, sizes and positioning will be made relative to this parent. If the relative argument is false, positioning will be the number of offset pixels from the parents origin. If no parent is passed, the parent will become the screen - causing positioning and sizing according to screen positioning.'}, result='Returns an [[GUI_widgets|element]] of the created label if it was successfully created, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/GuiCreateLabel', name='guiCreateLabel', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiLabelGetColor', return_types=['int', 'int', 'int'], arguments=[FunctionArgument(name='element', argument_type='gui', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the color of a label.\n}}', arguments={'theLabel': 'The label to get color.'}, result="Returns three ''int'' values, representing the amount of red, green, blue if successful. ''false'' otherwise."), oop=FunctionOOP(class_name='GuiLabel', method_name='getColor', field=None), url=FunctionUrl(url='/wiki/GuiLabelGetColor', name='guiLabelGetColor', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiLabelGetFontHeight', return_types=['float'], arguments=[FunctionArgument(name='theLabel', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the height of the font currently used in a GUI text label.', arguments={'theLabel': 'The text label to get the font height from.'}, result="Returns the absolute height of the font currently used in the text label if the function is successful, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiLabel', method_name='getFontHeight', field="fontHeight}} \n===Required Arguments=== \n*'''theLabel:''' The text label to get the font height from.\n\n===Returns===\nReturns the absolute height of the font currently used in the text label if the function is successful, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/GuiLabelGetFontHeight', name='guiLabelGetFontHeight', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiLabelGetTextExtent', return_types=['float'], arguments=[FunctionArgument(name='theLabel', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the extent, or width, of the current text inside a GUI text label.', arguments={'theLabel': 'The text label to get the text extent from.'}, result="Returns the absolute width of the current text inside the text label if the function is successful, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiLabel', method_name='getTextExtent', field="textExtent}} \n===Required Arguments=== \n*'''theLabel:''' The text label to get the text extent from.\n\n===Returns===\nReturns the absolute width of the current text inside the text label if the function is successful, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/GuiLabelGetTextExtent', name='guiLabelGetTextExtent', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiLabelSetColor', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='red', argument_type='int', default_value=None, optional=False), FunctionArgument(name='green', argument_type='int', default_value=None, optional=False), FunctionArgument(name='blue', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function allows you to set the color of a GUI label.", arguments={'theElement': 'The label to be changed.', 'red': 'An integer specifying the amount of red (0 to 255).', 'green': 'An integer specifying the amount of green (0 to 255).', 'blue': 'An integer specifying the amount of blue (0 to 255).'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the the color of the gui label was successfully changed, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiLabel', method_name='setColor', field=None), url=FunctionUrl(url='/wiki/GuiLabelSetColor', name='guiLabelSetColor', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiLabelSetHorizontalAlign', return_types=['bool'], arguments=[FunctionArgument(name='theLabel', argument_type='element', default_value=None, optional=False), FunctionArgument(name='align', argument_type='string', default_value=None, optional=False), FunctionArgument(name='wordwrap', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='This function sets the horizontal alignment of a text label.', arguments={'theLabel': 'The text label to set the horizontal alignment on.', 'align': 'The alignment type. Valid type strings are:\n**"left"\n**"center"\n**"right"', 'wordwrap': 'Whether or not to enable wordwrap for the gui-label.'}, result="Returns ''true'' on success, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiLabel', method_name='setHorizontalAlign', field='horizontalAlign}} \n===Required Arguments=== \n*\'\'\'theLabel:\'\'\' The text label to set the horizontal alignment on.\n*\'\'\'align:\'\'\' The alignment type. Valid type strings are:\n**"left"\n**"center"\n**"right"\n*\'\'\'wordwrap:\'\'\' Whether or not to enable wordwrap for the gui-label.\n\n===Returns===\nReturns \'\'true\'\' on success, \'\'false\'\' otherwise.\n\n'), url=FunctionUrl(url='/wiki/GuiLabelSetHorizontalAlign', name='guiLabelSetHorizontalAlign', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiLabelSetVerticalAlign', return_types=['bool'], arguments=[FunctionArgument(name='theLabel', argument_type='element', default_value=None, optional=False), FunctionArgument(name='align', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the vertical alignment of a text label.', arguments={'theLabel': 'The text label to set the vertical alignment on.', 'align': 'The alignment type. Valid type strings are:\n**"top"\n**"center"\n**"bottom"'}, result="Returns ''true'' on success, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiLabel', method_name='setVerticalAlign', field='verticalAlign}} \n===Required Arguments=== \n*\'\'\'theLabel:\'\'\' The text label to set the vertical alignment on.\n*\'\'\'align:\'\'\' The alignment type. Valid type strings are:\n**"top"\n**"center"\n**"bottom"\n\n===Returns===\nReturns \'\'true\'\' on success, \'\'false\'\' otherwise.\n\n'), url=FunctionUrl(url='/wiki/GuiLabelSetVerticalAlign', name='guiLabelSetVerticalAlign', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiCreateWindow', return_types=['element'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='width', argument_type='float', default_value=None, optional=False), FunctionArgument(name='height', argument_type='float', default_value=None, optional=False), FunctionArgument(name='titleBarText', argument_type='string', default_value=None, optional=False), FunctionArgument(name='relative', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is for creating a new GUI window.  This provides a base for other gui elements to be created within.  However, windows do not have a parent and cannot be created in any GUI elements.', arguments={'x': 'A float of the 2D x position of the GUI window on a players screen.  This is affected by the relative argument.', 'y': 'A float of the 2D y position of the GUI window on a players screen. This is affected by the relative argument.', 'width': 'A float of the width of the GUI window. This is affected by the relative argument.', 'height': 'A float of the height of the GUI window. This is affected by the relative argument.', 'titleBarText': 'A string of the text that will be displayed in the title bar of the window.', 'relative': 'This is whether sizes and positioning are relative.  If this is true, then all x,y,width,height floats must be between 0 and 1, representing sizes/positions as a fraction of the screen size. If false, then the size and co-ordinates are based on clients resolution, accessible using guiGetScreenSize.'}, result='Returns a gui window element if it was created successfully, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/GuiCreateWindow', name='guiCreateWindow', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiWindowIsMovable', return_types=['bool'], arguments=[FunctionArgument(name='window', argument_type='gui', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'guiWindow': 'the window to check the movable flag of'}, result="Returns ''true'' if the window is movable, ''false'' if not, ''nil'' if an invalid window was provided."), oop=None, url=FunctionUrl(url='/wiki/GuiWindowIsMovable', name='guiWindowIsMovable', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiWindowIsSizable', return_types=['bool'], arguments=[FunctionArgument(name='window', argument_type='gui', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'guiWindow': 'the window to check the sizable flag of'}, result="Returns ''true'' if the window is sizable, ''false'' if not, ''nil'' if an invalid window was provided."), oop=None, url=FunctionUrl(url='/wiki/GuiWindowIsSizable', name='guiWindowIsSizable', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiWindowSetMovable', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='status', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to specify whether or not a user can move a GUI window.', arguments={'theElement': 'The window to be changed.', 'status': 'A boolean value indicating whether the window is movable or not.'}, result="Returns ''true'' if the function is successful, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiWindow', method_name='setMovable', field='movable'), url=FunctionUrl(url='/wiki/GuiWindowSetMovable', name='guiWindowSetMovable', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='guiWindowSetSizable', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='status', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function enables or disables user resizing of a GUI window.', arguments={'theElement': 'The window to be changed.', 'status': 'A boolean value indicating whether user resizing is to be enabled or disabled.'}, result="Returns ''true'' if the function is successful, ''false'' otherwise."), oop=FunctionOOP(class_name='GuiWindow', method_name='setSizable', field='sizable'), url=FunctionUrl(url='/wiki/GuiWindowSetSizable', name='guiWindowSetSizable', category='GUI functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='addCommandHandler', return_types=['bool'], arguments=[FunctionArgument(name='commandName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='handlerFunction', argument_type='function', default_value=None, optional=False), FunctionArgument(name='restricted', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='caseSensitive', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description="This function will attach a scripting function (handler) to a console command, so that whenever a player or administrator uses the command the function is called.\nMultiple command handlers can be attached to a single command, and they will be called in the order that the handlers were attached. Equally, multiple commands can be handled by a single function, and the ''commandName'' parameter used to decide the course of action.\nFor users, a command is in the format:\n''commandName'' ''argument1'' ''argument2''\nThis can be triggered from the player's console or directly from the chat box by prefixing the message with a forward slash (''/''). For server side handlers, the server admin is also able to trigger these directly from the server's console in the same way as they are triggered from a player's console.", arguments={'commandName': 'This is the name of the command you wish to attach a handler to. This is what must be typed into the console to trigger the function.', 'handlerFunction': 'This is the function that you want the command to trigger, which has to be defined before you add the handler. This function can take two parameters, playerSource and commandName, followed by as many parameters as you expect after your command (see below). These are all optional.\n{{OptionalArg}} ', 'restricted': 'Specify whether or not this command should be restricted by default. Use this on commands that should be inaccessible to everyone as default except special users specified in the ACL (Access Control List). This is to make sure admin commands such as ie. punish wont be available to everyone if a server administrator forgets masking it in ACL. Make sure to add the command to your ACL under the proper group for it to be usefull (i.e <right name=command.killEveryone access=true></right>). This argument defaults to false if nothing is specified.\n{{New feature|3|1.0|', 'caseSensitive': 'Specifies if the command handler will ignore the case for this command name.\n}}'}, result="Returns ''true'' if the command handler was added successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/AddCommandHandler', name='addCommandHandler', category='Input functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='addCommandHandler', return_types=['bool'], arguments=[FunctionArgument(name='commandName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='handlerFunction', argument_type='function', default_value=None, optional=False), FunctionArgument(name='caseSensitive', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description="This function will attach a scripting function (handler) to a console command, so that whenever a player or administrator uses the command the function is called.\nMultiple command handlers can be attached to a single command, and they will be called in the order that the handlers were attached. Equally, multiple commands can be handled by a single function, and the ''commandName'' parameter used to decide the course of action.\nFor users, a command is in the format:\n''commandName'' ''argument1'' ''argument2''\nThis can be triggered from the player's console or directly from the chat box by prefixing the message with a forward slash (''/''). For server side handlers, the server admin is also able to trigger these directly from the server's console in the same way as they are triggered from a player's console.", arguments={'commandName': 'This is the name of the command you wish to attach a handler to. This is what must be typed into the console to trigger the function.', 'handlerFunction': 'This is the function that you want the command to trigger, which has to be defined before you add the handler. This function can take commandName parameter, followed by as many parameters as you expect after your command (see below). These are all optional.\n{{OptionalArg}} \n{{New feature|3|1.0|', 'caseSensitive': 'Specifies if the command handler will ignore the case for this command name.\n}}'}, result="Returns ''true'' if the command handler was added successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/AddCommandHandler', name='addCommandHandler', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='bindKey', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='keyState', argument_type='string', default_value=None, optional=False), FunctionArgument(name='handlerFunction', argument_type='function', default_value=None, optional=False), FunctionArgument(name='arguments', argument_type='var', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description="Binds a player's key to a handler function or command, which will be called when the key is pressed. ", arguments={'thePlayer': 'The player you wish to bind the key of.', 'key': 'The key that was pressed', 'keyState': 'The state of the key that was pressed, down if it was pressed, up if it was released.', '"up"': 'If the bound key should trigger the function when the key is released', '"down"': 'If the bound key should trigger the function when the key is pressed', '"both"': 'If the bound key should trigger the function when the key is pressed or released', 'handlerFunction': 'The function that will be triggered when the players key is pressed. This function should have the form:\n:<syntaxhighlight lang="lua">function functionName ( player keyPresser, string key, string keyState, [ var arguments, ... ] )</syntaxhighlight>\n:The values passed to this function are:', 'keyPresser': 'The player who pressed the key', 'arguments': 'The optional arguments you specified when calling bindKey (see below).'}, result="Returns ''true'' if the key was bound, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/BindKey', name='bindKey', category='Input functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='bindKey', return_types=['bool'], arguments=[FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='keyState', argument_type='string', default_value=None, optional=False), FunctionArgument(name='handlerFunction', argument_type='function', default_value=None, optional=False), FunctionArgument(name='arguments', argument_type='var', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description="Binds a player's key to a handler function or command, which will be called when the key is pressed. ", arguments={'key': 'The key that was pressed', 'keyState': 'The state of the key that was pressed, down if it was pressed, up if it was released.', '"up"': 'If the bound key should trigger the function when the key is released', '"down"': 'If the bound key should trigger the function when the key is pressed', '"both"': 'If the bound key should trigger the function when the key is pressed or released', 'bindName': 'The name for this key bind when it appears in the clients settings dialog.-->', 'handlerFunction': 'The function that will be triggered when the players key is pressed. This function should have the form:\n:<syntaxhighlight lang="lua">function functionName ( string key, string keyState, [ var arguments, ... ] )</syntaxhighlight>\n:The values passed to this function are:', 'arguments': 'The optional arguments you specified when calling bindKey (see below).'}, result="Returns ''true'' if the key was bound, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/BindKey', name='bindKey', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='executeCommandHandler', return_types=['bool'], arguments=[FunctionArgument(name='commandName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='args', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will call all the attached functions of an existing console command, for a specified player.\n ', arguments={'commandName': 'The name of the command you wish to execute. This is what must be typed into the console to trigger the function.', 'thePlayer': 'The player that will be presented as executer of the command to the handler function(s) of the command.\n{{OptionalArg}}', 'args': 'Additional parameters that will be passed to the handler function(s) of the command that is called, separated by spaces.'}, result="Returns ''true'' if the command handler was called successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ExecuteCommandHandler', name='executeCommandHandler', category='Input functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='executeCommandHandler', return_types=['bool'], arguments=[FunctionArgument(name='commandName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='args', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will call all the attached functions of an existing console command, for a specified player.\n ', arguments={'commandName': 'The name of the command you wish to execute. This is what must be typed into the console to trigger the function.\n{{OptionalArg}}', 'args': 'Additional parameters that will be passed to the handler function(s) of the command that is called, separated by spaces.'}, result="Returns ''true'' if the command handler was called successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ExecuteCommandHandler', name='executeCommandHandler', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getAnalogControlState', return_types=['float'], arguments=[FunctionArgument(name='control', argument_type='string', default_value=None, optional=False), FunctionArgument(name='rawValue', argument_type='bool', default_value=None, optional=True)]), docs=FunctionDoc(description='This retrieves the analog control state of a control.  This is useful for detecting sensitive controls, such as those used on a joypad.\nTo get the analog control state for a [[ped]], please use [[getPedAnalogControlState]].', arguments={'control': 'The control that you want to get the state of. See control names for a list of possible controls.\n{{New feature/item|3.0157|1.5.7|20383|', 'rawValue': 'A bool indicating if it should return the raw player input value.\n}}'}, result='Returns a [[float]] between 0 and 1 indicating the amount the control is pressed.'), oop=None, url=FunctionUrl(url='/wiki/GetAnalogControlState', name='getAnalogControlState', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getBoundKeys', return_types=['table'], arguments=[FunctionArgument(name='command', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns a list of key names that are bound to the specified game [[Control names|control]] or console command.', arguments={'command/control': 'the name of a game control or a console command. See the control names page for valid controls.'}, result="If one or more keys are bound to the specified control or console command, a table is returned indexed by the names of the keys and containing key states as values. If no keys are bound or an invalid name was passed, returns ''false''."), oop=None, url=FunctionUrl(url='/wiki/GetBoundKeys', name='getBoundKeys', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getCommandHandlers', return_types=['table'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to retrieve a list of all the registered command handlers of a given resource (or of all resources).\n}}', arguments={'theResource': 'The resource from which you wish to retrieve all command handlers. Or leave it empty to retrieve command handlers of all resources.'}, result='Returns a \'\'table\'\' containing all the commands of the given resource or a table with subtables containing the command and theResource pointer ( { "command", theResource } ). See examples below if you don\'t understand it.'), oop=None, url=FunctionUrl(url='/wiki/GetCommandHandlers', name='getCommandHandlers', category='Input functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getCommandHandlers', return_types=['table'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to retrieve a list of all the registered command handlers of a given resource (or of all resources).\n}}', arguments={'theResource': 'The resource from which you wish to retrieve all command handlers. Or leave it empty to retrieve command handlers of all resources.'}, result='Returns a \'\'table\'\' containing all the commands of the given resource or a table with subtables containing the command and theResource pointer ( { "command", theResource } ). See examples below if you don\'t understand it.'), oop=None, url=FunctionUrl(url='/wiki/GetCommandHandlers', name='getCommandHandlers', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getCommandsBoundToKey', return_types=['table'], arguments=[FunctionArgument(name='theKey', argument_type='string', default_value=None, optional=False), FunctionArgument(name='keyState', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the commands bound to a key.', arguments={'theKey': 'See key names for a list of possible keys', 'keyState': 'A string that has one of the following values:', '"up"': 'If the bound key should trigger the function when the key is released', '"down"': 'If the bound key should trigger the function when the key is pressed', '"both"': 'If the bound key should trigger the function when the key is pressed or released'}, result='Returns a table of the commands bound on that key.'), oop=None, url=FunctionUrl(url='/wiki/GetCommandsBoundToKey', name='getCommandsBoundToKey', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getFunctionsBoundToKey', return_types=['table'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='keyState', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the functions bound to a key. To bind a function to a key use the [[bindKey]] function', arguments={'thePlayer': 'The player to get the functions from a key.', 'theKey': 'The key you wish to check the functions from.', 'keyState': 'A string that has one of the following values:', '"up"': 'If the bound key should trigger the function when the key is released', '"down"': 'If the bound key should trigger the function when the key is pressed', '"both"': 'If the bound key should trigger the function when the key is pressed or released'}, result='Returns a table of the key function(s).'), oop=None, url=FunctionUrl(url='/wiki/GetFunctionsBoundToKey', name='getFunctionsBoundToKey', category='Input functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getFunctionsBoundToKey', return_types=['table'], arguments=[FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='keyState', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the functions bound to a key. To bind a function to a key use the [[bindKey]] function', arguments={'theKey': 'The key you wish to check the functions from.', 'keyState': 'A string that has one of the following values:', '"up"': 'If the bound key should trigger the function when the key is released', '"down"': 'If the bound key should trigger the function when the key is pressed', '"both"': 'If the bound key should trigger the function when the key is pressed or released'}, result='Returns a table of the key function(s).'), oop=None, url=FunctionUrl(url='/wiki/GetFunctionsBoundToKey', name='getFunctionsBoundToKey', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getKeyBoundToCommand', return_types=['string'], arguments=[FunctionArgument(name='command', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allow you get first key bound to command.', arguments={'command': 'command what you need check.'}, result='Returns a string of first key binded to current command.'), oop=None, url=FunctionUrl(url='/wiki/GetKeyBoundToCommand', name='getKeyBoundToCommand', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getKeyBoundToFunction', return_types=['string'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='theFunction', argument_type='function', default_value=None, optional=False)]), docs=FunctionDoc(description='getKeyBoundToFunction allows retrieval of the first key bound to a function.', arguments={'thePlayer': 'The player you are checking the function bound to a key', 'theFunction': 'The function in which you would like to check the bound key'}, result='Returns a string of the first key the function was bound to.'), oop=None, url=FunctionUrl(url='/wiki/GetKeyBoundToFunction', name='getKeyBoundToFunction', category='Input functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getKeyBoundToFunction', return_types=['string'], arguments=[FunctionArgument(name='theFunction', argument_type='function', default_value=None, optional=False)]), docs=FunctionDoc(description='getKeyBoundToFunction allows retrieval of the first key bound to a function.', arguments={'theFunction': 'The function in which you would like to check the bound key'}, result='Returns a string of the first key the function was bound to.'), oop=None, url=FunctionUrl(url='/wiki/GetKeyBoundToFunction', name='getKeyBoundToFunction', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getKeyState', return_types=['bool'], arguments=[FunctionArgument(name='keyName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function determines if a certain key is pressed or not.\n'''Note:''' 'ralt' may trigger both 'ralt' and 'lctrl', this is due to AltGr", arguments={'keyName': 'The name of the key youre checking state of. See Key names.'}, result="Returns ''true'' if the specified key is pressed, ''false'' if it isn't or if an invalid key name is passed."), oop=None, url=FunctionUrl(url='/wiki/GetKeyState', name='getKeyState', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isControlEnabled', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='control', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Checks whether a GTA control is enabled or disabled for a certain player.', arguments={'thePlayer': 'The player you wish the control status of.', 'control': 'The control you wish to check. See control names for a list of possible controls.'}, result="Returns ''true'' if control is enabled, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsControlEnabled', name='isControlEnabled', category='Input functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isControlEnabled', return_types=['bool'], arguments=[FunctionArgument(name='control', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Checks whether a GTA control is enabled or disabled for a certain player.', arguments={'control': 'The control you wish to check. See control names for a list of possible controls.'}, result="Returns ''true'' if control is enabled, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsControlEnabled', name='isControlEnabled', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removeCommandHandler', return_types=['bool'], arguments=[FunctionArgument(name='commandName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='handler', argument_type='function', default_value=None, optional=True)]), docs=FunctionDoc(description='This function removes a command handler, that is one that has been added using [[addCommandHandler]]. This function can only remove command handlers that were added by the resource that it is called in.', arguments={'commandName': 'the name of the command you wish to remove.', 'handler': 'the specific handler function to remove. If not specified, all handler functions for the command (from the calling resource) will be removed. This argument is only available in the server.'}, result="Returns ''true'' if the command handler was removed successfully, ''false'' if the command doesn't exist."), oop=None, url=FunctionUrl(url='/wiki/RemoveCommandHandler', name='removeCommandHandler', category='Input functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='removeCommandHandler', return_types=['bool'], arguments=[FunctionArgument(name='commandName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='handler', argument_type='function', default_value=None, optional=True)]), docs=FunctionDoc(description='This function removes a command handler, that is one that has been added using [[addCommandHandler]]. This function can only remove command handlers that were added by the resource that it is called in.', arguments={'commandName': 'the name of the command you wish to remove.', 'handler': 'the specific handler function to remove. If not specified, all handler functions for the command (from the calling resource) will be removed. This argument is only available in the server.'}, result="Returns ''true'' if the command handler was removed successfully, ''false'' if the command doesn't exist."), oop=None, url=FunctionUrl(url='/wiki/RemoveCommandHandler', name='removeCommandHandler', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='toggleAllControls', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='gtaControls', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='mtaControls', argument_type='bool', default_value='true', optional=False)]), docs=FunctionDoc(description='Enables or disables the use of all GTA controls for a specified player.', arguments={'thePlayer': 'The player you wish to toggle the control ability of.', 'enabled': 'A boolean value representing whether or not the controls will be usable.\n{{OptionalArg}}', 'gtaControls': 'A boolean deciding whether the enabled parameter will affect GTAs internal controls.', 'mtaControls': 'A boolean deciding whether the enabled parameter will affect MTAs own controls., e.g. chatbox.'}, result="This function returns ''true'' if controls were toggled successfully, false otherwise."), oop=None, url=FunctionUrl(url='/wiki/ToggleAllControls', name='toggleAllControls', category='Input functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='toggleAllControls', return_types=['bool'], arguments=[FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='gtaControls', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='mtaControls', argument_type='bool', default_value='true', optional=False)]), docs=FunctionDoc(description='Enables or disables the use of all GTA controls for a specified player.', arguments={'enabled': 'A boolean value representing whether or not the controls will be usable.\n{{OptionalArg}}', 'gtaControls': 'A boolean deciding whether the enabled parameter will affect GTAs internal controls.', 'mtaControls': 'A boolean deciding whether the enabled parameter will affect MTAs own controls., e.g. chatbox.'}, result="This function returns ''true'' if controls were toggled successfully, false otherwise."), oop=None, url=FunctionUrl(url='/wiki/ToggleAllControls', name='toggleAllControls', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='toggleControl', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='control', argument_type='string', default_value=None, optional=False), FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='Enables or disables the use of a GTA control for a specific player.', arguments={'thePlayer': 'The player you wish to toggle the control ability of.', 'control': 'The control that you want to toggle the ability of. See control names for a list of possible controls.', 'enabled': 'A boolean value representing whether or not the key will be usable or not.'}, result="This function ''true'' if the control was set successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ToggleControl', name='toggleControl', category='Input functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='toggleControl', return_types=['bool'], arguments=[FunctionArgument(name='control', argument_type='string', default_value=None, optional=False), FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='Enables or disables the use of a GTA control for a specific player.', arguments={'control': 'The control that you want to toggle the ability of. See control names for a list of possible controls.', 'enabled': 'A boolean value representing whether or not the key will be usable or not.'}, result="This function ''true'' if the control was set successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ToggleControl', name='toggleControl', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='unbindKey', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='keyState', argument_type='string', default_value=None, optional=False), FunctionArgument(name='command', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Removes an existing key bind from the specified player.', arguments={'thePlayer': 'The player you wish to unbind the key of.', 'key': 'The key you wish to unbind. See Key names for a list of valid key names.', 'keyState': 'is optional in Syntax 2.', '"up"': 'If the bound key triggered a function when the key was released', '"down"': 'If the bound key triggered a function when the key was pressed', '"both"': 'If the bound key triggered a function when the key was pressed and released', 'command ': '(Syntax 1) The command you wish to unbind.', 'handler': "(Syntax 2) The function you wish to unbind.\nNote: If you do not specify ''handler'', any instances of ''key'' being bound will be unbound, whatever function they are bound to."}, result="Returns '''true'' if the key was unbound, ''false'' if it was not previously bound or invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/UnbindKey', name='unbindKey', category='Input functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='unbindKey', return_types=['bool'], arguments=[FunctionArgument(name='key', argument_type='string', default_value=None, optional=False), FunctionArgument(name='keyState', argument_type='string', default_value=None, optional=False), FunctionArgument(name='command', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Removes an existing key bind from the specified player.', arguments={'key': 'The key you wish to unbind. See Key names for a list of valid key names.', 'keyState': 'is optional in Syntax 2.', '"up"': 'If the bound key triggered a function when the key was released', '"down"': 'If the bound key triggered a function when the key was pressed', '"both"': 'If the bound key triggered a function when the key was pressed and released', 'command ': '(Syntax 1) The command you wish to unbind.', 'handler': "(Syntax 2) The function you wish to unbind.\nNote: If you do not specify ''handler'', any instances of ''key'' being bound will be unbound, whatever function they are bound to."}, result="Returns '''true'' if the key was unbound, ''false'' if it was not previously bound or invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/UnbindKey', name='unbindKey', category='Input functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='createLight', return_types=['light'], arguments=[FunctionArgument(name='lightType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='radius', argument_type='float', default_value='3', optional=True), FunctionArgument(name='r', argument_type='int', default_value='255', optional=True), FunctionArgument(name='g', argument_type='int', default_value='0', optional=True), FunctionArgument(name='b', argument_type='int', default_value='0', optional=True), FunctionArgument(name='dirX', argument_type='float', default_value='0', optional=True), FunctionArgument(name='dirY', argument_type='float', default_value='0', optional=True), FunctionArgument(name='dirZ', argument_type='float', default_value='0', optional=True), FunctionArgument(name='createsShadow', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="* The direction of the light only has any effect if the light type is ''spot light''.\n* One light will only apply illumination effects to [[Element/Ped|peds]], [[Element/Player|players]], wheels and number plates (like a emergency vehicle siren light does).\n* Two or more lights will apply illumination effects to everything (excluding objects) that is in range of, at least, two of them.\n}}", arguments={'lightType': 'An integer representing the type of light to create.\n{{Light_types}}', 'posX': 'A floating point number representing the X coordinate on the map.', 'posY': 'A floating point number representing the Y coordinate on the map.', 'posZ': 'A floating point number representing the Z coordinate on the map.\n{{OptionalArg}} ', 'radius': 'A floating point number representing the radius of the light.', 'r': 'An integer number representing the amount of red to use in the colouring of the light (0 - 255).', 'g': 'An integer number representing the amount of green to use in the colouring of the light (0 - 255).', 'b': 'An integer number representing the amount of blue to use in the colouring of the light (0 - 255).', 'dirX': 'A floating point number representing the light directions X coordinate on the map.', 'dirY': 'A floating point number representing the light directions Y coordinate on the map.', 'dirZ': 'A floating point number representing the light directions Z coordinate on the map.', 'createsShadow': 'A boolean representing whether or not does the light cast shadows.'}, result=''), oop=None, url=FunctionUrl(url='/wiki/CreateLight', name='createLight', category='Light functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getLightColor', return_types=['int,', 'int,', 'int'], arguments=[FunctionArgument(name='theLight', argument_type='light', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the color for a [[Element/Light|light]] element.\n}}', arguments={'theLight': 'The Element/Light|light that you wish to retrieve the color of.'}, result=''), oop=FunctionOOP(class_name='light', method_name='getColor', field='color'), url=FunctionUrl(url='/wiki/GetLightColor', name='getLightColor', category='Light functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getLightDirection', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theLight', argument_type='light', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the direction for a [[Element/Light|light]] element.\n}}', arguments={'theLight': 'The Element/Light|light that you wish to retrieve the direction of.'}, result=''), oop=FunctionOOP(class_name='light', method_name='getDirection', field='direction'), url=FunctionUrl(url='/wiki/GetLightDirection', name='getLightDirection', category='Light functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getLightRadius', return_types=['float'], arguments=[FunctionArgument(name='theLight', argument_type='light', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the radius for a [[Element/Light|light]] element.\n}}', arguments={'theLight': 'The Element/Light|light that you wish to retrieve the radius of.'}, result=''), oop=FunctionOOP(class_name='light', method_name='getRadius', field='radius'), url=FunctionUrl(url='/wiki/GetLightRadius', name='getLightRadius', category='Light functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getLightType', return_types=['int'], arguments=[FunctionArgument(name='theLight', argument_type='light', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the type for a [[Element/Light|light]] element.\n}}', arguments={'theLight': 'The Element/Light|light that you wish to retrieve the type of.'}, result=''), oop=FunctionOOP(class_name='light', method_name="getType}}\n\n===Required Arguments=== \n*'''theLight:''' The [[Element/Light", field="light]] that you wish to retrieve the type of.\n\n=== Returns ===\nReturns an [[int]] containing the type of the specified light, ''false'' if invalid arguments were passed.\n\n"), url=FunctionUrl(url='/wiki/GetLightType', name='getLightType', category='Light functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setLightColor', return_types=['bool'], arguments=[FunctionArgument(name='theLight', argument_type='light', default_value=None, optional=False), FunctionArgument(name='r', argument_type='float', default_value=None, optional=False), FunctionArgument(name='g', argument_type='float', default_value=None, optional=False), FunctionArgument(name='b', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the color for a [[Element/Light|light]] element.', arguments={'theLight': 'The Element/Light|light that you wish to set the color of.'}, result=''), oop=FunctionOOP(class_name='light', method_name='setColor', field='color'), url=FunctionUrl(url='/wiki/SetLightColor', name='setLightColor', category='Light functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setLightDirection', return_types=['bool'], arguments=[FunctionArgument(name='theLight', argument_type='light', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the direction for a [[Element/Light|light]] element.', arguments={'theLight': 'The Element/Light|light that you wish to set the direction of.'}, result=''), oop=FunctionOOP(class_name='light', method_name='setDirection', field='direction'), url=FunctionUrl(url='/wiki/SetLightDirection', name='setLightDirection', category='Light functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setLightRadius', return_types=['bool'], arguments=[FunctionArgument(name='theLight', argument_type='Light', default_value=None, optional=False), FunctionArgument(name='radius', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the radius for a [[Element/Light|light]] element.\n}}', arguments={'theLight': 'The Element/Light|light that you wish to set the radius of.'}, result=''), oop=FunctionOOP(class_name='light', method_name='setRadius', field='radius'), url=FunctionUrl(url='/wiki/SetLightRadius', name='setLightRadius', category='Light functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createMarker', return_types=['marker'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='theType', argument_type='string', default_value='"checkpoint"', optional=True), FunctionArgument(name='size', argument_type='float', default_value='4.0', optional=True), FunctionArgument(name='r', argument_type='int', default_value='0', optional=True), FunctionArgument(name='g', argument_type='int', default_value='0', optional=True), FunctionArgument(name='b', argument_type='int', default_value='255', optional=True), FunctionArgument(name='a', argument_type='int', default_value='255', optional=True), FunctionArgument(name='visibleTo', argument_type='element', default_value='getRootElement(', optional=True)]), docs=FunctionDoc(description='[[Image:Mtasa_markers.png|thumb|337px|This image shows all the different marker types available using this function.]]\nThis function creates a marker. A marker is a 3D model in the world that can highlight a particular point or area, often used to instruct players where to go to perform actions such as entering buildings.\nThere are various limits that govern the maximum number of each type that can be visible at once. These are:\n* Coronas: 32\n* Checkpoints, Rings, Cylinders and Arrows combined: 32\nYou are able to create as many markers as you wish (memory and element limit permitting), but the player will only be able to see the nearest ones up to the limit.\n<br><br><br><br>', arguments={'x': ': A floating point number representing the X coordinate on the map.', 'y': ': A floating point number representing the Y coordinate on the map.', 'z': ': A floating point number representing the Z coordinate on the map.\n{{OptionalArg}}', 'theType': ': The visual type of the marker to be created. Possible values:\n{{Marker_types}}', 'size': ': The diameter of the marker to be created, in meters.', 'r': ': An integer number representing the amount of red to use in the colouring of the marker (0 - 255).', 'g': ': An integer number representing the amount of green to use in the colouring of the marker (0 - 255).', 'b': ': An integer number representing the amount of blue to use in the colouring of the marker (0 - 255).', 'a': ': An integer number representing the amount of alpha to use in the colouring of the marker (0 - 255 where 0 is transparent and 255 is opaque).', 'visibleTo': ': This defines which elements can see the marker. Defaults to visible to everyone. See visibility.'}, result="Returns the [[marker]] element that was created, or ''false'' if the arguments are incorrect."), oop=None, url=FunctionUrl(url='/wiki/CreateMarker', name='createMarker', category='Marker functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createMarker', return_types=['marker'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='theType', argument_type='string', default_value='"checkpoint"', optional=True), FunctionArgument(name='size', argument_type='float', default_value='4.0', optional=True), FunctionArgument(name='r', argument_type='int', default_value='0', optional=True), FunctionArgument(name='g', argument_type='int', default_value='0', optional=True), FunctionArgument(name='b', argument_type='int', default_value='255', optional=True), FunctionArgument(name='a', argument_type='int', default_value='255', optional=True)]), docs=FunctionDoc(description='[[Image:Mtasa_markers.png|thumb|337px|This image shows all the different marker types available using this function.]]\nThis function creates a marker. A marker is a 3D model in the world that can highlight a particular point or area, often used to instruct players where to go to perform actions such as entering buildings.\nThere are various limits that govern the maximum number of each type that can be visible at once. These are:\n* Coronas: 32\n* Checkpoints, Rings, Cylinders and Arrows combined: 32\nYou are able to create as many markers as you wish (memory and element limit permitting), but the player will only be able to see the nearest ones up to the limit.\n<br><br><br><br>', arguments={'x': ': A floating point number representing the X coordinate on the map.', 'y': ': A floating point number representing the Y coordinate on the map.', 'z': ': A floating point number representing the Z coordinate on the map.\n{{OptionalArg}}', 'theType': ': The visual type of the marker to be created. Possible values:\n{{Marker_types}}', 'size': ': The diameter of the marker to be created, in meters.', 'r': ': An integer number representing the amount of red to use in the colouring of the marker (0 - 255).', 'g': ': An integer number representing the amount of green to use in the colouring of the marker (0 - 255).', 'b': ': An integer number representing the amount of blue to use in the colouring of the marker (0 - 255).', 'a': ': An integer number representing the amount of alpha to use in the colouring of the marker (0 - 255 where 0 is transparent and 255 is opaque).'}, result="Returns the [[marker]] element that was created, or ''false'' if the arguments are incorrect."), oop=None, url=FunctionUrl(url='/wiki/CreateMarker', name='createMarker', category='Marker functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getMarkerColor', return_types=['int,', 'int,', 'int,', 'int'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the color and transparency for a marker element. Not all marker types support transparency.', arguments={'theMarker': ': The marker that you wish to retrieve the color of.'}, result="Returns four [[int]]s corresponding to the amount of ''red'', ''green'', ''blue'' and ''alpha'' (respectively) of the marker, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='Marker', method_name='getColor', field=None), url=FunctionUrl(url='/wiki/GetMarkerColor', name='getMarkerColor', category='Marker functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getMarkerColor', return_types=['int,', 'int,', 'int,', 'int'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the color and transparency for a marker element. Not all marker types support transparency.', arguments={'theMarker': ': The marker that you wish to retrieve the color of.'}, result="Returns four [[int]]s corresponding to the amount of ''red'', ''green'', ''blue'' and ''alpha'' (respectively) of the marker, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='Marker', method_name='getColor', field=None), url=FunctionUrl(url='/wiki/GetMarkerColor', name='getMarkerColor', category='Marker functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getMarkerCount', return_types=['int'], arguments=[]), docs=FunctionDoc(description='Returns the number of markers that currently exist in the world.', arguments={}, result='Returns the number of markers that currently exist.'), oop=None, url=FunctionUrl(url='/wiki/GetMarkerCount', name='getMarkerCount', category='Marker functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getMarkerCount', return_types=['int'], arguments=[]), docs=FunctionDoc(description='Returns the number of markers that currently exist in the world.', arguments={}, result='Returns the number of markers that currently exist.'), oop=None, url=FunctionUrl(url='/wiki/GetMarkerCount', name='getMarkerCount', category='Marker functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getMarkerIcon', return_types=['string'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the icon name for a marker.', arguments={'theMarker': ': A marker element referencing the specified marker.'}, result='Returns \'\'false\'\' if the marker passed is invalid or a string containing one of the following:\n* \'\'\'"none"\'\'\': No icon\n* \'\'\'"arrow"\'\'\': Arrow icon\n* \'\'\'"finish"\'\'\': Finish (end-race) icon'), oop=FunctionOOP(class_name='Marker', method_name='getIcon', field='icon'), url=FunctionUrl(url='/wiki/GetMarkerIcon', name='getMarkerIcon', category='Marker functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getMarkerIcon', return_types=['string'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the icon name for a marker.', arguments={'theMarker': ': A marker element referencing the specified marker.'}, result='Returns \'\'false\'\' if the marker passed is invalid or a string containing one of the following:\n* \'\'\'"none"\'\'\': No icon\n* \'\'\'"arrow"\'\'\': Arrow icon\n* \'\'\'"finish"\'\'\': Finish (end-race) icon'), oop=FunctionOOP(class_name='Marker', method_name='getIcon', field='icon'), url=FunctionUrl(url='/wiki/GetMarkerIcon', name='getMarkerIcon', category='Marker functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getMarkerSize', return_types=['float'], arguments=[FunctionArgument(name='myMarker', argument_type='marker', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a [[float]] containing the size of the specified marker.', arguments={'myMarker': ': The marker that you wish to retrieve the size of.'}, result='Returns a [[float]] containing the size of the specified marker.'), oop=FunctionOOP(class_name='Marker', method_name='getSize', field='size'), url=FunctionUrl(url='/wiki/GetMarkerSize', name='getMarkerSize', category='Marker functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getMarkerSize', return_types=['float'], arguments=[FunctionArgument(name='myMarker', argument_type='marker', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a [[float]] containing the size of the specified marker.', arguments={'myMarker': ': The marker that you wish to retrieve the size of.'}, result='Returns a [[float]] containing the size of the specified marker.'), oop=FunctionOOP(class_name='Marker', method_name='getSize', field='size'), url=FunctionUrl(url='/wiki/GetMarkerSize', name='getMarkerSize', category='Marker functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getMarkerTarget', return_types=['float', 'float', 'float'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False)]), docs=FunctionDoc(description="This function returns the position of the specified marker's target, the position it points to. This only works for checkpoint markers and ring markers. For checkpoints it returns the position the arrow is pointing to, for ring markers it returns the position the ring is facing. You can set this target with [[setMarkerTarget]].", arguments={'theMarker': 'The marker you wish to retrieve the target position of.'}, result="Returns three ''float''s if a target is set, or ''false'' in the first variable and ''nil'' in the two others if the marker is invalid or no target is set."), oop=FunctionOOP(class_name='Marker', method_name='getTarget', field='target'), url=FunctionUrl(url='/wiki/GetMarkerTarget', name='getMarkerTarget', category='Marker functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getMarkerTarget', return_types=['float', 'float', 'float'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False)]), docs=FunctionDoc(description="This function returns the position of the specified marker's target, the position it points to. This only works for checkpoint markers and ring markers. For checkpoints it returns the position the arrow is pointing to, for ring markers it returns the position the ring is facing. You can set this target with [[setMarkerTarget]].", arguments={'theMarker': 'The marker you wish to retrieve the target position of.'}, result="Returns three ''float''s if a target is set, or ''false'' in the first variable and ''nil'' in the two others if the marker is invalid or no target is set."), oop=FunctionOOP(class_name='Marker', method_name='getTarget', field='target'), url=FunctionUrl(url='/wiki/GetMarkerTarget', name='getMarkerTarget', category='Marker functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getMarkerType', return_types=['string'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False)]), docs=FunctionDoc(description="This function returns a marker's type.", arguments={'theMarker': ': A marker element referencing the specified marker.'}, result="* Returns one of the following strings:\n{{Marker_types}}\nIf an invalid marker is specified, ''false'' is returned."), oop=FunctionOOP(class_name='Marker', method_name='getMarkerType', field='markerType'), url=FunctionUrl(url='/wiki/GetMarkerType', name='getMarkerType', category='Marker functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getMarkerType', return_types=['string'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False)]), docs=FunctionDoc(description="This function returns a marker's type.", arguments={'theMarker': ': A marker element referencing the specified marker.'}, result="* Returns one of the following strings:\n{{Marker_types}}\nIf an invalid marker is specified, ''false'' is returned."), oop=FunctionOOP(class_name='Marker', method_name='getMarkerType', field='markerType'), url=FunctionUrl(url='/wiki/GetMarkerType', name='getMarkerType', category='Marker functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isElementWithinMarker', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to determine if an [[element]] is within a [[marker]].', arguments={'theElement': 'The element youre checking.', 'theMarker': 'The marker youre checking.'}, result="Returns ''true'' if the element is within the marker, ''false'' otherwise"), oop=FunctionOOP(class_name='element', method_name='isWithinMarker', field=None), url=FunctionUrl(url='/wiki/IsElementWithinMarker', name='isElementWithinMarker', category='Marker functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isElementWithinMarker', return_types=['bool'], arguments=[FunctionArgument(name='theElement', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to determine if an [[element]] is within a [[marker]].', arguments={'theElement': 'The element youre checking.', 'theMarker': 'The marker youre checking.'}, result="Returns ''true'' if the element is within the marker, ''false'' otherwise"), oop=FunctionOOP(class_name='element', method_name='isWithinMarker', field=None), url=FunctionUrl(url='/wiki/IsElementWithinMarker', name='isElementWithinMarker', category='Marker functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setMarkerColor', return_types=['bool'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False), FunctionArgument(name='r', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b', argument_type='int', default_value=None, optional=False), FunctionArgument(name='a', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the color of the specified marker by modifying the values for red, green, blue and alpha.', arguments={'theMarker': 'The marker that you wish to set the color of.', 'r': 'The amount of red in the final color (0 to 255).', 'g': 'The amount of green in the final color (0 to 255).', 'b': 'The amount of blue in the final color (0 to 255).', 'a': 'The amount of alpha in the final color (0 to 255).'}, result=''), oop=FunctionOOP(class_name='Marker', method_name='setColor', field=None), url=FunctionUrl(url='/wiki/SetMarkerColor', name='setMarkerColor', category='Marker functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setMarkerColor', return_types=['bool'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False), FunctionArgument(name='r', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b', argument_type='int', default_value=None, optional=False), FunctionArgument(name='a', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the color of the specified marker by modifying the values for red, green, blue and alpha.', arguments={'theMarker': 'The marker that you wish to set the color of.', 'r': 'The amount of red in the final color (0 to 255).', 'g': 'The amount of green in the final color (0 to 255).', 'b': 'The amount of blue in the final color (0 to 255).', 'a': 'The amount of alpha in the final color (0 to 255).'}, result=''), oop=FunctionOOP(class_name='Marker', method_name='setColor', field=None), url=FunctionUrl(url='/wiki/SetMarkerColor', name='setMarkerColor', category='Marker functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setMarkerIcon', return_types=['bool'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False), FunctionArgument(name='icon', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theMarker': 'The marker to change the visual style of', 'icon': 'A string referring to the type of icon, acceptable values are:', '"none"': ': No icon', '"arrow"': ': Arrow icon', '"finish"': ': Finish icon (at end of race)'}, result=''), oop=FunctionOOP(class_name='Marker', method_name='setIcon', field='icon'), url=FunctionUrl(url='/wiki/SetMarkerIcon', name='setMarkerIcon', category='Marker functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setMarkerIcon', return_types=['bool'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False), FunctionArgument(name='icon', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theMarker': 'The marker to change the visual style of', 'icon': 'A string referring to the type of icon, acceptable values are:', '"none"': ': No icon', '"arrow"': ': Arrow icon', '"finish"': ': Finish icon (at end of race)'}, result=''), oop=FunctionOOP(class_name='Marker', method_name='setIcon', field='icon'), url=FunctionUrl(url='/wiki/SetMarkerIcon', name='setMarkerIcon', category='Marker functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setMarkerSize', return_types=['bool'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False), FunctionArgument(name='size', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the size of the specified marker.\nSetting negative value will "flip" the marker, do nothing or make it invisible: \n* \'\'\'cylinder\'\'\' or \'\'\'arrow\'\'\': upside down\n* \'\'\'ring\'\'\': inside out\n* \'\'\'checkpoint\'\'\': disappear\n* \'\'\'corona\'\'\': bigger', arguments={'theMarker': 'The marker that you wish to set the size of.', 'size': 'A float representing new size of the marker.'}, result="Returns ''true'' if successful, ''false'' if failed."), oop=FunctionOOP(class_name='Marker', method_name='setSize', field='size'), url=FunctionUrl(url='/wiki/SetMarkerSize', name='setMarkerSize', category='Marker functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setMarkerSize', return_types=['bool'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False), FunctionArgument(name='size', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the size of the specified marker.\nSetting negative value will "flip" the marker, do nothing or make it invisible: \n* \'\'\'cylinder\'\'\' or \'\'\'arrow\'\'\': upside down\n* \'\'\'ring\'\'\': inside out\n* \'\'\'checkpoint\'\'\': disappear\n* \'\'\'corona\'\'\': bigger', arguments={'theMarker': 'The marker that you wish to set the size of.', 'size': 'A float representing new size of the marker.'}, result="Returns ''true'' if successful, ''false'' if failed."), oop=FunctionOOP(class_name='Marker', method_name='setSize', field='size'), url=FunctionUrl(url='/wiki/SetMarkerSize', name='setMarkerSize', category='Marker functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setMarkerTarget', return_types=['bool'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the 'target' for a marker. Only the ''checkpoint'' and ''ring'' marker types can have a target.\nFor ''checkpoint'' markers, the target is shown as an arrow aiming at the point specified.\nFor ''ring'' markers, the target is shown by rotating the whole ring so that it faces the point specified.\nThis function is most useful for setting up markers for races, where each marker points to the next one's position.\n(This is mostly used in races!)", arguments={'theMarker': 'The marker to set the target of', 'x': 'The x axis of the coordinate to target the marker at', 'y': 'The y axis of the coordinate to target the marker at', 'z': 'The z axis of the coordinate to target the marker at'}, result="Returns ''true'' if target was set, ''false'' otherwise."), oop=FunctionOOP(class_name='Marker', method_name='setTarget', field="getMarkerTarget}}\n===Required Arguments=== \n*'''theMarker:''' The marker to set the target of\n*'''x:''' The x axis of the coordinate to target the marker at\n*'''y:''' The y axis of the coordinate to target the marker at\n*'''z:''' The z axis of the coordinate to target the marker at\n\n===Returns===\nReturns ''true'' if target was set, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/SetMarkerTarget', name='setMarkerTarget', category='Marker functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setMarkerTarget', return_types=['bool'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the 'target' for a marker. Only the ''checkpoint'' and ''ring'' marker types can have a target.\nFor ''checkpoint'' markers, the target is shown as an arrow aiming at the point specified.\nFor ''ring'' markers, the target is shown by rotating the whole ring so that it faces the point specified.\nThis function is most useful for setting up markers for races, where each marker points to the next one's position.\n(This is mostly used in races!)", arguments={'theMarker': 'The marker to set the target of', 'x': 'The x axis of the coordinate to target the marker at', 'y': 'The y axis of the coordinate to target the marker at', 'z': 'The z axis of the coordinate to target the marker at'}, result="Returns ''true'' if target was set, ''false'' otherwise."), oop=FunctionOOP(class_name='Marker', method_name='setTarget', field="getMarkerTarget}}\n===Required Arguments=== \n*'''theMarker:''' The marker to set the target of\n*'''x:''' The x axis of the coordinate to target the marker at\n*'''y:''' The y axis of the coordinate to target the marker at\n*'''z:''' The z axis of the coordinate to target the marker at\n\n===Returns===\nReturns ''true'' if target was set, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/SetMarkerTarget', name='setMarkerTarget', category='Marker functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setMarkerType', return_types=['bool'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False), FunctionArgument(name='markerType', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function changes a marker's type. The type controls how the marker is displayed in the game. It's important that you use marker types that users are used to from the single player game. For example, checkpoints are used in races, rings are used for aircraft races, arrows are used for entering buildings etc. ", arguments={'theMarker': ': A marker element referencing the specified marker.', 'markerType': ': A string denoting the marker type. Valid values are:\n{{Marker types}}'}, result="Returns ''true'' if the marker type was changed, ''false'' if it wasn't or marker values were invalid."), oop=FunctionOOP(class_name='Marker', method_name='setMarkerType', field='markerType'), url=FunctionUrl(url='/wiki/SetMarkerType', name='setMarkerType', category='Marker functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setMarkerType', return_types=['bool'], arguments=[FunctionArgument(name='theMarker', argument_type='marker', default_value=None, optional=False), FunctionArgument(name='markerType', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function changes a marker's type. The type controls how the marker is displayed in the game. It's important that you use marker types that users are used to from the single player game. For example, checkpoints are used in races, rings are used for aircraft races, arrows are used for entering buildings etc. ", arguments={'theMarker': ': A marker element referencing the specified marker.', 'markerType': ': A string denoting the marker type. Valid values are:\n{{Marker types}}'}, result="Returns ''true'' if the marker type was changed, ''false'' if it wasn't or marker values were invalid."), oop=FunctionOOP(class_name='Marker', method_name='setMarkerType', field='markerType'), url=FunctionUrl(url='/wiki/SetMarkerType', name='setMarkerType', category='Marker functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='breakObject', return_types=['bool'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False)]), docs=FunctionDoc(description='This function breaks a specific object.', arguments={'theObject': 'an object element'}, result="* ''true'' if the object was successfully broken.\n* ''false'' if the object is not breakable, or a wrong object was given."), oop=None, url=FunctionUrl(url='/wiki/BreakObject', name='breakObject', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createObject', return_types=['object'], arguments=[FunctionArgument(name='modelId', argument_type='int', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rx', argument_type='float', default_value=None, optional=False), FunctionArgument(name='ry', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rz', argument_type='float', default_value=None, optional=False), FunctionArgument(name='isLowLOD', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='Creates an [[object]] [[element]] at a given position and rotation.', arguments={'modelId': 'A whole integer specifying the GTA:SA object model ID.', 'x': 'A floating point number representing the X coordinate on the map.', 'y': 'A floating point number representing the Y coordinate on the map.', 'z': 'A floating point number representing the Z coordinate on the map.\n{{OptionalArg}} ', 'rx': 'A floating point number representing the rotation about the X axis in degrees.', 'ry': 'A floating point number representing the rotation about the Y axis in degrees.', 'rz': 'A floating point number representing the rotation about the Z axis in degrees.\n{{New items|3.0120|1.2|', 'isLowLOD': 'A bool value specifying if the object will be low LOD. A low LOD object has no collision and a longer draw distance.\n}}'}, result="* Returns the [[object]] element if the creation was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/CreateObject', name='createObject', category='Object functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createObject', return_types=['object'], arguments=[FunctionArgument(name='modelId', argument_type='int', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rx', argument_type='float', default_value=None, optional=False), FunctionArgument(name='ry', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rz', argument_type='float', default_value=None, optional=False), FunctionArgument(name='isLowLOD', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='Creates an [[object]] [[element]] at a given position and rotation.', arguments={'modelId': 'A whole integer specifying the GTA:SA object model ID.', 'x': 'A floating point number representing the X coordinate on the map.', 'y': 'A floating point number representing the Y coordinate on the map.', 'z': 'A floating point number representing the Z coordinate on the map.\n{{OptionalArg}} ', 'rx': 'A floating point number representing the rotation about the X axis in degrees.', 'ry': 'A floating point number representing the rotation about the Y axis in degrees.', 'rz': 'A floating point number representing the rotation about the Z axis in degrees.\n{{New items|3.0120|1.2|', 'isLowLOD': 'A bool value specifying if the object will be low LOD. A low LOD object has no collision and a longer draw distance.\n}}'}, result="* Returns the [[object]] element if the creation was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/CreateObject', name='createObject', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getObjectMass', return_types=['float'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the mass of a specified object.\n}}', arguments={'theObject': 'the object whose mass you want to get.'}, result="* A [[float]] representing the mass of the object.\n* ''false'' if invalid arguments were passed.\n* ''-1'' if object was never streamed in."), oop=FunctionOOP(class_name='object', method_name='getMass', field='mass'), url=FunctionUrl(url='/wiki/GetObjectMass', name='getObjectMass', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getObjectScale', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the visible size of an object.', arguments={'theObject': ': the object you wish to return the scale of.'}, result="* Three [[float]] values indicating the scale of the object on the x, y, and z axis if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='Object', method_name='getScale', field='scale'), url=FunctionUrl(url='/wiki/GetObjectScale', name='getObjectScale', category='Object functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getObjectScale', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the visible size of an object.', arguments={'theObject': ': the object you wish to return the scale of.'}, result="* Three [[float]] values indicating the scale of the object on the x, y, and z axis if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='Object', method_name='getScale', field='scale'), url=FunctionUrl(url='/wiki/GetObjectScale', name='getObjectScale', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isObjectBreakable', return_types=['bool'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if an object / model ID is breakable.', arguments={'theObject / modelId': 'The object / model ID thats being checked.'}, result="* ''true'' if the object is breakable.\n* ''false'' if the object is not breakable."), oop=FunctionOOP(class_name='object', method_name='isBreakable', field='breakable'), url=FunctionUrl(url='/wiki/IsObjectBreakable', name='isObjectBreakable', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='moveObject', return_types=['bool'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False), FunctionArgument(name='time', argument_type='int', default_value=None, optional=False), FunctionArgument(name='targetx', argument_type='float', default_value=None, optional=False), FunctionArgument(name='targety', argument_type='float', default_value=None, optional=False), FunctionArgument(name='targetz', argument_type='float', default_value=None, optional=False), FunctionArgument(name='moverx', argument_type='float', default_value=None, optional=False), FunctionArgument(name='movery', argument_type='float', default_value=None, optional=False), FunctionArgument(name='moverz', argument_type='float', default_value=None, optional=False), FunctionArgument(name='strEasingType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='fEasingPeriod', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fEasingAmplitude', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fEasingOvershoot', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will smoothly move an object from its current position to a specified rotation and position.', arguments={'theObject': 'the object that will be moved.', 'time': 'the time in milliseconds the object will arrive at the destination.', 'targetx': 'the X value of the target position', 'targety': 'the Y value of the target position', 'targetz': 'the Z value of the target position', 'moverx': 'the rotation along the X axis relative to its current rotation, which is its starting angle.', 'movery': 'the rotation along the Y axis relative to its current rotation, which is its starting angle.', 'moverz': 'the rotation along the Z axis relative to its current rotation, which is its starting angle.', 'strEasingType': 'the Easing|easing function to use for the interpolation (default is Linear)', 'fEasingPeriod': 'the period of the Easing|easing function (only some easing functions use this parameter)', 'fEasingAmplitude': 'the amplitude of the Easing|easing function (only some easing functions use this parameter)', 'fEasingOvershoot': 'the overshoot of the Easing|easing function (only some easing functions use this parameter)'}, result="* ''true'' if the function moved the object succesfully.\n* ''false'' otherwise."), oop=FunctionOOP(class_name='object', method_name='move', field=None), url=FunctionUrl(url='/wiki/MoveObject', name='moveObject', category='Object functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='moveObject', return_types=['bool'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False), FunctionArgument(name='time', argument_type='int', default_value=None, optional=False), FunctionArgument(name='targetx', argument_type='float', default_value=None, optional=False), FunctionArgument(name='targety', argument_type='float', default_value=None, optional=False), FunctionArgument(name='targetz', argument_type='float', default_value=None, optional=False), FunctionArgument(name='moverx', argument_type='float', default_value=None, optional=False), FunctionArgument(name='movery', argument_type='float', default_value=None, optional=False), FunctionArgument(name='moverz', argument_type='float', default_value=None, optional=False), FunctionArgument(name='strEasingType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='fEasingPeriod', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fEasingAmplitude', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fEasingOvershoot', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will smoothly move an object from its current position to a specified rotation and position.', arguments={'theObject': 'the object that will be moved.', 'time': 'the time in milliseconds the object will arrive at the destination.', 'targetx': 'the X value of the target position', 'targety': 'the Y value of the target position', 'targetz': 'the Z value of the target position', 'moverx': 'the rotation along the X axis relative to its current rotation, which is its starting angle.', 'movery': 'the rotation along the Y axis relative to its current rotation, which is its starting angle.', 'moverz': 'the rotation along the Z axis relative to its current rotation, which is its starting angle.', 'strEasingType': 'the Easing|easing function to use for the interpolation (default is Linear)', 'fEasingPeriod': 'the period of the Easing|easing function (only some easing functions use this parameter)', 'fEasingAmplitude': 'the amplitude of the Easing|easing function (only some easing functions use this parameter)', 'fEasingOvershoot': 'the overshoot of the Easing|easing function (only some easing functions use this parameter)'}, result="* ''true'' if the function moved the object succesfully.\n* ''false'' otherwise."), oop=FunctionOOP(class_name='object', method_name='move', field=None), url=FunctionUrl(url='/wiki/MoveObject', name='moveObject', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='respawnObject', return_types=['bool'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False)]), docs=FunctionDoc(description='This function respawns a specific object.', arguments={'theObject': 'an object element'}, result="* ''true'' if the object was sucessfully respawned.\n* ''false'' if the object is not breakable, or a wrong object was given."), oop=None, url=FunctionUrl(url='/wiki/RespawnObject', name='respawnObject', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setObjectBreakable', return_types=['bool'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False), FunctionArgument(name='breakable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets an object to be breakable/unbreakable.', arguments={'object': 'the object thats being set.', 'breakable': 'a boolean whether the object is breakable (true) or unbreakable (false).'}, result="* ''true'' if the object is now breakable.\n* ''false'' if it can't or if invalid arguments are passed. "), oop=FunctionOOP(class_name='object', method_name='setBreakable', field='breakable'), url=FunctionUrl(url='/wiki/SetObjectBreakable', name='setObjectBreakable', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setObjectMass', return_types=['bool'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False), FunctionArgument(name='mass', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the mass of a specified object. Changing the mass leads to a different movement behavior for especially dynamic objects.\n}}', arguments={'theObject': 'the object whose mass will be set.', 'mass': 'the new mass.'}, result="* ''true'' if the new mass value has been.\n* ''false'' otherwise."), oop=FunctionOOP(class_name='object', method_name='setMass', field='mass'), url=FunctionUrl(url='/wiki/SetObjectMass', name='setObjectMass', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setObjectScale', return_types=['bool'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False), FunctionArgument(name='scale', argument_type='float', default_value=None, optional=False), FunctionArgument(name='scaleY', argument_type='float', default_value='scale', optional=True), FunctionArgument(name='scaleZ', argument_type='float', default_value='scale', optional=True)]), docs=FunctionDoc(description='This function changes the visible size of an object.', arguments={'theObject': ': the object you wish to change the scale of.', 'scale': ': a float containing the new scale. 1.0 is the standard scale, with 0.5 being half the size and 2.0 being twice the size. If the scaleY is set, this will be scaleX.', 'scaleY': ': a float containing the new scale on the Y axis', 'scaleZ': ': a float containing the new scale on the Z axis'}, result="* ''true'' if the scale was set properly.\n* ''false'' otherwise."), oop=FunctionOOP(class_name='object', method_name='setScale', field='scale'), url=FunctionUrl(url='/wiki/SetObjectScale', name='setObjectScale', category='Object functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setObjectScale', return_types=['bool'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False), FunctionArgument(name='scale', argument_type='float', default_value=None, optional=False), FunctionArgument(name='scaleY', argument_type='float', default_value='scale', optional=True), FunctionArgument(name='scaleZ', argument_type='float', default_value='scale', optional=True)]), docs=FunctionDoc(description='This function changes the visible size of an object.', arguments={'theObject': ': the object you wish to change the scale of.', 'scale': ': a float containing the new scale. 1.0 is the standard scale, with 0.5 being half the size and 2.0 being twice the size. If the scaleY is set, this will be scaleX.', 'scaleY': ': a float containing the new scale on the Y axis', 'scaleZ': ': a float containing the new scale on the Z axis'}, result="* ''true'' if the scale was set properly.\n* ''false'' otherwise."), oop=FunctionOOP(class_name='object', method_name='setScale', field='scale'), url=FunctionUrl(url='/wiki/SetObjectScale', name='setObjectScale', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='stopObject', return_types=['bool'], arguments=[FunctionArgument(name='theobject', argument_type='object', default_value=None, optional=False)]), docs=FunctionDoc(description='This will allow you to stop an object that is currently moving.', arguments={'theobject': 'the object whose movement you wish to stop'}, result="* ''true'' if successful.\n* ''false'' otherwise."), oop=FunctionOOP(class_name='object', method_name='stop', field=None), url=FunctionUrl(url='/wiki/StopObject', name='stopObject', category='Object functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='stopObject', return_types=['bool'], arguments=[FunctionArgument(name='theobject', argument_type='object', default_value=None, optional=False)]), docs=FunctionDoc(description='This will allow you to stop an object that is currently moving.', arguments={'theobject': 'the object whose movement you wish to stop'}, result="* ''true'' if successful.\n* ''false'' otherwise."), oop=FunctionOOP(class_name='object', method_name='stop', field=None), url=FunctionUrl(url='/wiki/StopObject', name='stopObject', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='toggleObjectRespawn', return_types=['bool'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False), FunctionArgument(name='respawn', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to toggle if an object should respawn after it got destroyed\n}}', arguments={'theObject': ': the object you want to toggle the respawn from', 'respawn ': ': a bool denoting whether we want to enable (true) or disable (false) respawning'}, result="* ''true'' when the it was changed successfully.\n* ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ToggleObjectRespawn', name='toggleObjectRespawn', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getObjectProperty', return_types=['mixed'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theObject': ': the object you wish to get a property of.', 'property': ': the property you want to get the value of:\n<div style="padding-left:20px">\n* "all" - \'\'table\'\' with values of all properties below (OOP method: \'\'getProperties\'\')\n</div>\n{{Object Properties}}'}, result="On success: [[table]] for '''all''', 3 [[float|floats]] for '''center_of_mass''' or [[float]] for other properties\nOn failure: ''false''"), oop=FunctionOOP(class_name='object', method_name='getProperty', field=None), url=FunctionUrl(url='/wiki/GetObjectProperty', name='getObjectProperty', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setObjectProperty', return_types=['bool'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='var', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theObject': ': the object you wish to change a property of.', 'property': ': the property you want to set the value of:\n{{Object Properties}}', 'value': ': the new value for the property.'}, result="Returns ''true'' if the property was set successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='object', method_name='setProperty', field=None), url=FunctionUrl(url='/wiki/SetObjectProperty', name='setObjectProperty', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isObjectMoving', return_types=['bool'], arguments=[FunctionArgument(name='theObject', argument_type='object', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theObject': 'The object'}, result="* ''true'' if the object is moving.\n* ''false'' if the object is not moving."), oop=None, url=FunctionUrl(url='/wiki/IsObjectMoving', name='isObjectMoving', category='Object functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='clearChatBox', return_types=['bool'], arguments=[FunctionArgument(name='clearFor', argument_type='element', default_value='getRootElement(', optional=False)]), docs=FunctionDoc(description='', arguments={'clearFor ': 'The player whose chat is to be cleared. By default, this is set to the root element, which will affect all players.'}, result="Returns ''true'' if the player's chat was cleared successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ClearChatBox', name='clearChatBox', category='Output functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='clearChatBox', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='', arguments={}, result="Returns ''true'' if the player's chat was cleared successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ClearChatBox', name='clearChatBox', category='Output functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isChatVisible', return_types=['bool'], arguments=[]), docs=FunctionDoc(description="This function checks if player's chat is visible.", arguments={}, result="Returns ''true'' if the chat is visible, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsChatVisible', name='isChatVisible', category='Output functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='outputChatBox', return_types=['bool'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='visibleTo', argument_type='element', default_value='root', optional=True), FunctionArgument(name='r', argument_type='int', default_value='231', optional=True), FunctionArgument(name='g', argument_type='int', default_value='217', optional=True), FunctionArgument(name='b', argument_type='int', default_value='176', optional=True), FunctionArgument(name='colorCoded', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This outputs the specified text string to the chatbox. It can be specified as a message to certain player(s) or all players.\nIt can optionally allow you to embed color changes into the string by setting the colorCoded boolean to true. This allows: \n<syntaxhighlight lang="lua">\noutputChatBox ( "#FF0000Hello #00FF00World", root, 255, 255, 255, true )\n</syntaxhighlight>\nThis will display as: \'\'\'<span style=\'color:red;\'>Hello</span> <span style=\'color:green\'>World</span> \'\'\'', arguments={'text': 'The text string that you wish to send to the chat window. If more than 256 characters it will not be showed in chat.\n{{OptionalArg}}', 'visibleTo': 'Can also be a table of players or team.}}', 'r': 'The amount of red in the color of the text. Default value is 231.', 'g': 'The amount of green in the color of the text. Default value is 217.', 'b': 'The amount of blue in the color of the text. Default value is 176.', 'colorCoded': "A boolean value determining whether or not #RRGGBB tags should be used.\nNote: The #RRGGBB format must contain capital letters a-f is not acceptable but A-F is. Default RGB values in this format are: '#E7D9B0'."}, result="Returns ''true'' if the message was displayed successfully. Returns ''false'' if invalid arguments are specified."), oop=FunctionOOP(class_name='player', method_name="outputChat}}\n==Required Arguments==\n*'''text:''' The text string that you wish to send to the chat window. If more than 256 characters it will not be showed in chat.\n\n==Optional Arguments==\n{{OptionalArg}}\n*'''visibleTo:''' This specifies who the chat is visible to. Any players in this element will see the chat message. See [[visibility]].\n{{New items", field='5.0157'), url=FunctionUrl(url='/wiki/OutputChatBox', name='outputChatBox', category='Output functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='outputChatBox', return_types=['bool'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='r', argument_type='int', default_value='231', optional=True), FunctionArgument(name='g', argument_type='int', default_value='217', optional=True), FunctionArgument(name='b', argument_type='int', default_value='176', optional=True), FunctionArgument(name='colorCoded', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This outputs the specified text string to the chatbox. It can be specified as a message to certain player(s) or all players.\nIt can optionally allow you to embed color changes into the string by setting the colorCoded boolean to true. This allows: \n<syntaxhighlight lang="lua">\noutputChatBox ( "#FF0000Hello #00FF00World", root, 255, 255, 255, true )\n</syntaxhighlight>\nThis will display as: \'\'\'<span style=\'color:red;\'>Hello</span> <span style=\'color:green\'>World</span> \'\'\'', arguments={'text': 'The text string that you wish to send to the chat window. If more than 256 characters it will not be showed in chat.\n{{OptionalArg}}', 'r': 'The amount of red in the color of the text. Default value is 231.', 'g': 'The amount of green in the color of the text. Default value is 217.', 'b': 'The amount of blue in the color of the text. Default value is 176.', 'colorCoded': "A boolean value determining whether or not #RRGGBB tags should be used.\nNote: The #RRGGBB format must contain capital letters a-f is not acceptable but A-F is. Default RGB values in this format are: '#E7D9B0'."}, result="Returns ''true'' if the message was displayed successfully. Returns ''false'' if invalid arguments are specified."), oop=None, url=FunctionUrl(url='/wiki/OutputChatBox', name='outputChatBox', category='Output functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='outputConsole', return_types=['bool'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='visibleTo', argument_type='element', default_value='getRootElement(', optional=False)]), docs=FunctionDoc(description='This outputs the specified text string to the console window (accessed with F8 or ~ key). It can be specified as a message to certain player(s) or all players.', arguments={'text': 'The text string that you wish to send to the console window', 'visibleTo': "This specifies who the chat is visible to. Any players in this element will see the chat message. See visibility.\n{{Note|'''visibleTo''' can also be a Team object, in this case, the text will be visible to all the players of that team.}}"}, result=''), oop=None, url=FunctionUrl(url='/wiki/OutputConsole', name='outputConsole', category='Output functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='outputConsole', return_types=['bool'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This outputs the specified text string to the console window (accessed with F8 or ~ key). It can be specified as a message to certain player(s) or all players.', arguments={'text': 'The text string that you wish to send to the console window'}, result=''), oop=None, url=FunctionUrl(url='/wiki/OutputConsole', name='outputConsole', category='Output functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='outputDebugString', return_types=['bool'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='level', argument_type='int', default_value='3', optional=False), FunctionArgument(name='red', argument_type='int', default_value='255', optional=False), FunctionArgument(name='green', argument_type='int', default_value='255', optional=False), FunctionArgument(name='blue', argument_type='int', default_value='255', optional=False)]), docs=FunctionDoc(description='This function outputs scripting debug messages, which can be read by enabling the debug textbox. The debug display level can then be set so that info or warning messages get filtered out.', arguments={'text': 'the text to be output to the debug box.\n{{OptionalArg}} ', 'level': 'the debug message level. Possible values are:', '0': 'Custom message', '1': 'Error message', '2': 'Warning message', '3': 'Information message (default)\n{{New items|5.0157|1.5.7-9.20477|', '4': 'Custom message (omits file path and line number)}}', 'red': 'The amount of red in the color of the text. Default value is 255.', 'green': 'The amount of green in the color of the text. Default value is 255.', 'blue': 'The amount of blue in the color of the text. Default value is 255.\n{{Note|Color values are only applied when debug level is 0 or 4.}}'}, result="Returns ''true'' if the debug message was successfully output, ''false'' if invalid arguments are specified."), oop=None, url=FunctionUrl(url='/wiki/OutputDebugString', name='outputDebugString', category='Output functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='outputDebugString', return_types=['bool'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='level', argument_type='int', default_value='3', optional=False), FunctionArgument(name='red', argument_type='int', default_value='255', optional=False), FunctionArgument(name='green', argument_type='int', default_value='255', optional=False), FunctionArgument(name='blue', argument_type='int', default_value='255', optional=False)]), docs=FunctionDoc(description='This function outputs scripting debug messages, which can be read by enabling the debug textbox. The debug display level can then be set so that info or warning messages get filtered out.', arguments={'text': 'the text to be output to the debug box.\n{{OptionalArg}} ', 'level': 'the debug message level. Possible values are:', '0': 'Custom message', '1': 'Error message', '2': 'Warning message', '3': 'Information message (default)\n{{New items|5.0157|1.5.7-9.20477|', '4': 'Custom message (omits file path and line number)}}', 'red': 'The amount of red in the color of the text. Default value is 255.', 'green': 'The amount of green in the color of the text. Default value is 255.', 'blue': 'The amount of blue in the color of the text. Default value is 255.\n{{Note|Color values are only applied when debug level is 0 or 4.}}'}, result="Returns ''true'' if the debug message was successfully output, ''false'' if invalid arguments are specified."), oop=None, url=FunctionUrl(url='/wiki/OutputDebugString', name='outputDebugString', category='Output functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='showChat', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='show', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to show or hide the player's chat.", arguments={'thePlayer': 'The player whose chat is to be hidden or shown.', 'show': 'A boolean value determining whether to show (true) or hide (false) the chat.'}, result="Returns ''true'' if the player's chat was shown or hidden successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ShowChat', name='showChat', category='Output functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='showChat', return_types=['bool'], arguments=[FunctionArgument(name='show', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to show or hide the player's chat.", arguments={'show': 'A boolean value determining whether to show (true) or hide (false) the chat.'}, result="Returns ''true'' if the player's chat was shown or hidden successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ShowChat', name='showChat', category='Output functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='addPedClothes', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='clothesTexture', argument_type='string', default_value=None, optional=False), FunctionArgument(name='clothesModel', argument_type='string', default_value=None, optional=False), FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the current clothes on a [[ped]]. ', arguments={'thePed': ': The ped whose clothes you want to change.', 'clothesTexture': ': A string determining the clothes texture that will be added. See the CJ Clothes|clothes catalog.', 'clothesModel': ': A string determining the clothes model that will be added. See the CJ Clothes|clothes catalog.', 'clothesType': ': A integer representing the clothes slot/type the clothes should be added to. See the CJ Clothes|clothes catalog.'}, result="This function returns ''true'' if the clothes were successfully added to the ped, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='addClothes', field=None), url=FunctionUrl(url='/wiki/AddPedClothes', name='addPedClothes', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='addPedClothes', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='clothesTexture', argument_type='string', default_value=None, optional=False), FunctionArgument(name='clothesModel', argument_type='string', default_value=None, optional=False), FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the current clothes on a [[ped]]. ', arguments={'thePed': ': The ped whose clothes you want to change.', 'clothesTexture': ': A string determining the clothes texture that will be added. See the CJ Clothes|clothes catalog.', 'clothesModel': ': A string determining the clothes model that will be added. See the CJ Clothes|clothes catalog.', 'clothesType': ': A integer representing the clothes slot/type the clothes should be added to. See the CJ Clothes|clothes catalog.'}, result="This function returns ''true'' if the clothes were successfully added to the ped, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='addClothes', field=None), url=FunctionUrl(url='/wiki/AddPedClothes', name='addPedClothes', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='canPedBeKnockedOffBike', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if the given ped can fall off bikes.', arguments={'thePed': 'the ped you want to check.'}, result="Returns ''true'' if the ped can be knocked off bikes, ''false'' if he cannot or an invalid element was passed."), oop=FunctionOOP(class_name='ped', method_name='canBeKnockedOffBike', field=None), url=FunctionUrl(url='/wiki/CanPedBeKnockedOffBike', name='canPedBeKnockedOffBike', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createPed', return_types=['ped'], arguments=[FunctionArgument(name='modelid', argument_type='int', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rot', argument_type='float', default_value='0.0', optional=True), FunctionArgument(name='synced', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description='Creates a Ped in the GTA world.', arguments={'modelid': 'A whole integer specifying the Character_Skins|GTASA skin ID.', 'x': 'A floating point number representing the X coordinate on the map.', 'y': 'A floating point number representing the Y coordinate on the map.', 'z': 'A floating point number representing the Z coordinate on the map.\n{{OptionalArg}}', 'rot': 'A floating point number representing the rotation in degrees.', 'synced': 'A boolean value representing whether or not the ped will be synced. Disabling the sync might be useful for frozen or static peds to increase the server performance.'}, result='Returns a ped element if it was successfully created.'), oop=None, url=FunctionUrl(url='/wiki/CreatePed', name='createPed', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createPed', return_types=['ped'], arguments=[FunctionArgument(name='modelid', argument_type='int', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rot', argument_type='float', default_value='0.0', optional=True)]), docs=FunctionDoc(description='Creates a Ped in the GTA world.', arguments={'modelid': 'A whole integer specifying the Character_Skins|GTASA skin ID.', 'x': 'A floating point number representing the X coordinate on the map.', 'y': 'A floating point number representing the Y coordinate on the map.', 'z': 'A floating point number representing the Z coordinate on the map.\n{{OptionalArg}}', 'rot': 'A floating point number representing the rotation in degrees.'}, result='Returns a ped element if it was successfully created.'), oop=None, url=FunctionUrl(url='/wiki/CreatePed', name='createPed', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedAmmoInClip', return_types=['int'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='weaponSlot', argument_type='int', default_value='current', optional=True)]), docs=FunctionDoc(description="This function returns an integer that contains the ammo in a specified [[ped]]'s weapon. See [[weapon|Weapon Info]]", arguments={'thePed': 'The ped whose ammo you want to check.', 'weaponSlot': 'an integer representing the weapon slot (set to the peds currently selected slot if not specified).'}, result="Returns an [[int]] containing the amount of ammo in the specified ped's currently selected or specified clip, or 0 if the ped specified is invalid."), oop=FunctionOOP(class_name='ped', method_name='getAmmoInClip', field="ammoInClip}}\n\n===Required Arguments===\n*'''thePed:''' The [[ped]] whose ammo you want to check.\n\n===Optional Arguments===\n*'''weaponSlot:''' an integer representing the weapon slot (set to the ped's currently selected slot if not specified).\n\n===Returns===\nReturns an [[int]] containing the amount of ammo in the specified ped's currently selected or specified clip, or 0 if the ped specified is invalid.\n\n"), url=FunctionUrl(url='/wiki/GetPedAmmoInClip', name='getPedAmmoInClip', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPedAmmoInClip', return_types=['int'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='weaponSlot', argument_type='int', default_value='current', optional=True)]), docs=FunctionDoc(description="This function returns an integer that contains the ammo in a specified [[ped]]'s weapon. See [[weapon|Weapon Info]]", arguments={'thePed': 'The ped whose ammo you want to check.', 'weaponSlot': 'an integer representing the weapon slot (set to the peds currently selected slot if not specified).'}, result="Returns an [[int]] containing the amount of ammo in the specified ped's currently selected or specified clip, or 0 if the ped specified is invalid."), oop=FunctionOOP(class_name='ped', method_name='getAmmoInClip', field="ammoInClip}}\n\n===Required Arguments===\n*'''thePed:''' The [[ped]] whose ammo you want to check.\n\n===Optional Arguments===\n*'''weaponSlot:''' an integer representing the weapon slot (set to the ped's currently selected slot if not specified).\n\n===Returns===\nReturns an [[int]] containing the amount of ammo in the specified ped's currently selected or specified clip, or 0 if the ped specified is invalid.\n\n"), url=FunctionUrl(url='/wiki/GetPedAmmoInClip', name='getPedAmmoInClip', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedAnalogControlState', return_types=['float'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='controlName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='rawValue', argument_type='bool', default_value=None, optional=True)]), docs=FunctionDoc(description='This function retrieves the analog control state of a ped, as set by [[setPedAnalogControlState]].', arguments={'thePed': 'The ped you wish to retrieve the control state of.', 'controlName': 'The control. See control names for a list of possible controls.\n{{New feature/item|3.0160|1.5.7|20383|', 'rawValue': 'A bool indicating if it should return the raw player input value (will always return script value for non-player peds).\n}}'}, result='Returns a float between 0 ( full release ) and 1 ( full push ) indicating the amount the control is pushed.\n<section name="Client-side example" class="client" show="true">\n<syntaxhighlight lang="lua">\nx, y, z = getElementPosition(localPlayer)\nrotX, rotY, rotZ = getElementRotation(localPlayer)\nCJ = createPed(0, x, y, z)\nCJ2 = createPed(0, x, y, z)\ncopcar = createVehicle(597, x, y+5, z+2)\ncopcar2 = createVehicle(597, x+2, y+10, z+4)\nwarpPedIntoVehicle(CJ2, copcar2, 0)\nwarpPedIntoVehicle(CJ, copcar, 0)\nfunction onGetCJAnalogControlState()\nsetPedAnalogControlState(CJ, "accelerate", 0.90)\nif getPedAnalogControlState(CJ, "accelerate", 0.90) then\nsetPedAnalogControlState(CJ2, "brake_reverse", 0.90)\nend\nend\naddEventHandler("onClientRender", getRootElement(), onGetCJAnalogControlState)\n</syntaxhighlight>\n</section>\n<br /><br />\n* This example was created by \'\'\'Hydra\'\'\'.'), oop=None, url=FunctionUrl(url='/wiki/GetPedAnalogControlState', name='getPedAnalogControlState', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedAnimation', return_types=['string,', 'string'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the animation of a player or ped that was set using [[setPedAnimation]].', arguments={'thePed': 'the player or ped you want to get the animations|animation of.'}, result='Returns two [[string|strings]]: the first is the name of the block, the second is the name of the animation. Returns \'\'false\'\' if there was an error or if the ped is not doing an animation.\n{{New feature/item|3.0160|1.5.7|20450|<syntaxhighlight lang="lua"> string, string, int, int, bool, bool, bool, int, bool getPedAnimation ( ped thePed )</syntaxhighlight>\n\'\'\'The function now returns 9 values in the same order as required by setPedAnimation:\'\'\'\n<syntaxhighlight lang="lua">string anim, string block, int time, bool loop, bool updatePosition, bool interruptable, bool freezeLastFrame, int blendTime, bool restoreTaskOnAnimEnd</syntaxhighlight>\n}}'), oop=FunctionOOP(class_name='ped', method_name='getAnimation', field=None), url=FunctionUrl(url='/wiki/GetPedAnimation', name='getPedAnimation', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedArmor', return_types=['float'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current armor of the specified [[ped]].', arguments={'thePed': 'The ped whose armor you want to check'}, result="A ''float'' with the armor, ''false'' if an invalid ped was given."), oop=FunctionOOP(class_name='ped', method_name='getArmor', field='armor'), url=FunctionUrl(url='/wiki/GetPedArmor', name='getPedArmor', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPedArmor', return_types=['float'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current armor of the specified [[ped]].', arguments={'thePed': 'The ped whose armor you want to check'}, result="A ''float'' with the armor, ''false'' if an invalid ped was given."), oop=FunctionOOP(class_name='ped', method_name='getArmor', field='armor'), url=FunctionUrl(url='/wiki/GetPedArmor', name='getPedArmor', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedBonePosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='bone', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the 3D world coordinates of a specific bone of a given ped.', arguments={'thePed': 'the ped you want to inspect.', 'bone': 'the number of the bone to get the position of.\n[[Image:Bones.jpg|thumb|Bone numbers]]\n<div style="border: 3px red solid; margin-bottom:3px; padding-left:5px;">', '1': 'BONE_PELVIS1', '2': 'BONE_PELVIS', '3': 'BONE_SPINE1', '4': 'BONE_UPPERTORSO', '5': 'BONE_NECK', '6': 'BONE_HEAD2', '7': 'BONE_HEAD1', '8': 'BONE_HEAD', '21': 'BONE_RIGHTUPPERTORSO', '22': 'BONE_RIGHTSHOULDER', '23': 'BONE_RIGHTELBOW', '24': 'BONE_RIGHTWRIST', '25': 'BONE_RIGHTHAND', '26': 'BONE_RIGHTTHUMB', '31': 'BONE_LEFTUPPERTORSO', '32': 'BONE_LEFTSHOULDER', '33': 'BONE_LEFTELBOW', '34': 'BONE_LEFTWRIST', '35': 'BONE_LEFTHAND', '36': 'BONE_LEFTTHUMB', '41': 'BONE_LEFTHIP', '42': 'BONE_LEFTKNEE', '43': 'BONE_LEFTANKLE', '44': 'BONE_LEFTFOOT', '51': 'BONE_RIGHTHIP', '52': 'BONE_RIGHTKNEE', '53': 'BONE_RIGHTANKLE', '54': 'BONE_RIGHTFOOT\n</div>'}, result='Returns the x, y, z world position of the bone.'), oop=FunctionOOP(class_name='ped', method_name='getBonePosition', field=None), url=FunctionUrl(url='/wiki/GetPedBonePosition', name='getPedBonePosition', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedCameraRotation', return_types=['float'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the current camera rotation of a [[ped]].', arguments={'thePed': 'the ped to retrieve the camera rotation of.'}, result="Returns the camera rotation of the [[ped]] in degrees if successful. Returns ''false'' if an invalid element was passed."), oop=FunctionOOP(class_name='ped', method_name='getCameraRotation', field='cameraRotation'), url=FunctionUrl(url='/wiki/GetPedCameraRotation', name='getPedCameraRotation', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedClothes', return_types=['string,', 'string'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the current clothes texture and model of a certain type on a [[ped]].', arguments={'thePed': 'The ped whose clothes you want to retrieve.', 'clothesType': 'The type/slot of clothing you want to get.\n{{Clothes Textures}}'}, result="This function returns 2 [[string|strings]], the clothes texture and model. The first return value will be ''false'' if this player's clothes type is empty or an invalid player was specified."), oop=FunctionOOP(class_name='ped', method_name='getClothes', field=None), url=FunctionUrl(url='/wiki/GetPedClothes', name='getPedClothes', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPedClothes', return_types=['string,', 'string'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the current clothes texture and model of a certain type on a [[ped]].', arguments={'thePed': 'The ped whose clothes you want to retrieve.', 'clothesType': 'The type/slot of clothing you want to get.\n{{Clothes Textures}}'}, result="This function returns 2 [[string|strings]], the clothes texture and model. The first return value will be ''false'' if this player's clothes type is empty or an invalid player was specified."), oop=FunctionOOP(class_name='ped', method_name='getClothes', field=None), url=FunctionUrl(url='/wiki/GetPedClothes', name='getPedClothes', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedContactElement', return_types=['element'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function detects the element a ped is standing on. This can be a vehicle or an object.', arguments={'thePed': 'The ped of which you want to get the element he is standing on.'}, result="Returns an [[object]] or a [[vehicle]] if the ped is standing on one, ''false'' if he is touching none or an invalid element was passed."), oop=FunctionOOP(class_name='ped', method_name='getContactElement', field="contactElement}}\n\n===Required Arguments=== \n*'''thePed:''' The [[ped]] of which you want to get the [[element]] he is standing on.\n\n===Returns===\nReturns an [[object]] or a [[vehicle]] if the ped is standing on one, ''false'' if he is touching none or an invalid element was passed.\n\n"), url=FunctionUrl(url='/wiki/GetPedContactElement', name='getPedContactElement', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPedContactElement', return_types=['element'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function detects the element a ped is standing on. This can be a vehicle or an object.', arguments={'thePed': 'The ped of which you want to get the element he is standing on.'}, result="Returns an [[object]] or a [[vehicle]] if the ped is standing on one, ''false'' if he is touching none or an invalid element was passed."), oop=FunctionOOP(class_name='ped', method_name='getContactElement', field="contactElement}}\n\n===Required Arguments=== \n*'''thePed:''' The [[ped]] of which you want to get the [[element]] he is standing on.\n\n===Returns===\nReturns an [[object]] or a [[vehicle]] if the ped is standing on one, ''false'' if he is touching none or an invalid element was passed.\n\n"), url=FunctionUrl(url='/wiki/GetPedContactElement', name='getPedContactElement', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedControlState', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='control', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Checks whether a ped or the localplayer has a certain control pressed.', arguments={'thePed': 'the ped you want to check.', 'control': 'the control to get the status of. See control names for a list of valid names.'}, result="Returns ''true'' if the ped is pressing the specified control, ''false'' if not or an invalid argument was passed."), oop=None, url=FunctionUrl(url='/wiki/GetPedControlState', name='getPedControlState', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedFightingStyle', return_types=['int'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='Retrieves the fighting style a player/ped is currently using.', arguments={'thePed': 'the ped whose current fighting style ID you wish to retrieve.'}, result="Returns the ped's current fighting style as an integer ID, ''false'' if it fails to retrieve a value.\n{{Fighting Styles}}"), oop=FunctionOOP(class_name='ped', method_name='getFightingStyle', field='fightingStyle'), url=FunctionUrl(url='/wiki/GetPedFightingStyle', name='getPedFightingStyle', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPedFightingStyle', return_types=['int'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='Retrieves the fighting style a player/ped is currently using.', arguments={'thePed': 'the ped whose current fighting style ID you wish to retrieve.'}, result="Returns the ped's current fighting style as an integer ID, ''false'' if it fails to retrieve a value.\n{{Fighting Styles}}"), oop=FunctionOOP(class_name='ped', method_name='getFightingStyle', field='fightingStyle'), url=FunctionUrl(url='/wiki/GetPedFightingStyle', name='getPedFightingStyle', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedMoveState', return_types=['string'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current move state for the specified [[ped]].', arguments={'thePed': 'The ped whose move state you want to know'}, result="Returns a [[string]] indicating the ped's move state, or ''false'' if the ped is not streamed in, the movement type is unknown, the ped is in a vehicle or the ped is invalid.\n{{Ped move states}}"), oop=None, url=FunctionUrl(url='/wiki/GetPedMoveState', name='getPedMoveState', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedOccupiedVehicle', return_types=['vehicle'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the [[vehicle]] that the ped is currently in or is trying to enter, if any.', arguments={'thePed': ': The ped whose vehicle youre looking up.'}, result="Returns the vehicle that the specified ped is in, or ''false'' if the ped is not in a vehicle or is an invalid ped."), oop=FunctionOOP(class_name='ped', method_name='getOccupiedVehicle', field='vehicle'), url=FunctionUrl(url='/wiki/GetPedOccupiedVehicle', name='getPedOccupiedVehicle', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPedOccupiedVehicle', return_types=['vehicle'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the [[vehicle]] that the ped is currently in or is trying to enter, if any.', arguments={'thePed': ': The ped whose vehicle youre looking up.'}, result="Returns the vehicle that the specified ped is in, or ''false'' if the ped is not in a vehicle or is an invalid ped."), oop=FunctionOOP(class_name='ped', method_name='getOccupiedVehicle', field='vehicle'), url=FunctionUrl(url='/wiki/GetPedOccupiedVehicle', name='getPedOccupiedVehicle', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedOccupiedVehicleSeat', return_types=['int'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the seat that a specific ped is sitting in in a vehicle.\n[[File:vehicle seat ids.png|200px|thumb|right|Vehicle seat ids]] ', arguments={'thePed': ': The ped whose vehicle seat youre looking up.'}, result="* Returns an integer containing the number of the seat that the ped is currently in:\n** '''0:''' Front-left\n** '''1:''' Front-right\n** '''2:''' Rear-left\n** '''3:''' Rear-right\nReturns ''false'' if the ped is on foot, or the ped doesn't exist."), oop=FunctionOOP(class_name='ped', method_name='getOccupiedVehicleSeat', field="vehicleSeat}}\n\n===Required Arguments===\n*'''thePed''': The [[ped]] whose vehicle seat you're looking up.\n\n===Returns===\n* Returns an integer containing the number of the seat that the ped is currently in:\n** '''0:''' Front-left\n** '''1:''' Front-right\n** '''2:''' Rear-left\n** '''3:''' Rear-right\n\nReturns ''false'' if the ped is on foot, or the ped doesn't exist.\n\n"), url=FunctionUrl(url='/wiki/GetPedOccupiedVehicleSeat', name='getPedOccupiedVehicleSeat', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPedOccupiedVehicleSeat', return_types=['int'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the seat that a specific ped is sitting in in a vehicle.\n[[File:vehicle seat ids.png|200px|thumb|right|Vehicle seat ids]] ', arguments={'thePed': ': The ped whose vehicle seat youre looking up.'}, result="* Returns an integer containing the number of the seat that the ped is currently in:\n** '''0:''' Front-left\n** '''1:''' Front-right\n** '''2:''' Rear-left\n** '''3:''' Rear-right\nReturns ''false'' if the ped is on foot, or the ped doesn't exist."), oop=FunctionOOP(class_name='ped', method_name='getOccupiedVehicleSeat', field="vehicleSeat}}\n\n===Required Arguments===\n*'''thePed''': The [[ped]] whose vehicle seat you're looking up.\n\n===Returns===\n* Returns an integer containing the number of the seat that the ped is currently in:\n** '''0:''' Front-left\n** '''1:''' Front-right\n** '''2:''' Rear-left\n** '''3:''' Rear-right\n\nReturns ''false'' if the ped is on foot, or the ped doesn't exist.\n\n"), url=FunctionUrl(url='/wiki/GetPedOccupiedVehicleSeat', name='getPedOccupiedVehicleSeat', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedOxygenLevel', return_types=['float'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current oxygen level of the specified [[ped]].', arguments={'thePed': 'The ped whose oxygen level you want to check'}, result="A ''float'' with the oxygen level, ''false'' if an invalid ped was given."), oop=FunctionOOP(class_name='ped', method_name='getOxygenLevel', field='oxygenLevel'), url=FunctionUrl(url='/wiki/GetPedOxygenLevel', name='getPedOxygenLevel', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedSimplestTask', return_types=['string'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to get the name of a specified ped's current simplest [[task]].<br>", arguments={'thePed': ': The ped whose task you want to retrieve.'}, result="Returns a string representing the name of the ped's simplest, active [[task]]."), oop=None, url=FunctionUrl(url='/wiki/GetPedSimplestTask', name='getPedSimplestTask', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedStat', return_types=['float'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='stat', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the value of the specified statistic of a specific [[ped]].', arguments={'thePed': ': The ped whose stat you want to retrieve.', 'stat': ': A whole number determining the stat ID.\n{{Stats}}'}, result='Returns the value of the requested statistic.'), oop=None, url=FunctionUrl(url='/wiki/GetPedStat', name='getPedStat', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPedStat', return_types=['float'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='stat', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the value of the specified statistic of a specific [[ped]].', arguments={'thePed': ': The ped whose stat you want to retrieve.', 'stat': ': A whole number determining the stat ID.\n{{Stats}}'}, result='Returns the value of the requested statistic.'), oop=None, url=FunctionUrl(url='/wiki/GetPedStat', name='getPedStat', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedTarget', return_types=['element'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the element a [[ped]] is currently targeting.', arguments={'thePed': 'The ped whose target you want to retrieve.'}, result="Returns the [[element]] that's being targeted, or ''false'' if there isn't one.\nThis is only effective on physical GTA elements, namely:\n* Players\n* Peds\n* Vehicles\n* Objects"), oop=None, url=FunctionUrl(url='/wiki/GetPedTarget', name='getPedTarget', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPedTarget', return_types=['element'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the element a [[ped]] is currently targeting.', arguments={'thePed': 'The ped whose target you want to retrieve.'}, result="Returns the [[element]] that's being targeted, or ''false'' if there isn't one.\nThis is only effective on physical GTA elements, namely:\n* Players\n* Peds\n* Vehicles\n* Objects"), oop=None, url=FunctionUrl(url='/wiki/GetPedTarget', name='getPedTarget', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedTargetCollision', return_types=['float', 'float', 'float'], arguments=[FunctionArgument(name='targetingPed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows retrieval of where a ped's target is blocked. It will only be blocked if there is an obstacle within a ped's target range.", arguments={'targetingPed': 'This is the ped whose target collision you wish to retrieve'}, result="Returns three floats, ''x'',''y'',''z'', representing the position where the ped's target collides, or ''false'' if it was unsuccessful."), oop=None, url=FunctionUrl(url='/wiki/GetPedTargetCollision', name='getPedTargetCollision', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedTargetEnd', return_types=['float', 'float', 'float'], arguments=[FunctionArgument(name='targetingPed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows retrieval of the position where a ped's target range ends, when he is aiming with a weapon.", arguments={'targetingPed': 'the ped who is targeting whose target end you wish to retrieve'}, result="Returns three floats, ''x'',''y'',''z'', representing the position where the ped's target ends according to his range, or ''false'' if it was unsuccessful."), oop=None, url=FunctionUrl(url='/wiki/GetPedTargetEnd', name='getPedTargetEnd', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedTargetStart', return_types=['float', 'float', 'float'], arguments=[FunctionArgument(name='targetingPed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows retrieval of the position a ped's target range begins, when he is aiming with a weapon.", arguments={'targetingPed': 'The ped whose target start you wish to retrieve'}, result="Returns three floats, x,y,z, representing the position where the ped's target starts, or ''false'' if it was unsuccessful."), oop=None, url=FunctionUrl(url='/wiki/GetPedTargetStart', name='getPedTargetStart', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedTask', return_types=['string,', 'string,', 'string,', 'string'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='priority', argument_type='string', default_value=None, optional=False), FunctionArgument(name='taskType', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get any simple or complex [[task]] of a certain type for a ped.\nIt can provide feedback on all tasks relating to a ped. For example, while jumping, [[getPedSimplestTask]] will return TASK_SIMPLE_IN_AIR. If you wanted to know specifically if the player has jumped, you would use this function. If you did you will discover that while jumping Primary task 3 is TASK_COMPLEX_JUMP.', arguments={'thePed': ': The ped whose task you want to retrieve.', 'priority': ': A string determining which set of tasks you want to retrieve it from. This must be either primary or secondary.', 'taskType': ': An integer value representing the task type (or slot) you want to get the task from. Types can be:', 'PRIMARY TASKS': '', '0': 'TASK_SECONDARY_ATTACK', '1': 'TASK_SECONDARY_DUCK', '2': 'TASK_SECONDARY_SAY', '3': 'TASK_SECONDARY_FACIAL_COMPLEX', '4': 'TASK_SECONDARY_PARTIAL_ANIM', 'SECONDARY TASKS': '', '5': 'TASK_SECONDARY_IK'}, result="Returns the name of the most complex task. See [[list of player tasks]] for valid strings. Returns ''false'' if invalid arguments are specified or if there is no task of the type specified.\n<br>\n{{New feature|3.0110|1.1|\nReturns between 1 and 4 strings. The first string contains the name of the most complex task, with simpler sub-tasks being named in the following strings. See [[list of player tasks]] for valid strings. Returns ''false'' if invalid arguments are specified or if there is no task of the type specified.\n}}"), oop=FunctionOOP(class_name='ped', method_name='getTask}}\n===Required Arguments===\n*\'\'\'thePed\'\'\': The [[ped]] whose task you want to retrieve.\n*\'\'\'priority\'\'\': A string determining which set of tasks you want to retrieve it from. This must be either "primary" or "secondary".\n*\'\'\'taskType\'\'\': An integer value representing the task type (or slot) you want to get the task from. Types can be:\n**\'\'\'PRIMARY TASKS\'\'\'\n***\'\'\'0:\'\'\' TASK_PHYSICAL_RESPONSE\n***\'\'\'1:\'\'\' TASK_EVENT_RESPONSE_TEMP\n***\'\'\'2:\'\'\' TASK_EVENT_RESPONSE_NONTEMP\n***\'\'\'3:\'\'\' TASK_PRIMARY\n***\'\'\'4:\'\'\' TASK_DEFAULT\n**\'\'\'SECONDARY TASKS\'\'\'\n***\'\'\'0:\'\'\' TASK_SECONDARY_ATTACK\n***\'\'\'1:\'\'\' TASK_SECONDARY_DUCK\n***\'\'\'2:\'\'\' TASK_SECONDARY_SAY\n***\'\'\'3:\'\'\' TASK_SECONDARY_FACIAL_COMPLEX\n***\'\'\'4:\'\'\' TASK_SECONDARY_PARTIAL_ANIM\n***\'\'\'5:\'\'\' TASK_SECONDARY_IK\n\n===Returns===\nReturns the name of the most complex task. See [[list of player tasks]] for valid strings. Returns \'\'false\'\' if invalid arguments are specified or if there is no task of the type specified.\n<br>\n{{New feature', field='3.0110'), url=FunctionUrl(url='/wiki/GetPedTask', name='getPedTask', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedTotalAmmo', return_types=['int'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='weaponSlot', argument_type='int', default_value='current', optional=False)]), docs=FunctionDoc(description="This function returns an integer that contains the total ammo in a specified [[ped]]'s weapon. See [[weapon|Weapon Info]]", arguments={'thePed': ': The ped whose ammo you want to check.', 'weaponSlot': ': an integer representing the weapon slot (set to the peds current slot if not given)'}, result="Returns an [[int]] containing the total amount of ammo for the specified ped's weapon, or 0 if the ped specified is invalid."), oop=None, url=FunctionUrl(url='/wiki/GetPedTotalAmmo', name='getPedTotalAmmo', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPedTotalAmmo', return_types=['int'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='weaponSlot', argument_type='int', default_value='current', optional=False)]), docs=FunctionDoc(description="This function returns an integer that contains the total ammo in a specified [[ped]]'s weapon. See [[weapon|Weapon Info]]", arguments={'thePed': ': The ped whose ammo you want to check.', 'weaponSlot': ': an integer representing the weapon slot (set to the peds current slot if not given)'}, result="Returns an [[int]] containing the total amount of ammo for the specified ped's weapon, or 0 if the ped specified is invalid."), oop=None, url=FunctionUrl(url='/wiki/GetPedTotalAmmo', name='getPedTotalAmmo', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedVoice', return_types=['string,', 'string'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the current voice of a ped.', arguments={'thePed': 'the ped to get the voice of.'}, result="If successul, returns the current voice type name and the voice name of the ped (see [[ped voices]] for possible names). Returns ''false'' in case of failure."), oop=None, url=FunctionUrl(url='/wiki/GetPedVoice', name='getPedVoice', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedWalkingStyle', return_types=['int'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'thePed': 'the ped whose walking style to retrieve.'}, result="Returns the walking style ID if successful, ''false'' otherwise. The possible walking styles are as follows:\n{{Ped walking styles}}"), oop=FunctionOOP(class_name='ped', method_name='getWalkingStyle', field='walkingStyle'), url=FunctionUrl(url='/wiki/GetPedWalkingStyle', name='getPedWalkingStyle', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPedWalkingStyle', return_types=['int'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'thePed': 'the ped whose walking style to retrieve.'}, result="Returns the walking style ID if successful, ''false'' otherwise. The possible walking styles are as follows:\n{{Ped walking styles}}"), oop=FunctionOOP(class_name='ped', method_name='getWalkingStyle', field='walkingStyle'), url=FunctionUrl(url='/wiki/GetPedWalkingStyle', name='getPedWalkingStyle', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedWeapon', return_types=['int'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='weaponSlot', argument_type='int', default_value='current', optional=False)]), docs=FunctionDoc(description='This function tells you which weapon type is in a certain weapon slot of a ped. See [[weapon|Weapon Info]]', arguments={'thePed': ': the ped you want to get the weapon type from.', 'weaponSlot': ': an integer representing the weapon slot (set to the peds current slot if not given).'}, result="Returns an [[int]] indicating the type of the weapon the ped has in the specified slot. If the slot is empty, it returns 0.\nIt should be noted that if a ped runs out of ammo for a weapon, it will still return the ID of that weapon in the slot (even if it appears as if the ped does not have a weapon at all), though [[getPedTotalAmmo]] will return '''0'''.  Therefore, [[getPedTotalAmmo]] should be used in conjunction with [[getPedWeapon]] in order to check if a ped has a weapon."), oop=None, url=FunctionUrl(url='/wiki/GetPedWeapon', name='getPedWeapon', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPedWeapon', return_types=['int'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='weaponSlot', argument_type='int', default_value='current', optional=False)]), docs=FunctionDoc(description='This function tells you which weapon type is in a certain weapon slot of a ped. See [[weapon|Weapon Info]]', arguments={'thePed': ': the ped you want to get the weapon type from.', 'weaponSlot': ': an integer representing the weapon slot (set to the peds current slot if not given).'}, result="Returns an [[int]] indicating the type of the weapon the ped has in the specified slot. If the slot is empty, it returns 0.\nIt should be noted that if a ped runs out of ammo for a weapon, it will still return the ID of that weapon in the slot (even if it appears as if the ped does not have a weapon at all), though [[getPedTotalAmmo]] will return '''0'''.  Therefore, [[getPedTotalAmmo]] should be used in conjunction with [[getPedWeapon]] in order to check if a ped has a weapon."), oop=None, url=FunctionUrl(url='/wiki/GetPedWeapon', name='getPedWeapon', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedWeaponMuzzlePosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the world position of the muzzle of the weapon that a ped is currently carrying. The weapon muzzle is the end of the gun barrel where the bullets/rockets/... come out.\nThe position may not be accurate if the ped is off screen.', arguments={'thePed': 'the ped whose weapon muzzle position to retrieve.'}, result="If successful, returns the x/y/z coordinates of the weapon muzzle. Returns ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetPedWeaponMuzzlePosition', name='getPedWeaponMuzzlePosition', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPedWeaponSlot', return_types=['int'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets a ped's selected weapon slot.", arguments={'thePed': 'the ped to get the current weapon slot of.'}, result="Returns the selected weapon slot ID on success, ''false'' otherwise.\n{{Weapon_Slots}}"), oop=FunctionOOP(class_name='ped', method_name='getWeaponSlot', field='weaponSlot'), url=FunctionUrl(url='/wiki/GetPedWeaponSlot', name='getPedWeaponSlot', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPedWeaponSlot', return_types=['int'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets a ped's selected weapon slot.", arguments={'thePed': 'the ped to get the current weapon slot of.'}, result="Returns the selected weapon slot ID on success, ''false'' otherwise.\n{{Weapon_Slots}}"), oop=FunctionOOP(class_name='ped', method_name='getWeaponSlot', field='weaponSlot'), url=FunctionUrl(url='/wiki/GetPedWeaponSlot', name='getPedWeaponSlot', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getValidPedModels', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function returns all valid ped models.', arguments={}, result='Returns a [[table]] with all valid ped models.'), oop=None, url=FunctionUrl(url='/wiki/GetValidPedModels', name='getValidPedModels', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getValidPedModels', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function returns all valid ped models.', arguments={}, result='Returns a [[table]] with all valid ped models.'), oop=None, url=FunctionUrl(url='/wiki/GetValidPedModels', name='getValidPedModels', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='givePedWeapon', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='weapon', argument_type='int', default_value=None, optional=False), FunctionArgument(name='ammo', argument_type='int', default_value='30', optional=True), FunctionArgument(name='setAsCurrent', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="This function gives the specified weapon to the specified ped. This function can't be used on players, use [[giveWeapon]] for that.\nThis function is mainly useful for client side created peds however you can use it on a server side ped, though note that the weapon wouldn't be synced between clients unless your script gives the weapon to the ped on every client.\nThere is an optional argument to specify ammunition and whether to set as the current weapon. If you don't specify an ammo value it will give 30 ammo by default and for a melee weapon you can specify just 1 or above.\n}}\n*When setting ammo for [[Weapon|weapons in slot]] 0,1,10,11 or 12 the maximum ammo is 1\n*When setting ammo for [[Weapon|weapons in slot]] 3,4,5 the ammo is added\n*When setting ammo for [[Weapon|weapons in slot]] 2,6,7,8,9 and the slot weapon is changing, the ammo is replaced\n}}", arguments={'thePed': 'A ped element.', 'weapon': 'A whole number integer that refers to a Weapon ID. Click Weapon|here for a list of possible weapon IDs.\n{{OptionalArg}}', 'ammo': 'A whole number integer serving as the ammo amount for the given weapon. For weapons that do not require ammo, such as melee, this should be at least 1.', 'setAsCurrent': 'A boolean value determining whether or not the weapon will be set as the peds currently selected weapon.'}, result="Returns ''true'' if weapon was successfully given to the ped, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GivePedWeapon', name='givePedWeapon', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isPedChoking', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if the specified [[ped]] is choking (coughing) or not. This happens as a result of weapons that produce smoke - smoke grenades, fire extinguisher and the spray can. ', arguments={'thePed': ': The ped you wish to check'}, result="Returns ''true'' if the ped is choking, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='isChoking', field='choking'), url=FunctionUrl(url='/wiki/IsPedChoking', name='isPedChoking', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isPedChoking', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if the specified [[ped]] is choking (coughing) or not. This happens as a result of weapons that produce smoke - smoke grenades, fire extinguisher and the spray can. ', arguments={'thePed': ': The ped you wish to check'}, result="Returns ''true'' if the ped is choking, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='isChoking', field='choking'), url=FunctionUrl(url='/wiki/IsPedChoking', name='isPedChoking', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isPedDead', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if the specified [[ped]] is dead or not.', arguments={'thePed': ': the ped you want to check up on.'}, result="Returns ''true'' if the ped is dead, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='isDead', field="dead}}\n\n===Required Arguments===\n* '''thePed''': the [[ped]] you want to check up on.\n\n===Returns===\nReturns ''true'' if the ped is dead, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/IsPedDead', name='isPedDead', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isPedDoingGangDriveby', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if the ped is in the driveby state.', arguments={'thePed': 'The ped element whose state is to be checked.'}, result="Returns '''true''' if the driveby state is enabled, '''false''' otherwise."), oop=FunctionOOP(class_name='ped', method_name='isDoingGangDriveby', field='doingGangDriveby'), url=FunctionUrl(url='/wiki/IsPedDoingGangDriveby', name='isPedDoingGangDriveby', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isPedDoingGangDriveby', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if the ped is in the driveby state.', arguments={'thePed': 'The ped element whose state is to be checked.'}, result="Returns '''true''' if the driveby state is enabled, '''false''' otherwise."), oop=FunctionOOP(class_name='ped', method_name='isDoingGangDriveby', field='doingGangDriveby'), url=FunctionUrl(url='/wiki/IsPedDoingGangDriveby', name='isPedDoingGangDriveby', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isPedDoingTask', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='taskName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if the specified ped is carrying out a certain [[List of player tasks|task]].', arguments={'thePed': ': The ped you want to check.', 'taskName': ': A string containing the name of the List of player tasks|task youre checking for.'}, result="Returns ''true'' if the player is currently doing the task, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsPedDoingTask', name='isPedDoingTask', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isPedDucked', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if the specified [[ped]] is ducked (crouched) or not.', arguments={'thePed': ': The ped to check.'}, result="Returns ''true'' if the ped is ducked, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='isDucked', field="ducked}}\n\n===Required Arguments===\n*'''thePed''': The [[ped]] to check.\n\n===Returns===\nReturns ''true'' if the ped is ducked, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/IsPedDucked', name='isPedDucked', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isPedDucked', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if the specified [[ped]] is ducked (crouched) or not.', arguments={'thePed': ': The ped to check.'}, result="Returns ''true'' if the ped is ducked, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='isDucked', field="ducked}}\n\n===Required Arguments===\n*'''thePed''': The [[ped]] to check.\n\n===Returns===\nReturns ''true'' if the ped is ducked, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/IsPedDucked', name='isPedDucked', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isPedHeadless', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='With this function, you can check if a ped has a head or not.', arguments={'thePed': ': The ped to check.'}, result="Returns ''true'' if the ped is headless, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsPedHeadless', name='isPedHeadless', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isPedHeadless', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='With this function, you can check if a ped has a head or not.', arguments={'thePed': ': The ped to check.'}, result="Returns ''true'' if the ped is headless, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsPedHeadless', name='isPedHeadless', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isPedInVehicle', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description="Checks whether or not a given ped is currently in a vehicle. This also returns true if they're trying to enter a vehicle.", arguments={'thePed': 'the ped you want to check.'}, result="Returns ''true'' if the ped is in a vehicle, ''false'' if he is on foot or an invalid element was passed."), oop=FunctionOOP(class_name='ped', method_name='isInVehicle', field="inVehicle}}\n\n===Required Arguments===\n*'''thePed:''' the ped you want to check.\n\n===Returns===\nReturns ''true'' if the ped is in a vehicle, ''false'' if he is on foot or an invalid element was passed.\n\n"), url=FunctionUrl(url='/wiki/IsPedInVehicle', name='isPedInVehicle', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isPedInVehicle', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description="Checks whether or not a given ped is currently in a vehicle. This also returns true if they're trying to enter a vehicle.", arguments={'thePed': 'the ped you want to check.'}, result="Returns ''true'' if the ped is in a vehicle, ''false'' if he is on foot or an invalid element was passed."), oop=FunctionOOP(class_name='ped', method_name='isInVehicle', field="inVehicle}}\n\n===Required Arguments===\n*'''thePed:''' the ped you want to check.\n\n===Returns===\nReturns ''true'' if the ped is in a vehicle, ''false'' if he is on foot or an invalid element was passed.\n\n"), url=FunctionUrl(url='/wiki/IsPedInVehicle', name='isPedInVehicle', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isPedOnFire', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if the specified [[ped]] is on fire or not.', arguments={'thePed': ': The ped to check.'}, result="Returns ''true'' if the ped is on fire, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='isOnFire', field='onFire'), url=FunctionUrl(url='/wiki/IsPedOnFire', name='isPedOnFire', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isPedOnFire', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if the specified [[ped]] is on fire or not.', arguments={'thePed': ': The ped to check.'}, result="Returns ''true'' if the ped is on fire, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='isOnFire', field='onFire'), url=FunctionUrl(url='/wiki/IsPedOnFire', name='isPedOnFire', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isPedOnGround', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to determine whether or not a ped is on the ground. This is for on-foot usage only.', arguments={'thePed': 'The ped you are checking.'}, result="Returns ''true'' if the ped is on foot and on the ground, ''false'' otherwise, even if he is in a car that stands still or on object outside world map."), oop=FunctionOOP(class_name='ped', method_name='isOnGround', field="onGround}}\n\n===Required Arguments===\n*'''thePed:''' The [[ped]] you are checking.\n\n===Returns===\nReturns ''true'' if the ped is on foot and on the ground, ''false'' otherwise, even if he is in a car that stands still or on object outside world map.\n\n"), url=FunctionUrl(url='/wiki/IsPedOnGround', name='isPedOnGround', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isPedOnGround', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to determine whether or not a ped is on the ground. This is for on-foot usage only.', arguments={'thePed': 'The ped you are checking.'}, result="Returns ''true'' if the ped is on foot and on the ground, ''false'' otherwise, even if he is in a car that stands still or on object outside world map."), oop=FunctionOOP(class_name='ped', method_name='isOnGround', field="onGround}}\n\n===Required Arguments===\n*'''thePed:''' The [[ped]] you are checking.\n\n===Returns===\nReturns ''true'' if the ped is on foot and on the ground, ''false'' otherwise, even if he is in a car that stands still or on object outside world map.\n\n"), url=FunctionUrl(url='/wiki/IsPedOnGround', name='isPedOnGround', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isPedReloadingWeapon', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to determine whether or not a ped is currently reloading their weapon. Useful to stop certain quick reload exploits.}}', arguments={'thePed': 'The ped you are checking.'}, result="Returns ''true'' if the ped is currently reloading a weapon, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='isReloadingWeapon', field="reloadingWeapon}}\n\n===Required Arguments===\n*'''thePed:''' The [[ped]] you are checking.\n\n===Returns===\nReturns ''true'' if the ped is currently reloading a weapon, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/IsPedReloadingWeapon', name='isPedReloadingWeapon', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isPedTargetingMarkerEnabled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='[[Image:Targetingmarker.png|thumb|200px|Targeting marker]]\nThis function checks whether health target markers are drawn as set by [[setPedTargetingMarkerEnabled]] or not.', arguments={}, result="Returns ''true'' if the health target markers are enabled, ''false'' if not."), oop=None, url=FunctionUrl(url='/wiki/IsPedTargetingMarkerEnabled', name='isPedTargetingMarkerEnabled', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isPedWearingJetpack', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'thePed': 'the ped you want to check'}, result="Returns ''true'' if the ped is carrying a jetpack, ''false'' if he is not or an invalid element was passed."), oop=FunctionOOP(class_name='ped', method_name='isWearingJetpack', field="jetpack}}\n\n===Required Arguments===\n*'''thePed:''' the ped you want to check\n\n===Returns===\nReturns ''true'' if the ped is carrying a jetpack, ''false'' if he is not or an invalid element was passed.\n\n"), url=FunctionUrl(url='/wiki/IsPedWearingJetpack', name='isPedWearingJetpack', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isPedWearingJetpack', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'thePed': 'the ped you want to check'}, result="Returns ''true'' if the ped is carrying a jetpack, ''false'' if he is not or an invalid element was passed."), oop=FunctionOOP(class_name='ped', method_name='isWearingJetpack', field="jetpack}}\n\n===Required Arguments===\n*'''thePed:''' the ped you want to check\n\n===Returns===\nReturns ''true'' if the ped is carrying a jetpack, ''false'' if he is not or an invalid element was passed.\n\n"), url=FunctionUrl(url='/wiki/IsPedWearingJetpack', name='isPedWearingJetpack', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='killPed', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='theKiller', argument_type='ped', default_value='nil', optional=False), FunctionArgument(name='weapon', argument_type='int', default_value='255', optional=False), FunctionArgument(name='bodyPart', argument_type='int', default_value='255', optional=False), FunctionArgument(name='stealth', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='This function kills the specified ped.\nFrom v1.5.3 onwards this function is now available client side. Only works on client side peds.\n}}', arguments={'thePed': 'The ped to kill', 'theKiller': 'The ped responsible for the kill', 'weapon': 'The ID of the weapon or Damage Types that should appear to have killed the ped (doesnt affect how they die)', 'bodyPart': 'The ID of the body part that should appear to have been hit by the weapon (doesnt affect how they die)\n{{BodyParts}}', 'stealth': 'Boolean value, representing whether or not this a stealth kill'}, result="Returns ''true'' if the ped was killed, ''false'' if the ped specified could not be killed or is invalid."), oop=None, url=FunctionUrl(url='/wiki/KillPed', name='killPed', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='killPed', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='theKiller', argument_type='ped', default_value='nil', optional=False), FunctionArgument(name='weapon', argument_type='int', default_value='255', optional=False), FunctionArgument(name='bodyPart', argument_type='int', default_value='255', optional=False), FunctionArgument(name='stealth', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='This function kills the specified ped.\nFrom v1.5.3 onwards this function is now available client side. Only works on client side peds.\n}}', arguments={'thePed': 'The ped to kill', 'theKiller': 'The ped responsible for the kill', 'weapon': 'The ID of the weapon or Damage Types that should appear to have killed the ped (doesnt affect how they die)', 'bodyPart': 'The ID of the body part that should appear to have been hit by the weapon (doesnt affect how they die)\n{{BodyParts}}', 'stealth': 'Boolean value, representing whether or not this a stealth kill'}, result="Returns ''true'' if the ped was killed, ''false'' if the ped specified could not be killed or is invalid."), oop=None, url=FunctionUrl(url='/wiki/KillPed', name='killPed', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removePedClothes', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='clothesTexture', argument_type='string', default_value=None, optional=False), FunctionArgument(name='clothesModel', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to remove the current clothes of a certain type on a [[ped]]. It will remove them if the clothesTexture and clothesModel aren't specified, or if they match the current clothes on that slot.", arguments={'thePed': ': The ped you want to remove clothes from.', 'clothesType': ': the clothes slot/type to remove. See the CJ Clothes|clothes catalog.', 'clothesTexture': ': (Server only) A string determining the clothes texture that will be removed. See the CJ Clothes|clothes catalog.', 'clothesModel': ': (Server only) A string determining the clothes model that will be removed. See the CJ Clothes|clothes catalog.'}, result="This function returns ''true'' if the clothes were successfully removed from the ped, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name="removeClothes}}\n\n===Required Arguments===\n*'''thePed''': The [[ped]] you want to remove clothes from.\n*'''clothesType''': the clothes slot/type to remove. See the [[CJ Clothes", field="clothes catalog]].\n\n===Optional Arguments===\n*'''clothesTexture''': (Server only) A string determining the clothes texture that will be removed. See the [[CJ Clothes"), url=FunctionUrl(url='/wiki/RemovePedClothes', name='removePedClothes', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='removePedClothes', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='clothesType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='clothesTexture', argument_type='string', default_value=None, optional=False), FunctionArgument(name='clothesModel', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to remove the current clothes of a certain type on a [[ped]]. It will remove them if the clothesTexture and clothesModel aren't specified, or if they match the current clothes on that slot.", arguments={'thePed': ': The ped you want to remove clothes from.', 'clothesType': ': the clothes slot/type to remove. See the CJ Clothes|clothes catalog.', 'clothesTexture': ': (Server only) A string determining the clothes texture that will be removed. See the CJ Clothes|clothes catalog.', 'clothesModel': ': (Server only) A string determining the clothes model that will be removed. See the CJ Clothes|clothes catalog.'}, result="This function returns ''true'' if the clothes were successfully removed from the ped, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name="removeClothes}}\n\n===Required Arguments===\n*'''thePed''': The [[ped]] you want to remove clothes from.\n*'''clothesType''': the clothes slot/type to remove. See the [[CJ Clothes", field="clothes catalog]].\n\n===Optional Arguments===\n*'''clothesTexture''': (Server only) A string determining the clothes texture that will be removed. See the [[CJ Clothes"), url=FunctionUrl(url='/wiki/RemovePedClothes', name='removePedClothes', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removePedFromVehicle', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description="This function removes a ped from a vehicle immediately. This works for drivers and passengers. Note that this removes the ped from the vehicle and puts him in the exact position where the command was initiated.\n'''Available client side from 1.3.1''' (It will only work with client side vehicles and peds)", arguments={'thePed': 'The ped you wish to remove from a vehicle'}, result="Returns ''true'' if the operation was successful, ''false'' if the specified ped is not valid or if it isn't in a vehicle."), oop=FunctionOOP(class_name='ped', method_name='removeFromVehicle', field="vehicle}}\n\n===Required Arguments=== \n*'''thePed:''' The ped you wish to remove from a vehicle\n\n===Returns===\nReturns ''true'' if the operation was successful, ''false'' if the specified ped is not valid or if it isn't in a vehicle.\n\n"), url=FunctionUrl(url='/wiki/RemovePedFromVehicle', name='removePedFromVehicle', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='removePedFromVehicle', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description="This function removes a ped from a vehicle immediately. This works for drivers and passengers. Note that this removes the ped from the vehicle and puts him in the exact position where the command was initiated.\n'''Available client side from 1.3.1''' (It will only work with client side vehicles and peds)", arguments={'thePed': 'The ped you wish to remove from a vehicle'}, result="Returns ''true'' if the operation was successful, ''false'' if the specified ped is not valid or if it isn't in a vehicle."), oop=FunctionOOP(class_name='ped', method_name='removeFromVehicle', field="vehicle}}\n\n===Required Arguments=== \n*'''thePed:''' The ped you wish to remove from a vehicle\n\n===Returns===\nReturns ''true'' if the operation was successful, ''false'' if the specified ped is not valid or if it isn't in a vehicle.\n\n"), url=FunctionUrl(url='/wiki/RemovePedFromVehicle', name='removePedFromVehicle', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setAnalogControlState', return_types=['bool'], arguments=[FunctionArgument(name='control', argument_type='string', default_value=None, optional=False), FunctionArgument(name='state', argument_type='float', default_value=None, optional=True), FunctionArgument(name='forceOverrideNextFrame', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This sets the analog control state of a control for the local player.\nTo change the analog controls for a [[ped]], please use [[setPedAnalogControlState]].', arguments={'control': 'The control that you want to set the state of. See control names for a list of possible controls.', 'state': "A float between 0 and 1 indicating the amount the control is pressed. If no value is provided, the analog control is removed.\n<noinclude>{{New feature/item|3.0300|1.5.8|20756|\n*'''forceOverrideNextFrame: ''' A [[bool]] indicating if the player input should force fully overriden for the next frame.\n}}</noinclude>"}, result="Returns ''true'' if the control state was successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetAnalogControlState', name='setAnalogControlState', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setPedAimTarget', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows you to set a ped's aim target to a specific point. If a ped is within a certain range defined by [[getPedTargetStart]] and [[getPedTargetEnd]] he will be targeted and shot. \n''Note: If you wish to make a ped shoot you must use this in conjunction with an equipped weapon and [[setPedControlState]].''", arguments={'thePed': 'The ped whose target you want to set. Only peds and remote players will work; this function has no effect on the local player.', 'x': 'The x coordinate of the aim target point.', 'y': 'The y coordinate of the aim target point.', 'z': 'The z coordinate of the aim target point.'}, result="Returns ''true'' if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetPedAimTarget', name='setPedAimTarget', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setPedAnalogControlState', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='control', argument_type='string', default_value=None, optional=False), FunctionArgument(name='state', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="Sets an analog state of a specified [[ped]]'s control, as if they pressed or released it.\nThis function only works on [[ped]]s, to change the analog control state for a player, please use [[setAnalogControlState]].", arguments={'thePed': 'The ped you wish to set the control state of.', 'control': 'The control that you want to set the state of. See control names for a list of possible controls.', 'state': 'A float between 0 and 1 indicating the amount the control is pressed.'}, result="Returns ''true'' if the control state was successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetPedAnalogControlState', name='setPedAnalogControlState', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPedAnimation', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='block', argument_type='string', default_value='nil', optional=True), FunctionArgument(name='anim', argument_type='string', default_value='nil', optional=True), FunctionArgument(name='time', argument_type='int', default_value='-1', optional=True), FunctionArgument(name='loop', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='updatePosition', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='interruptable', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='freezeLastFrame', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='blendTime', argument_type='int', default_value='250', optional=True), FunctionArgument(name='retainPedState', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='Sets the current [[Animations|animation]] of a [[player]] or [[ped]]. Not specifying the type of animation will automatically cancel the current one.', arguments={'thePed': 'the player or ped you want to apply an Animations|animation to.\n{{OptionalArg}}', 'block': 'the Animations|animation blocks name.', 'anim': 'the name of the Animations|animation within the block.', 'time': 'how long the animation will run for in milliseconds.', 'loop': 'indicates whether or not the animation will loop.', 'updatePosition': 'will change the actual coordinates of the ped according to the animation. Use this for e.g. walking animations.', 'interruptable': 'if set to false other tasks wont be able to interupt the animation. Setting this to false also gives this function more power to override other animations that are running. For example, squatting after a jump can be terminated.', 'freezeLastFrame': 'if set to true after animation the last frame will be frozen, otherwise the animation will end and controls will return.', 'blendTime': 'how long the animation will mixed with the previous one in milliseconds.\n{{New items|3.0157|1.5.7|', 'retainPedState': 'will restore the task which was playing before calling this function. Useful for restoring the crouch task after animation ends. This may be extended in the future to support other states/tasks.\n|16632}}'}, result="Returns ''true'' if succesful, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='setAnimation', field=None), url=FunctionUrl(url='/wiki/SetPedAnimation', name='setPedAnimation', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPedAnimation', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='block', argument_type='string', default_value='nil', optional=True), FunctionArgument(name='anim', argument_type='string', default_value='nil', optional=True), FunctionArgument(name='time', argument_type='int', default_value='-1', optional=True), FunctionArgument(name='loop', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='updatePosition', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='interruptable', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='freezeLastFrame', argument_type='bool', default_value='true', optional=True), FunctionArgument(name='blendTime', argument_type='int', default_value='250', optional=True), FunctionArgument(name='retainPedState', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='Sets the current [[Animations|animation]] of a [[player]] or [[ped]]. Not specifying the type of animation will automatically cancel the current one.', arguments={'thePed': 'the player or ped you want to apply an Animations|animation to.\n{{OptionalArg}}', 'block': 'the Animations|animation blocks name.', 'anim': 'the name of the Animations|animation within the block.', 'time': 'how long the animation will run for in milliseconds.', 'loop': 'indicates whether or not the animation will loop.', 'updatePosition': 'will change the actual coordinates of the ped according to the animation. Use this for e.g. walking animations.', 'interruptable': 'if set to false other tasks wont be able to interupt the animation. Setting this to false also gives this function more power to override other animations that are running. For example, squatting after a jump can be terminated.', 'freezeLastFrame': 'if set to true after animation the last frame will be frozen, otherwise the animation will end and controls will return.', 'blendTime': 'how long the animation will mixed with the previous one in milliseconds.\n{{New items|3.0157|1.5.7|', 'retainPedState': 'will restore the task which was playing before calling this function. Useful for restoring the crouch task after animation ends. This may be extended in the future to support other states/tasks.\n|16632}}'}, result="Returns ''true'' if succesful, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='setAnimation', field=None), url=FunctionUrl(url='/wiki/SetPedAnimation', name='setPedAnimation', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPedAnimationProgress', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='anim', argument_type='string', default_value=None, optional=True), FunctionArgument(name='progress', argument_type='float', default_value=None, optional=True)]), docs=FunctionDoc(description='Sets the current animation progress of a player or ped.', arguments={'thePed': 'the player or ped you want to change animation progress.', 'anim': 'the animation name currently applied to ped, if not supplied, the animation will stop', 'progress': 'current animation progress you want to apply, value from 0.0 to 1.0, if not supplied will default to 0.0'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetPedAnimationProgress', name='setPedAnimationProgress', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPedAnimationProgress', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='anim', argument_type='string', default_value=None, optional=True), FunctionArgument(name='progress', argument_type='float', default_value=None, optional=True)]), docs=FunctionDoc(description='Sets the current animation progress of a player or ped.', arguments={'thePed': 'the player or ped you want to change animation progress.', 'anim': 'the animation name currently applied to ped, if not supplied, the animation will stop', 'progress': 'current animation progress you want to apply, value from 0.0 to 1.0, if not supplied will default to 0.0'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetPedAnimationProgress', name='setPedAnimationProgress', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPedAnimationSpeed', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='anim', argument_type='string', default_value='""', optional=True), FunctionArgument(name='speed', argument_type='float', default_value='1.0', optional=True)]), docs=FunctionDoc(description='Sets the speed of a currently running animation for a particular player or ped.\n}}', arguments={'thePed': 'the player or ped you want to change animation speed of.', 'anim': 'the animation name it will affect.', 'speed': 'a float containing the speed between 0.0–1.0 you want to apply to the animation. This limitation may be adjusted in the future, so do not provide speeds outside this boundary. {{New feature/item|3.0160|1.5.7|20395|The limit is now 0.0 to 10.0.}} {{Warning|Setting speed higher than 1 can cause issues with some animations.}}'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name="setAnimationSpeed}}\n\n===Required Arguments===\n*'''thePed:''' the [[player]] or [[ped]] you want to change animation speed of.\n\n===Optional Arguments===\n*'''anim:''' the animation name it will affect.\n*'''speed:''' a [[float]] containing the speed between 0.0–1.0 you want to apply to the animation. ''This limitation may be adjusted in the future, so do not provide speeds outside this boundary.'' {{New feature/item", field='3.0160'), url=FunctionUrl(url='/wiki/SetPedAnimationSpeed', name='setPedAnimationSpeed', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPedAnimationSpeed', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='anim', argument_type='string', default_value='""', optional=True), FunctionArgument(name='speed', argument_type='float', default_value='1.0', optional=True)]), docs=FunctionDoc(description='Sets the speed of a currently running animation for a particular player or ped.\n}}', arguments={'thePed': 'the player or ped you want to change animation speed of.', 'anim': 'the animation name it will affect.', 'speed': 'a float containing the speed between 0.0–1.0 you want to apply to the animation. This limitation may be adjusted in the future, so do not provide speeds outside this boundary. {{New feature/item|3.0160|1.5.7|20395|The limit is now 0.0 to 10.0.}} {{Warning|Setting speed higher than 1 can cause issues with some animations.}}'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name="setAnimationSpeed}}\n\n===Required Arguments===\n*'''thePed:''' the [[player]] or [[ped]] you want to change animation speed of.\n\n===Optional Arguments===\n*'''anim:''' the animation name it will affect.\n*'''speed:''' a [[float]] containing the speed between 0.0–1.0 you want to apply to the animation. ''This limitation may be adjusted in the future, so do not provide speeds outside this boundary.'' {{New feature/item", field='3.0160'), url=FunctionUrl(url='/wiki/SetPedAnimationSpeed', name='setPedAnimationSpeed', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPedArmor', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='armor', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to set the armor value of a [[ped]].', arguments={'thePed': ': the ped whose armor you want to modify.', 'armor': ': the amount of armor you want to set on the ped. Valid values are from 0 to 100.'}, result="Returns ''true'' if the armor was changed succesfully. Returns ''false'' if an invalid ped was specified, or the armor value specified is out of acceptable range."), oop=FunctionOOP(class_name='ped', method_name='setArmor', field='armor'), url=FunctionUrl(url='/wiki/SetPedArmor', name='setPedArmor', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPedArmor', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='armor', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to set the armor value of a [[ped]].', arguments={'thePed': ': the ped whose armor you want to modify.', 'armor': ': the amount of armor you want to set on the ped. Valid values are from 0 to 100.'}, result="Returns ''true'' if the armor was changed succesfully. Returns ''false'' if an invalid ped was specified, or the armor value specified is out of acceptable range."), oop=FunctionOOP(class_name='ped', method_name='setArmor', field='armor'), url=FunctionUrl(url='/wiki/SetPedArmor', name='setPedArmor', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setPedCameraRotation', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='cameraRotation', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the camera rotation of a ped, e.g. where its camera will look at. Don't confuse this with [[getCameraMatrix]], because that function is designed for fixed (scripted) camera moves.", arguments={'thePed': 'The ped whose camera rotation is to be changed.', 'cameraRotation': 'The new direction that the ped will walk if you set their forwards control state. If the ped is the local player, it will also change where his camera is looking at if it isnt fixed (i.e. camera target is the local player).'}, result="Returns ''true'' if the camera rotation was changed, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='setCameraRotation', field='cameraRotation'), url=FunctionUrl(url='/wiki/SetPedCameraRotation', name='setPedCameraRotation', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setPedCanBeKnockedOffBike', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='canBeKnockedOffBike', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function controls if a ped can fall of his bike by accident - namely by banging into a wall.', arguments={'thePed': 'the ped whose knockoffstatus is being changed', 'canBeKnockedOffBike': 'true or false'}, result=''), oop=FunctionOOP(class_name='ped', method_name='setCanBeKnockedOffBike', field=None), url=FunctionUrl(url='/wiki/SetPedCanBeKnockedOffBike', name='setPedCanBeKnockedOffBike', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setPedControlState', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='control', argument_type='string', default_value=None, optional=False), FunctionArgument(name='state', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function makes a [[ped]] or [[player]] press or release a certain control.', arguments={'thePed': 'the ped you want to press or release a control.', 'control': 'the name of the control of which to change the state. See control names for a list of valid names.', 'state': 'the new control state. true means pressed, false is released.'}, result="Returns ''true'' if successful, ''false'' if otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetPedControlState', name='setPedControlState', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPedDoingGangDriveby', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='state', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the driveby state of a ped.', arguments={'thePed': 'The ped element whose state is to be changed.', 'state': 'A boolean value representing the drive-by state, true meaning enabled and false disabled.'}, result="Returns ''true'' if the driveby state could be changed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetPedDoingGangDriveby', name='setPedDoingGangDriveby', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPedDoingGangDriveby', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='state', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the driveby state of a ped.', arguments={'thePed': 'The ped element whose state is to be changed.', 'state': 'A boolean value representing the drive-by state, true meaning enabled and false disabled.'}, result="Returns ''true'' if the driveby state could be changed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetPedDoingGangDriveby', name='setPedDoingGangDriveby', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setPedEnterVehicle', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='nil', argument_type='vehicle', default_value=None, optional=True), FunctionArgument(name='false', argument_type='passenger', default_value=None, optional=True)]), docs=FunctionDoc(description='', arguments={'thePed': "The player or ped to enter the vehicle.\n**''Note: The player must be the local player.''\n**''Note: The ped must be synced by the client. Use [[isElementSyncer]] clientside to check if the client is syncing. Use [[setElementSyncer]] serverside to change the syncer manually.''", 'vehicle': 'The vehicle to enter. If no vehicle is set, the ped will enter the nearest vehicle within 20 m.', 'passenger': 'If set to true, the ped will enter as passenger in the nearest available seat, otherwise he will enter as driver.'}, result="Returns ''true'' if the function was successful, ''false'' otherwise.\nWhen this function returns ''true'', the client will ask server for permission to enter a vehicle. Actually entering can still fail in the following cases\n*The function is used on a ped, but another client is not on version '''1.5.8 r20740''' or newer.\n*Another player or ped is already entering, exiting or jacking the same vehicle and seat.\n*Movement input or damage can interrupt the task. Use [[getPedTask]] to monitor what the ped is doing.\nThis function returns ''false'' in the following cases\n*Invalid arguments were parsed.\n*The function is used on a ped, but the server is not on version '''1.5.8 r20740''' or newer.\n*Time passed since last enter/exit for this ped is less than 1500 ms.\n*[[onClientVehicleStartEnter]] was cancelled by a script.\n*The ped has an active TASK_PRIMARY [[task]]. Use [[getPedTask]] to monitor what the ped is doing."), oop=None, url=FunctionUrl(url='/wiki/SetPedEnterVehicle', name='setPedEnterVehicle', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setPedExitVehicle', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'thePed': 'The player or ped to exit the vehicle.'}, result="Returns ''true'' if the function was successful, ''false'' otherwise.\nWhen this function returns ''true'', the client will ask server for permission to exit a vehicle. Exiting can still fail in the following cases\n*The function is used on a ped, but another client is not on version '''1.5.8 r20740''' or newer.\nThis function returns ''false'' in the following cases\n*Invalid arguments were parsed.\n*The function is used on a ped but the server is not on version '''1.5.8 r20740''' or newer.\n*Time passed since last enter/exit for this ped is less than 1500 ms.\n*The ped is getting jacked."), oop=None, url=FunctionUrl(url='/wiki/SetPedExitVehicle', name='setPedExitVehicle', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPedFightingStyle', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='style', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="Changes a ped's fighting style. Most styles only change the 'special attack' which is done using the Aim and Enter keys.", arguments={'thePed': 'The ped whose fighting style to change.', 'style': 'The fighting style ID to apply.\n{{Fighting Styles}}'}, result="Returns ''true'' in case of success, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetPedFightingStyle', name='setPedFightingStyle', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPedFightingStyle', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='style', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="Changes a ped's fighting style. Most styles only change the 'special attack' which is done using the Aim and Enter keys.", arguments={'thePed': 'The ped whose fighting style to change.', 'style': 'The fighting style ID to apply.\n{{Fighting Styles}}'}, result="Returns ''true'' in case of success, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetPedFightingStyle', name='setPedFightingStyle', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setPedFootBloodEnabled', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='element', default_value=None, optional=False), FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function makes a players foot prints bloody.', arguments={'thePlayer': 'The player to give bloody foot prints to.', 'enabled': 'Boolean specifying whether or not to have bloody feet.'}, result="Returns ''true'' if changing the players bloody feet status worked."), oop=None, url=FunctionUrl(url='/wiki/SetPedFootBloodEnabled', name='setPedFootBloodEnabled', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isPedFootBloodEnabled', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if player feets are bleeding.', arguments={'thePlayer': 'The player to give bloody foot prints to.'}, result="Returns ''true'' if feets are bleeding, '''false''' otherwise"), oop=None, url=FunctionUrl(url='/wiki/IsPedFootBloodEnabled', name='isPedFootBloodEnabled', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPedHeadless', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='headState', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='With this function, you can set if a ped has a head or not.', arguments={'thePed': ': The ped to check.', 'headState': ': head state, use true if you want the ped be headless, use false to give back the head.'}, result="Returns ''true'' if successful, ''false'' otherwise"), oop=FunctionOOP(class_name='ped', method_name='setHeadless', field="headless}}\n\n===Required Arguments===\n*'''thePed''': The [[ped]] to check.\n*'''headState''': head state, use true if you want the ped be headless, use false to give back the head.\n\n===Returns===\nReturns ''true'' if successful, ''false'' otherwise\n\n"), url=FunctionUrl(url='/wiki/SetPedHeadless', name='setPedHeadless', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPedHeadless', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='headState', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='With this function, you can set if a ped has a head or not.', arguments={'thePed': ': The ped to check.', 'headState': ': head state, use true if you want the ped be headless, use false to give back the head.'}, result="Returns ''true'' if successful, ''false'' otherwise"), oop=FunctionOOP(class_name='ped', method_name='setHeadless', field="headless}}\n\n===Required Arguments===\n*'''thePed''': The [[ped]] to check.\n*'''headState''': head state, use true if you want the ped be headless, use false to give back the head.\n\n===Returns===\nReturns ''true'' if successful, ''false'' otherwise\n\n"), url=FunctionUrl(url='/wiki/SetPedHeadless', name='setPedHeadless', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setPedLookAt', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='time', argument_type='int', default_value='3000 [', optional=True), FunctionArgument(name='blend', argument_type='int', default_value='1000', optional=True), FunctionArgument(name='target', argument_type='element', default_value='nil', optional=True)]), docs=FunctionDoc(description='Makes a ped turn his head and look at a specific world position or element.', arguments={'thePed': 'the ped to change the lookat of.', 'x': 'the x coordinate of the world position to look at.', 'y': 'the y coordinate of the world position to look at.', 'z': 'the z coordinate of the world position to look at.', 'time': 'the time, in milliseconds, during which the ped will look at the target. Once this time has elapsed, he will look ahead again like before the function was applied. A time of 0 will immediately stop any lookat. A negative time will make the ped look at the target indefinitely.', 'blend': 'the time, in milliseconds, during which the look will blend.', 'target': 'if this argument is specified, the position arguments will be ignored and the peds gaze will follow the specified element instead. Can be a player, a vehicle, another ped etc.'}, result=''), oop=None, url=FunctionUrl(url='/wiki/SetPedLookAt', name='setPedLookAt', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPedOnFire', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='isOnFire', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function can be used to set a ped on fire or extinguish a fire on it.', arguments={'thePed': 'The ped that we want to set/unset', 'isOnFire': 'true to set the ped on fire, false to extinguish any fire on him'}, result="Returns ''true'' if successful, ''false'' otherwise"), oop=FunctionOOP(class_name='ped', method_name='setOnFire', field='onFire'), url=FunctionUrl(url='/wiki/SetPedOnFire', name='setPedOnFire', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPedOnFire', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='isOnFire', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function can be used to set a ped on fire or extinguish a fire on it.', arguments={'thePed': 'The ped that we want to set/unset', 'isOnFire': 'true to set the ped on fire, false to extinguish any fire on him'}, result="Returns ''true'' if successful, ''false'' otherwise"), oop=FunctionOOP(class_name='ped', method_name='setOnFire', field='onFire'), url=FunctionUrl(url='/wiki/SetPedOnFire', name='setPedOnFire', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setPedOxygenLevel', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='oxygen', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to set the oxygen level of a [[ped]].', arguments={'thePed': ': the ped whose oxygen level you want to modify.', 'oxygen': ': the amount of oxygen you want to set on the ped. Native values are from 0 to 1000. Each of the stamina (22) and underwater stamina (225) Template:Stats|stat maximum adds a bonus of 1500. So the maximum oxygen level is 4000.'}, result="Returns ''true'' if the oxygen level was changed succesfully. Returns ''false'' if an invalid ped and/or oxygen level was specified."), oop=FunctionOOP(class_name='ped', method_name='setOxygenLevel', field='oxygenLevel'), url=FunctionUrl(url='/wiki/SetPedOxygenLevel', name='setPedOxygenLevel', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPedStat', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='stat', argument_type='int', default_value=None, optional=False), FunctionArgument(name='value', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="*Things like infinite run, fire proof CJ, 150 armor have special activation flags. They need a way to be triggered on/off.\n}}\nThis function allows you to set the value of a specific statistic for a [[ped]]. '''Visual stats (FAT and BODY_MUSCLE) can only be used on the CJ skin''', they have no effect on other skins.\nWhen this function is used client side, it can only be used on client side created peds.", arguments={'thePed': ': the ped whose statistic you want to modify.', 'stat': ': the stat ID.\n{{Stats}}', 'value': ': the new value of the stat. It must be between 0 and 1000.'}, result="Returns ''true'' if the statistic was changed succesfully. Returns ''false'' if an invalid player is specified, if the stat-id/value is out of acceptable range or if the FAT or BODY_MUSCLE stats are used on non-CJ players."), oop=None, url=FunctionUrl(url='/wiki/SetPedStat', name='setPedStat', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPedStat', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='stat', argument_type='int', default_value=None, optional=False), FunctionArgument(name='value', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="*Things like infinite run, fire proof CJ, 150 armor have special activation flags. They need a way to be triggered on/off.\n}}\nThis function allows you to set the value of a specific statistic for a [[ped]]. '''Visual stats (FAT and BODY_MUSCLE) can only be used on the CJ skin''', they have no effect on other skins.\nWhen this function is used client side, it can only be used on client side created peds.", arguments={'thePed': ': the ped whose statistic you want to modify.', 'stat': ': the stat ID.\n{{Stats}}', 'value': ': the new value of the stat. It must be between 0 and 1000.'}, result="Returns ''true'' if the statistic was changed succesfully. Returns ''false'' if an invalid player is specified, if the stat-id/value is out of acceptable range or if the FAT or BODY_MUSCLE stats are used on non-CJ players."), oop=None, url=FunctionUrl(url='/wiki/SetPedStat', name='setPedStat', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setPedTargetingMarkerEnabled', return_types=['bool'], arguments=[FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='[[Image:Targetingmarker.png|thumb|200px|Targeting marker]]\nThis function is used to toggle the health target marker on top of all pedestrians.', arguments={'enabled': 'A boolean denoting whether we want to enable (true) or disable (false) the markers.'}, result="Returns ''true'' if the markers were enabled, ''false'' if weren't or if invalid arguments are passed."), oop=None, url=FunctionUrl(url='/wiki/SetPedTargetingMarkerEnabled', name='setPedTargetingMarkerEnabled', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setPedVoice', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='voiceType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='voiceName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Changes the voice of a ped.', arguments={'thePed': 'the ped whose voice to change.', 'voiceType': 'the voice type. See ped voices for possible types.', 'voiceName': 'the voice name within the specified type. See ped voices for possible voices.'}, result="Returns ''true'' when the voice was successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetPedVoice', name='setPedVoice', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPedWalkingStyle', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='style', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the walking style of a ped. A walking style consists of a set of animations that are used for walking, running etc.', arguments={'thePed': 'the ped whose walking style to change.', 'style': 'the walking style to set.\nThe possible walking styles are:\n{{Ped walking styles}}'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='setWalkingStyle', field='walkingStyle'), url=FunctionUrl(url='/wiki/SetPedWalkingStyle', name='setPedWalkingStyle', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPedWalkingStyle', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='style', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the walking style of a ped. A walking style consists of a set of animations that are used for walking, running etc.', arguments={'thePed': 'the ped whose walking style to change.', 'style': 'the walking style to set.\nThe possible walking styles are:\n{{Ped walking styles}}'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='setWalkingStyle', field='walkingStyle'), url=FunctionUrl(url='/wiki/SetPedWalkingStyle', name='setPedWalkingStyle', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPedWeaponSlot', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='weaponSlot', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the selected weapon slot of a [[ped]].', arguments={'thePed': 'the ped whose weapon slot you want to set. In a clientside script, this cannot be used on remote players.', 'weaponSlot': 'the weapon slot to set.\n{{Weapon_Slots}}'}, result="Returns ''true'' if successful in setting the ped's equipped weapon slot, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='setWeaponSlot', field='weaponSlot'), url=FunctionUrl(url='/wiki/SetPedWeaponSlot', name='setPedWeaponSlot', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPedWeaponSlot', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='weaponSlot', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the selected weapon slot of a [[ped]].', arguments={'thePed': 'the ped whose weapon slot you want to set. In a clientside script, this cannot be used on remote players.', 'weaponSlot': 'the weapon slot to set.\n{{Weapon_Slots}}'}, result="Returns ''true'' if successful in setting the ped's equipped weapon slot, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='setWeaponSlot', field='weaponSlot'), url=FunctionUrl(url='/wiki/SetPedWeaponSlot', name='setPedWeaponSlot', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='warpPedIntoVehicle', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='seat', argument_type='int', default_value='0', optional=False)]), docs=FunctionDoc(description="This function is used to warp or force a ped into a vehicle.  There are no animations involved when this happens.\n[[File:vehicle seat ids.png|200px|thumb|right|Vehicle seat ids]] \n'''Available client side from 1.3.1''' (It will only work with client side vehicles and peds)", arguments={'thePed': 'The ped which you wish to force inside the vehicle', 'theVehicle': 'The vehicle you wish to force the ped into\n{{OptionalArg}} ', 'seat': 'An integer representing the seat ID.', '0': 'Front-left', '1': 'Front-right', '2': 'Rear-left', '3': 'Rear-right'}, result="Returns ''true'' if the operation is successful, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='warpIntoVehicle', field='vehicle'), url=FunctionUrl(url='/wiki/WarpPedIntoVehicle', name='warpPedIntoVehicle', category='Ped functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='warpPedIntoVehicle', return_types=['bool'], arguments=[FunctionArgument(name='thePed', argument_type='ped', default_value=None, optional=False), FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='seat', argument_type='int', default_value='0', optional=False)]), docs=FunctionDoc(description="This function is used to warp or force a ped into a vehicle.  There are no animations involved when this happens.\n[[File:vehicle seat ids.png|200px|thumb|right|Vehicle seat ids]] \n'''Available client side from 1.3.1''' (It will only work with client side vehicles and peds)", arguments={'thePed': 'The ped which you wish to force inside the vehicle', 'theVehicle': 'The vehicle you wish to force the ped into\n{{OptionalArg}} ', 'seat': 'An integer representing the seat ID.', '0': 'Front-left', '1': 'Front-right', '2': 'Rear-left', '3': 'Rear-right'}, result="Returns ''true'' if the operation is successful, ''false'' otherwise."), oop=FunctionOOP(class_name='ped', method_name='warpIntoVehicle', field='vehicle'), url=FunctionUrl(url='/wiki/WarpPedIntoVehicle', name='warpPedIntoVehicle', category='Ped functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createPickup', return_types=['pickup'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='theType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='amount', argument_type='int', default_value=None, optional=False), FunctionArgument(name='respawnTime', argument_type='int', default_value='30000', optional=False), FunctionArgument(name='ammo', argument_type='int', default_value='50', optional=False)]), docs=FunctionDoc(description='This function creates a pickup element, which is placed in the GTA world and can be picked up to retrieve a health, armour or a weapon. ', arguments={'x': ': A floating point number representing the X coordinate on the map.', 'y': ': A floating point number representing the Y coordinate on the map.', 'z': ': A floating point number representing the Z coordinate on the map.', 'theType': ': This is an integer representing the type of pickup, representing the following types:', '0': ': Health Pickup', '1': ': Armour Pickup', '2': ': Weapon Pickup', '3': ': Custom Pickup', 'amount': ": This is an integer representing the amount of Health points or Armour points a pickup has.\n'''OR'''", 'weapon': ": If the type is a Weapon pickup, then it represents the Weapon|weapon ID of the weapon pickup. When used with the weapon pickup type set, the ammo parameter can be used.\n'''OR'''", 'model': ': If the pickup is a custom model, this is the model id to use. Many non-pickup models can be used, though some may cause crashes. The following is a list of models designed to be used as pickups.', '1212': 'Money (wad of cash)', '1240': 'Health (heart)', '1242': 'Armour', '1239': 'Info icon', '1272': 'House (blue)', '1273': 'House (green)', '1241': 'Adrenaline', '1247': 'Bribe', '1248': 'GTA III sign', '1252': 'Bomb from GTA III', '1253': 'Photo op', '1254': 'Skull', '1274': 'Money icon', '1275': 'Blue t-shirt', '1277': 'Save disk', '1313': '2 Skulls', '1314': '2 Players icon', '1276': 'Tiki statue', '1310': 'Parachute (with leg straps)', '1318': 'Down arrow', '1279': "Drug bundle\n'''OR'''\nOther ID Object\n{{OptionalArg}} ", 'respawnTime': ': How long before the pickup respawns in milliseconds (This parameter is ignored on the client!)', 'ammo': ': An integer representing the amount of ammo a pickup contains.  This is only valid when the pickup type is a weapon pickup.'}, result="Returns [[pickup]] [[element]] if the pickup was created succesfully, otherwise returns ''false''."), oop=None, url=FunctionUrl(url='/wiki/CreatePickup', name='createPickup', category='Pickup functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createPickup', return_types=['pickup'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='theType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='amount', argument_type='int', default_value=None, optional=False), FunctionArgument(name='respawnTime', argument_type='int', default_value='30000', optional=False), FunctionArgument(name='ammo', argument_type='int', default_value='50', optional=False)]), docs=FunctionDoc(description='This function creates a pickup element, which is placed in the GTA world and can be picked up to retrieve a health, armour or a weapon. ', arguments={'x': ': A floating point number representing the X coordinate on the map.', 'y': ': A floating point number representing the Y coordinate on the map.', 'z': ': A floating point number representing the Z coordinate on the map.', 'theType': ': This is an integer representing the type of pickup, representing the following types:', '0': ': Health Pickup', '1': ': Armour Pickup', '2': ': Weapon Pickup', '3': ': Custom Pickup', 'amount': ": This is an integer representing the amount of Health points or Armour points a pickup has.\n'''OR'''", 'weapon': ": If the type is a Weapon pickup, then it represents the Weapon|weapon ID of the weapon pickup. When used with the weapon pickup type set, the ammo parameter can be used.\n'''OR'''", 'model': ': If the pickup is a custom model, this is the model id to use. Many non-pickup models can be used, though some may cause crashes. The following is a list of models designed to be used as pickups.', '1212': 'Money (wad of cash)', '1240': 'Health (heart)', '1242': 'Armour', '1239': 'Info icon', '1272': 'House (blue)', '1273': 'House (green)', '1241': 'Adrenaline', '1247': 'Bribe', '1248': 'GTA III sign', '1252': 'Bomb from GTA III', '1253': 'Photo op', '1254': 'Skull', '1274': 'Money icon', '1275': 'Blue t-shirt', '1277': 'Save disk', '1313': '2 Skulls', '1314': '2 Players icon', '1276': 'Tiki statue', '1310': 'Parachute (with leg straps)', '1318': 'Down arrow', '1279': "Drug bundle\n'''OR'''\nOther ID Object\n{{OptionalArg}} ", 'respawnTime': ': How long before the pickup respawns in milliseconds (This parameter is ignored on the client!)', 'ammo': ': An integer representing the amount of ammo a pickup contains.  This is only valid when the pickup type is a weapon pickup.'}, result="Returns [[pickup]] [[element]] if the pickup was created succesfully, otherwise returns ''false''."), oop=None, url=FunctionUrl(url='/wiki/CreatePickup', name='createPickup', category='Pickup functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPickupAmmo', return_types=['int'], arguments=[FunctionArgument(name='thePickup', argument_type='pickup', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the amount of ammo in a weapon pickup.', arguments={'thePickup': 'The pickup in which you wish to retrieve the ammo of'}, result="Returns an ''integer'' of the amount of ammo in the pickup, ''false'' if the pickup element is invalid, 0 if it's no weapon pickup."), oop=None, url=FunctionUrl(url='/wiki/GetPickupAmmo', name='getPickupAmmo', category='Pickup functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPickupAmmo', return_types=['int'], arguments=[FunctionArgument(name='thePickup', argument_type='pickup', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the amount of ammo in a weapon pickup.', arguments={'thePickup': 'The pickup in which you wish to retrieve the ammo of'}, result="Returns an ''integer'' of the amount of ammo in the pickup, ''false'' if the pickup element is invalid, 0 if it's no weapon pickup."), oop=None, url=FunctionUrl(url='/wiki/GetPickupAmmo', name='getPickupAmmo', category='Pickup functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPickupAmount', return_types=['int'], arguments=[FunctionArgument(name='thePickup', argument_type='pickup', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the amount of health or armor given from a pickup.', arguments={'thePickup': 'The pickup you wish to retrieve the amount from.'}, result="Returns an ''integer'' of the amount the pickup is set to, ''false'' if it's invalid, 0 if it's no health or amor pickup."), oop=None, url=FunctionUrl(url='/wiki/GetPickupAmount', name='getPickupAmount', category='Pickup functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPickupAmount', return_types=['int'], arguments=[FunctionArgument(name='thePickup', argument_type='pickup', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the amount of health or armor given from a pickup.', arguments={'thePickup': 'The pickup you wish to retrieve the amount from.'}, result="Returns an ''integer'' of the amount the pickup is set to, ''false'' if it's invalid, 0 if it's no health or amor pickup."), oop=None, url=FunctionUrl(url='/wiki/GetPickupAmount', name='getPickupAmount', category='Pickup functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPickupType', return_types=['int'], arguments=[FunctionArgument(name='thePickup', argument_type='pickup', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the type of a pickup, either a health, armour or weapon pickup.', arguments={'thePickup': 'The pickup you wish to retrieve the type of.'}, result="Returns ''false'' if the pickup is invalid, or an integer of the type of the pickup, which include:\n*'''0:''' Health pickup\n*'''1:''' Armour pickup\n*'''2:''' Weapon pickup\n*'''3:''' Custom Pickup"), oop=None, url=FunctionUrl(url='/wiki/GetPickupType', name='getPickupType', category='Pickup functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPickupType', return_types=['int'], arguments=[FunctionArgument(name='thePickup', argument_type='pickup', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the type of a pickup, either a health, armour or weapon pickup.', arguments={'thePickup': 'The pickup you wish to retrieve the type of.'}, result="Returns ''false'' if the pickup is invalid, or an integer of the type of the pickup, which include:\n*'''0:''' Health pickup\n*'''1:''' Armour pickup\n*'''2:''' Weapon pickup\n*'''3:''' Custom Pickup"), oop=None, url=FunctionUrl(url='/wiki/GetPickupType', name='getPickupType', category='Pickup functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPickupWeapon', return_types=['int'], arguments=[FunctionArgument(name='thePickup', argument_type='pickup', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the weapon ID of a weapon pickup.', arguments={'thePickup': 'The pickup of which you wish to retrieve the weapon'}, result="Returns the [[Weapons|Weapon ID]] of the pickup, or ''false'' if the pickup is invalid."), oop=None, url=FunctionUrl(url='/wiki/GetPickupWeapon', name='getPickupWeapon', category='Pickup functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPickupWeapon', return_types=['int'], arguments=[FunctionArgument(name='thePickup', argument_type='pickup', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the weapon ID of a weapon pickup.', arguments={'thePickup': 'The pickup of which you wish to retrieve the weapon'}, result="Returns the [[Weapons|Weapon ID]] of the pickup, or ''false'' if the pickup is invalid."), oop=None, url=FunctionUrl(url='/wiki/GetPickupWeapon', name='getPickupWeapon', category='Pickup functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPickupType', return_types=['bool'], arguments=[FunctionArgument(name='thePickup', argument_type='pickup', default_value=None, optional=False), FunctionArgument(name='theType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='amount', argument_type='int', default_value=None, optional=False), FunctionArgument(name='ammo', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description="This function allows changing the type of a pickup to a Weapon, Armour or Health pickup, and allows you to set the health points '''or''' the weapon and ammo that the pickup will give.", arguments={'thePickup': 'The pickup which you wish to change the settings of', 'theType': ': An integer representing the type of pickup. You can choose from:', '0': ': Health Pickup', '1': ': Armour Pickup', '2': ': Weapon Pickup', '3': ': Custom Pickup', 'amount': ": This is an integer representing the amount of Health points or Armour points a pickup has.\n'''OR'''", 'weapon': ": If the type is a Weapon pickup, then it represents the Weapon|weapon ID of the weapon pickup the ammo field must be entered if the type is Weapon Pickup.\n'''OR'''", 'model': ': If the pickup is a custom model, this is the model id to use. Many non-pickup models can be used, though some may cause crashes. The following is a list of models designed to be used as pickups.', '370': 'Jetpack', '1240': 'Health (heart)', '1242': 'Armour', '1272': 'House (blue)', '1273': 'House (green)', '1274': 'Money (dollar symbol)', '1277': 'Save (floppy disk)\n{{OptionalArg}} ', 'ammo': ': An integer representing the amount of ammo a pickup contains. This argument is only valid when the pickup type is a Weapon Pickup, and must be specified in that case.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetPickupType', name='setPickupType', category='Pickup functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPickupType', return_types=['bool'], arguments=[FunctionArgument(name='thePickup', argument_type='pickup', default_value=None, optional=False), FunctionArgument(name='theType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='amount', argument_type='int', default_value=None, optional=False), FunctionArgument(name='ammo', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description="This function allows changing the type of a pickup to a Weapon, Armour or Health pickup, and allows you to set the health points '''or''' the weapon and ammo that the pickup will give.", arguments={'thePickup': 'The pickup which you wish to change the settings of', 'theType': ': An integer representing the type of pickup. You can choose from:', '0': ': Health Pickup', '1': ': Armour Pickup', '2': ': Weapon Pickup', '3': ': Custom Pickup', 'amount': ": This is an integer representing the amount of Health points or Armour points a pickup has.\n'''OR'''", 'weapon': ": If the type is a Weapon pickup, then it represents the Weapon|weapon ID of the weapon pickup the ammo field must be entered if the type is Weapon Pickup.\n'''OR'''", 'model': ': If the pickup is a custom model, this is the model id to use. Many non-pickup models can be used, though some may cause crashes. The following is a list of models designed to be used as pickups.', '370': 'Jetpack', '1240': 'Health (heart)', '1242': 'Armour', '1272': 'House (blue)', '1273': 'House (green)', '1274': 'Money (dollar symbol)', '1277': 'Save (floppy disk)\n{{OptionalArg}} ', 'ammo': ': An integer representing the amount of ammo a pickup contains. This argument is only valid when the pickup type is a Weapon Pickup, and must be specified in that case.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetPickupType', name='setPickupType', category='Pickup functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='forcePlayerMap', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='forceOn', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to forcefully show a player's radar map.", arguments={'thePlayer': ': A player object referencing the specified player', 'forceOn': ': A boolean value representing whether or not the players radar map will be forced on'}, result="Returns ''true'' if the player's radar map was forced on, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='forceMap', field='mapForced'), url=FunctionUrl(url='/wiki/ForcePlayerMap', name='forcePlayerMap', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='forcePlayerMap', return_types=['bool'], arguments=[FunctionArgument(name='forceOn', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to forcefully show a player's radar map.", arguments={'forceOn': ': A boolean value representing whether or not the players radar map will be forced on'}, result="Returns ''true'' if the player's radar map was forced on, ''false'' otherwise."), oop=FunctionOOP(class_name='Player', method_name='forceMap', field=None), url=FunctionUrl(url='/wiki/ForcePlayerMap', name='forcePlayerMap', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getLocalPlayer', return_types=['player'], arguments=[]), docs=FunctionDoc(description="This function gets the player element of the client running the current script. \nYou can use the predefined variable '''localPlayer''' instead of typing getLocalPlayer()\n}}", arguments={}, result='Returns the local [[player]] element.'), oop=None, url=FunctionUrl(url='/wiki/GetLocalPlayer', name='getLocalPlayer', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerBlurLevel', return_types=['int'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to check the current blur level of a specified [[player]].', arguments={'thePlayer': 'The player whose blur level you want to check.'}, result="Returns the player's blur level if successful, ''false'' if an invalid player was given."), oop=FunctionOOP(class_name='player', method_name='getBlurLevel', field=None), url=FunctionUrl(url='/wiki/GetPlayerBlurLevel', name='getPlayerBlurLevel', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getBlurLevel', return_types=['int'], arguments=[]), docs=FunctionDoc(description='This function allows you to check the current blur level of a specified [[player]].', arguments={}, result='Returns the local blur level.'), oop=FunctionOOP(class_name='Player', method_name='getBlurLevel', field='blurLevel'), url=FunctionUrl(url='/wiki/GetPlayerBlurLevel', name='getPlayerBlurLevel', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerFromName', return_types=['player'], arguments=[FunctionArgument(name='playerName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a [[player]] [[element]] for the player with the name passed to the function.', arguments={'playerName': ': A string containing the name of the player you want to reference'}, result="Returns a [[player]] [[element]] for the player with the nickname provided. If there is no player with that name, ''false'' is returned."), oop=None, url=FunctionUrl(url='/wiki/GetPlayerFromName', name='getPlayerFromName', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPlayerFromName', return_types=['player'], arguments=[FunctionArgument(name='playerName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a [[player]] [[element]] for the player with the name passed to the function.', arguments={'playerName': ': A string containing the name of the player you want to reference'}, result="Returns a [[player]] [[element]] for the player with the nickname provided. If there is no player with that name, ''false'' is returned."), oop=None, url=FunctionUrl(url='/wiki/GetPlayerFromName', name='getPlayerFromName', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPlayerMapBoundingBox', return_types=['int,', 'int,', 'int,', 'int'], arguments=[]), docs=FunctionDoc(description='This function gets the GUI bounding box of the radar map texture.', arguments={}, result="* If the player's map is showing, it returns four integers: ''minX'', ''minY'', ''maxX'', ''maxY''.  These are '''absolute''' position coordinates of where the player's map is drawn on the screen.\n** ''minX, minY'' represent the world coordinates ''-3000, 3000'' (upper-left corner of the world map).\n** ''maxX, maxY'' represent the world coordinates ''3000, -3000'' (lower-right corner of the world map).\n** Negative values may be returned if these coordinates are off screen.\n* If the map is not showing, a ''false'' boolean value is returned."), oop=None, url=FunctionUrl(url='/wiki/GetPlayerMapBoundingBox', name='getPlayerMapBoundingBox', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerMoney', return_types=['int'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the amount of money a player currently has.', arguments={'thePlayer': 'The player you wish the retrieve the amount of money from.'}, result="Returns an integer with the amount of money the specified player has, ''false'' if the player is invalid."), oop=FunctionOOP(class_name='player', method_name='getMoney', field='money'), url=FunctionUrl(url='/wiki/GetPlayerMoney', name='getPlayerMoney', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPlayerMoney', return_types=['int'], arguments=[]), docs=FunctionDoc(description='Returns the amount of money a player currently has.', arguments={}, result='Returns an integer with the amount of money the local player has.'), oop=FunctionOOP(class_name='Player', method_name='getMoney', field=None), url=FunctionUrl(url='/wiki/GetPlayerMoney', name='getPlayerMoney', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerName', return_types=['string'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a string containing the name of the specified player.', arguments={'thePlayer': 'the player you want to get the name of'}, result="Returns a string containing the requested player's name, or ''false'' if the player passed to the function is invalid."), oop=FunctionOOP(class_name='player', method_name='getName', field='name'), url=FunctionUrl(url='/wiki/GetPlayerName', name='getPlayerName', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPlayerName', return_types=['string'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a string containing the name of the specified player.', arguments={'thePlayer': 'the player you want to get the name of'}, result="Returns a string containing the requested player's name, or ''false'' if the player passed to the function is invalid."), oop=FunctionOOP(class_name='player', method_name='getName', field='name'), url=FunctionUrl(url='/wiki/GetPlayerName', name='getPlayerName', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerNametagColor', return_types=['int,', 'int,', 'int'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function gets the current color of a player's name tag as RGB values. These are in the range 0-255.", arguments={'thePlayer': 'The player whose name tag RGB color values you wish to retrieve.'}, result="Returns ''red'', ''green'' and ''blue'' values if an existent player was specified, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='getNametagColor', field=None), url=FunctionUrl(url='/wiki/GetPlayerNametagColor', name='getPlayerNametagColor', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPlayerNametagColor', return_types=['int,', 'int,', 'int'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function gets the current color of a player's name tag as RGB values. These are in the range 0-255.", arguments={'thePlayer': 'The player whose name tag RGB color values you wish to retrieve.'}, result="Returns ''red'', ''green'' and ''blue'' values if an existent player was specified, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='getNametagColor', field=None), url=FunctionUrl(url='/wiki/GetPlayerNametagColor', name='getPlayerNametagColor', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerNametagText', return_types=['string'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis will allow you to retrieve the name tag a player is currently using.", arguments={'thePlayer': 'The person whose name tag you want to retrieve'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns a ''string'' with the nametag text, ''false'' if the player is invalid."), oop=FunctionOOP(class_name='player', method_name='getNametagText', field='nametagText'), url=FunctionUrl(url='/wiki/GetPlayerNametagText', name='getPlayerNametagText', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPlayerNametagText', return_types=['string'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis will allow you to retrieve the name tag a player is currently using.", arguments={'thePlayer': 'The person whose name tag you want to retrieve'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns a ''string'' with the nametag text, ''false'' if the player is invalid."), oop=FunctionOOP(class_name='player', method_name='getNametagText', field='nametagText'), url=FunctionUrl(url='/wiki/GetPlayerNametagText', name='getPlayerNametagText', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerPing', return_types=['int'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="This function returns the ping of a specified [[player]]. The ping is the number of milliseconds that data takes to travel from the player's client to the server or vice versa.", arguments={'thePlayer': ': The player whose ping you want to determine.'}, result="Returns the ping as an [[int]], or ''false'' if the player is invalid."), oop=FunctionOOP(class_name='player', method_name='getPing', field='ping'), url=FunctionUrl(url='/wiki/GetPlayerPing', name='getPlayerPing', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPlayerPing', return_types=['int'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="This function returns the ping of a specified [[player]]. The ping is the number of milliseconds that data takes to travel from the player's client to the server or vice versa.", arguments={'thePlayer': ': The player whose ping you want to determine.'}, result="Returns the ping as an [[int]], or ''false'' if the player is invalid."), oop=FunctionOOP(class_name='player', method_name='getPing', field='ping'), url=FunctionUrl(url='/wiki/GetPlayerPing', name='getPlayerPing', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerTeam', return_types=['team'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the current [[team]] a [[player]] is on.', arguments={'thePlayer': ': The player whose team you want to find out.'}, result="Returns a ''team'' element representing the team the player is on, ''false'' if the player is not part of a team."), oop=FunctionOOP(class_name='player', method_name='getTeam', field='team'), url=FunctionUrl(url='/wiki/GetPlayerTeam', name='getPlayerTeam', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPlayerTeam', return_types=['team'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the current [[team]] a [[player]] is on.', arguments={'thePlayer': ': The player whose team you want to find out.'}, result="Returns a ''team'' element representing the team the player is on, ''false'' if the player is not part of a team."), oop=FunctionOOP(class_name='player', method_name='getTeam', field='team'), url=FunctionUrl(url='/wiki/GetPlayerTeam', name='getPlayerTeam', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerWantedLevel', return_types=['int'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets a player's current wanted level. The wanted level is indicated by the amount of stars a player has on the GTA HUD.", arguments={'thePlayer': 'The player whose wanted level you wish to get'}, result="Returns an ''int'' from 0 to 6 representing the player's wanted level, ''false'' if the player does not exist."), oop=FunctionOOP(class_name='player', method_name='getWantedLevel', field='wantedLevel'), url=FunctionUrl(url='/wiki/GetPlayerWantedLevel', name='getPlayerWantedLevel', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPlayerWantedLevel', return_types=['int'], arguments=[]), docs=FunctionDoc(description="This function gets a player's current wanted level. The wanted level is indicated by the amount of stars a player has on the GTA HUD.", arguments={}, result="Returns an ''int'' from 0 to 6 representing the player's wanted level, ''false'' if the player does not exist."), oop=FunctionOOP(class_name='Player', method_name='getWantedLevel', field=None), url=FunctionUrl(url='/wiki/GetPlayerWantedLevel', name='getPlayerWantedLevel', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='givePlayerMoney', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='amount', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function adds money to a [[player]]'s current money amount.  To set absolute values, [[setPlayerMoney]] can be used.<br>", arguments={'thePlayer': 'the player you are giving the money to.', 'amount': 'a positive integer number specifying the amount of money to give to the player.'}, result="Returns ''true'' if the money was added, or ''false'' if invalid parameters were passed."), oop=FunctionOOP(class_name='player', method_name='giveMoney', field="money}}\n===Required Arguments=== \n*'''thePlayer:''' the [[player]] you are giving the money to.\n*'''amount:''' a positive integer number specifying the amount of money to give to the player.\n"), url=FunctionUrl(url='/wiki/GivePlayerMoney', name='givePlayerMoney', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='givePlayerMoney', return_types=['bool'], arguments=[FunctionArgument(name='amount', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function adds money to a [[player]]'s current money amount.  To set absolute values, [[setPlayerMoney]] can be used.<br>", arguments={'amount': 'a positive integer number specifying the amount of money to give to the player.'}, result="Returns ''true'' if the money was added, or ''false'' if invalid parameters were passed."), oop=None, url=FunctionUrl(url='/wiki/GivePlayerMoney', name='givePlayerMoney', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isPlayerHudComponentVisible', return_types=['bool'], arguments=[FunctionArgument(name='component', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function can be used to check whether an hud component is visable or not.', arguments={'component': 'The component you wish to check. Valid values are:', 'ammo': 'The display showing how much ammo the player has in their weapon', 'area_name': 'The text that appears containing the name of the area a player has entered', 'armour': 'The display showing the players armor', 'breath': 'The display showing the players breath', 'clock': 'The display showing the in-game time', 'health': 'The display showing the players health', 'money': 'The display showing how much money the player has', 'radar': 'The bottom-left corner miniradar', 'vehicle_name': 'The text that appears containing the players vehicle name when the player enters a vehicle', 'weapon': 'The display showing the players weapon\n{{New feature/item|3.0110|1.1||', 'radio': 'The display showing the radio label', 'wanted': 'The display showing the players wanted level', 'crosshair': 'The weapon crosshair and sniper scope\n}}'}, result="Returns ''true'' if the component is visable, ''false'' if not."), oop=None, url=FunctionUrl(url='/wiki/IsPlayerHudComponentVisible', name='isPlayerHudComponentVisible', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isPlayerMapForced', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="This function checks if the specified player's radar map has been forced on or not.", arguments={'thePlayer': 'A player object referencing the specified player'}, result="Returns ''true'' if the player's radar map is forced on, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='isMapForced', field='mapForced'), url=FunctionUrl(url='/wiki/IsPlayerMapForced', name='isPlayerMapForced', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isPlayerMapForced', return_types=['bool'], arguments=[]), docs=FunctionDoc(description="This function checks if the specified player's radar map has been forced on or not.", arguments={}, result="Returns ''true'' if the local player's radar map is forced on, ''false'' otherwise."), oop=FunctionOOP(class_name='Player', method_name='isMapForced', field=None), url=FunctionUrl(url='/wiki/IsPlayerMapForced', name='isPlayerMapForced', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isPlayerMapVisible', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='[[Image:MTAsa_Default_Map.png|thumb|224px|Screenshot of the default map]]\nThis function checks if the local player has their map showing.', arguments={}, result="Returns ''true'' if the player has the map visible, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsPlayerMapVisible', name='isPlayerMapVisible', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isPlayerNametagShowing', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function will allow you to determine if a player's name tag is currently showing.", arguments={'thePlayer': 'The player whose current name tag condition you want to check'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the player's name tag is being shown, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='isNametagShowing', field='nametagShowing'), url=FunctionUrl(url='/wiki/IsPlayerNametagShowing', name='isPlayerNametagShowing', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isPlayerNametagShowing', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function will allow you to determine if a player's name tag is currently showing.", arguments={'thePlayer': 'The player whose current name tag condition you want to check'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the player's name tag is being shown, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='isNametagShowing', field='nametagShowing'), url=FunctionUrl(url='/wiki/IsPlayerNametagShowing', name='isPlayerNametagShowing', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isVoiceEnabled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='Added to client side.\n}}\nThis function allows you to make the server reveal whether or not voice is currently enabled.', arguments={}, result="Returns ''true'' if the voice is enabled on the server, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsVoiceEnabled', name='isVoiceEnabled', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isVoiceEnabled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='Added to client side.\n}}\nThis function allows you to make the server reveal whether or not voice is currently enabled.', arguments={}, result="Returns ''true'' if the voice is enabled on the server, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsVoiceEnabled', name='isVoiceEnabled', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='resetBlurLevel', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='Resets the motion blur level on the clients screen to default value (36).', arguments={}, result="Returns ''true'' if the blur level was reset successfully. Returns ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetBlurLevel', name='resetBlurLevel', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerBlurLevel', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='level', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the motion blur level on the clients screen. Accepts a value between 0 and 255.', arguments={'thePlayer': 'The player whose blur level will be changed.', 'level': 'The level to set the blur to (default: 36)'}, result=''), oop=FunctionOOP(class_name='player', method_name='setBlurLevel', field='blurLevel'), url=FunctionUrl(url='/wiki/SetPlayerBlurLevel', name='setPlayerBlurLevel', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setBlurLevel', return_types=['bool'], arguments=[FunctionArgument(name='level', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the motion blur level on the clients screen. Accepts a value between 0 and 255.', arguments={'level': 'The level to set the blur to (default: 36)'}, result=''), oop=FunctionOOP(class_name='Player', method_name='setBlurLevel', field=None), url=FunctionUrl(url='/wiki/SetPlayerBlurLevel', name='setPlayerBlurLevel', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerHudComponentVisible', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='component', argument_type='string', default_value=None, optional=False), FunctionArgument(name='show', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function will show or hide a part of the player's HUD. ", arguments={'thePlayer': 'The player element for which you wish to show/hide a HUD component', 'component': 'The component you wish to show or hide. Valid values are:', 'all': 'All of the following at the same time', 'ammo': 'The display showing how much ammo the player has in their weapon', 'area_name': 'The text that appears containing the name of the area a player has entered', 'armour': 'The display showing the players armor', 'breath': 'The display showing the players breath', 'clock': 'The display showing the in-game time', 'health': 'The display showing the players health', 'money': 'The display showing how much money the player has', 'radar': 'The bottom-left corner miniradar', 'vehicle_name': 'The text that appears containing the players vehicle name when the player enters a vehicle', 'weapon': 'The display showing the players weapon\n{{New feature|3.0110|1.1|', 'radio': 'The display showing the radio label', 'wanted': 'The display showing the players wanted level', 'crosshair': 'The weapon crosshair and sniper scope\n}}', 'show': 'Specify if the component should be shown (true) or hidden (false)'}, result="Returns ''true'' if the component was shown or hidden succesfully, ''false'' if an invalid argument was specified."), oop=FunctionOOP(class_name='player', method_name='setHudComponentVisible', field=None), url=FunctionUrl(url='/wiki/SetPlayerHudComponentVisible', name='setPlayerHudComponentVisible', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPlayerHudComponentVisible', return_types=['bool'], arguments=[FunctionArgument(name='component', argument_type='string', default_value=None, optional=False), FunctionArgument(name='show', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function will show or hide a part of the player's HUD. ", arguments={'component': 'The component you wish to show or hide. Valid values are:', 'all': 'All of the following at the same time', 'ammo': 'The display showing how much ammo the player has in their weapon', 'area_name': 'The text that appears containing the name of the area a player has entered', 'armour': 'The display showing the players armor', 'breath': 'The display showing the players breath', 'clock': 'The display showing the in-game time', 'health': 'The display showing the players health', 'money': 'The display showing how much money the player has', 'radar': 'The bottom-left corner miniradar', 'vehicle_name': 'The text that appears containing the players vehicle name when the player enters a vehicle', 'weapon': 'The display showing the players weapon\n{{New feature/item|3.0110|1.1||', 'radio': 'The display showing the radio label', 'wanted': 'The display showing the players wanted level', 'crosshair': 'The weapon crosshair and sniper scope\n}}', 'show': 'Specify if the component should be shown (true) or hidden (false)'}, result="Returns ''true'' if the component was shown or hidden succesfully, ''false'' if an invalid argument was specified."), oop=None, url=FunctionUrl(url='/wiki/SetPlayerHudComponentVisible', name='setPlayerHudComponentVisible', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerMoney', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='amount', argument_type='int', default_value=None, optional=False), FunctionArgument(name='instant', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="Sets a player's money to a certain value, regardless of current player money. It should be noted that setting negative values does not work and in fact gives the player large amounts of money.", arguments={'thePlayer': 'Which player to set the money of.', 'amount': 'A whole integer specifying the new amount of money the player will have.\n{{OptionalArg}}\n{{New items|3.0140|1.4|', 'instant': 'If set to true money will be set instantly without counting up/down like in singleplayer.}}'}, result="Returns ''true'' if the money was added, or ''false'' if invalid parameters were passed."), oop=FunctionOOP(class_name='player', method_name='setMoney', field='money'), url=FunctionUrl(url='/wiki/SetPlayerMoney', name='setPlayerMoney', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPlayerMoney', return_types=['bool'], arguments=[FunctionArgument(name='amount', argument_type='int', default_value=None, optional=False), FunctionArgument(name='instant', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="Sets a player's money to a certain value, regardless of current player money. It should be noted that setting negative values does not work and in fact gives the player large amounts of money.", arguments={'amount': 'A whole integer specifying the new amount of money the local player will have.\n{{OptionalArg}}\n{{New items|3.0140|1.4|', 'instant': 'If set to true money will be set instantly without counting up/down like in singleplayer.}}'}, result="Returns ''true'' if the money was added, or ''false'' if invalid parameters were passed."), oop=FunctionOOP(class_name='Player', method_name='setMoney', field=None), url=FunctionUrl(url='/wiki/SetPlayerMoney', name='setPlayerMoney', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerNametagColor', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='r', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis allows you to change the RGB color mixture in the name tags of players.", arguments={'thePlayer': 'The player whose name tag text you wish to change the color of', 'r': 'The amount of red you want in the mixture of RGB (0-255 is valid)', 'g': 'The amount of green you want in the mixture of RGB (0-255 is valid)', 'b': 'The amount of blue you want in the mixture of RGB (0-255 is valid)\n{{New feature|2|DP2|', 'false': 'If false is specified instead of the colors, the nametag color will reset to defaulting to your team color.\n}}'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the function was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='setNametagColor', field=None), url=FunctionUrl(url='/wiki/SetPlayerNametagColor', name='setPlayerNametagColor', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPlayerNametagColor', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='r', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis allows you to change the RGB color mixture in the name tags of players.", arguments={'thePlayer': 'The player whose name tag text you wish to change the color of', 'r': 'The amount of red you want in the mixture of RGB (0-255 is valid)', 'g': 'The amount of green you want in the mixture of RGB (0-255 is valid)', 'b': 'The amount of blue you want in the mixture of RGB (0-255 is valid)\n{{New feature|2|DP2|', 'false': 'If false is specified instead of the colors, the nametag color will reset to defaulting to your team color.\n}}'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if the function was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='setNametagColor', field=None), url=FunctionUrl(url='/wiki/SetPlayerNametagColor', name='setPlayerNametagColor', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerNametagShowing', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='showing', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="Use this to define whether the player's name tag is visible or invisible.", arguments={'thePlayer': 'Define the player whos tag visiblity status you want to change', 'showing': 'Use true or false to show/hide the tag'}, result="Returns ''true'' if successful, ''false'' otherwise"), oop=FunctionOOP(class_name='player', method_name='setNametagShowing', field='nametagShowing'), url=FunctionUrl(url='/wiki/SetPlayerNametagShowing', name='setPlayerNametagShowing', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPlayerNametagShowing', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='showing', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="Use this to define whether the player's name tag is visible or invisible.", arguments={'thePlayer': 'Define the player whos tag visiblity status you want to change', 'showing': 'Use true or false to show/hide the tag'}, result="Returns ''true'' if successful, ''false'' otherwise"), oop=FunctionOOP(class_name='player', method_name='setNametagShowing', field='nametagShowing'), url=FunctionUrl(url='/wiki/SetPlayerNametagShowing', name='setPlayerNametagShowing', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerNametagText', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='text', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis will change the text of a player's nickname in the world to something besides the nickname he chose. This will not change the player's actual nickname, it only changes the visible aspect inside the world (you will see his original nickname in the scoreboard and will refer to his original name in scripts).", arguments={'thePlayer': 'The player whose nickname text you wish to change', 'text': 'The new nickname text that will be displayed'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='setNametagText', field='nametagText'), url=FunctionUrl(url='/wiki/SetPlayerNametagText', name='setPlayerNametagText', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setPlayerNametagText', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='text', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis will change the text of a player's nickname in the world to something besides the nickname he chose. This will not change the player's actual nickname, it only changes the visible aspect inside the world (you will see his original nickname in the scoreboard and will refer to his original name in scripts).", arguments={'thePlayer': 'The player whose nickname text you wish to change', 'text': 'The new nickname text that will be displayed'}, result="<!-- Make this descriptive. Explain what cases will return false. If you're unsure, add a tag to it so we can check -->\nReturns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='player', method_name='setNametagText', field='nametagText'), url=FunctionUrl(url='/wiki/SetPlayerNametagText', name='setPlayerNametagText', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='takePlayerMoney', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='amount', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function subtracts money from a [[player]]'s current money amount.", arguments={'thePlayer': 'the player you are taking the money from.', 'amount': 'an integer number specifying the amount of money to take from the player.'}, result="Returns ''true'' if the money was taken, or ''false'' if invalid parameters were passed."), oop=FunctionOOP(class_name='player', method_name='takeMoney', field='money'), url=FunctionUrl(url='/wiki/TakePlayerMoney', name='takePlayerMoney', category='Player functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='takePlayerMoney', return_types=['bool'], arguments=[FunctionArgument(name='amount', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function subtracts money from a [[player]]'s current money amount.", arguments={'amount': 'an integer number specifying the amount of money to take from the player.'}, result="Returns ''true'' if the money was taken, or ''false'' if invalid parameters were passed."), oop=None, url=FunctionUrl(url='/wiki/TakePlayerMoney', name='takePlayerMoney', category='Player functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='createProjectile', return_types=['projectile'], arguments=[FunctionArgument(name='creator', argument_type='element', default_value=None, optional=False), FunctionArgument(name='weaponType', argument_type='int', default_value=None, optional=False), FunctionArgument(name='posX', argument_type='float', default_value=None, optional=True), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=True), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=True), FunctionArgument(name='force', argument_type='float', default_value='1.0', optional=True), FunctionArgument(name='target', argument_type='element', default_value='nil', optional=True), FunctionArgument(name='rotX', argument_type='float', default_value=None, optional=True), FunctionArgument(name='rotY', argument_type='float', default_value=None, optional=True), FunctionArgument(name='rotZ', argument_type='float', default_value=None, optional=True), FunctionArgument(name='velX', argument_type='float', default_value=None, optional=True), FunctionArgument(name='velY', argument_type='float', default_value=None, optional=True), FunctionArgument(name='velZ', argument_type='float', default_value=None, optional=True), FunctionArgument(name='model', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description="This function creates a projectile of the specified type on the specified coordinates.\n*'''Model''' argument is not synchronized between clients. Clients differs from local player see always standard projectile model.\n*'''Target''' argument can only be defined as a player or another projectile.\n}}", arguments={'creator': 'The element representing creator of the projectile. In case you want the projectile to be synced for everybody creator must be the local player or his vehicle.', 'weaponType': 'int representing the projectile weaponType (characteristics). Valid IDs are:\n{{Projectiles}}\n{{OptionalArg}}', 'posX': ', posY, posZ: float starting coordinates for the projectile. They are coordinates of creator by default.', 'force': ': float representing the starting force for throwable projectiles.', 'target': ': element target used for heat seeking rockets.', 'rotX': ', rotY, rotZ: float starting rotation for the projectile.', 'velX': ', velY, velZ: float starting velocity for the projectile.', 'model': ': Integer representing the projectiles model, uses default model for weaponType if not specified.'}, result="Returns a ''[[projectile]]'' element if [[projectile]] creation was successful. Returns ''false'' if unable to create a [[projectile]] (wrong weapon ID or projectiles limit was reached)."), oop=None, url=FunctionUrl(url='/wiki/CreateProjectile', name='createProjectile', category='Projectile functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='detonateSatchels', return_types=['bool'], arguments=[FunctionArgument(name='Player', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function can be used to detonate a players satchels.', arguments={}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DetonateSatchels', name='detonateSatchels', category='Projectile functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='detonateSatchels', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function can be used to detonate a players satchels.', arguments={}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DetonateSatchels', name='detonateSatchels', category='Projectile functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getProjectileCounter', return_types=['int'], arguments=[FunctionArgument(name='projectile', argument_type='projectile', default_value=None, optional=False)]), docs=FunctionDoc(description='Get the time left before a projectile detonates.', arguments={}, result='Returns the the time in milliseconds to detonation which depending on the projectile type will do different things:\n* Grenades will explode when it hits 0\n* Teargas may be a duration timer\n* Both types of rockets will explode when it hits 0\n* Satchels restarts so I do not think it does anything'), oop=FunctionOOP(class_name='projectile', method_name='getCounter', field='counter'), url=FunctionUrl(url='/wiki/GetProjectileCounter', name='getProjectileCounter', category='Projectile functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getProjectileCreator', return_types=['element'], arguments=[FunctionArgument(name='theProjectile', argument_type='projectile', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the creator of the specified projectile.', arguments={'theProjectile': 'The projectiles| projectile element which creator you want to retrieve.'}, result="Returns the element which created the projectile if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='projectile', method_name='getCreator', field="creator}}\n\n===Required Arguments===\n*'''theProjectile:''' The [[projectiles"), url=FunctionUrl(url='/wiki/GetProjectileCreator', name='getProjectileCreator', category='Projectile functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getProjectileForce', return_types=['float'], arguments=[FunctionArgument(name='theProjectile', argument_type='projectile', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the force of the specified projectile.', arguments={'theProjectile': 'The projectiles| projectile element which force you want to retrieve.'}, result="Returns a [[float]] if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='projectile', method_name='getForce', field="force}}\n\n===Required Arguments===\n*'''theProjectile:''' The [[projectiles"), url=FunctionUrl(url='/wiki/GetProjectileForce', name='getProjectileForce', category='Projectile functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getProjectileTarget', return_types=['element'], arguments=[FunctionArgument(name='theProjectile', argument_type='projectile', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the target of the specified projectile.', arguments={'theProjectile': 'The projectiles| projectile element which target you want to retrieve.'}, result="Returns the [[element]] which is the projectile's target if the projectile is valid and can have a target (like a heat-seeking rocket), ''false'' otherwise.\n{{New feature/item|3.0141|1.4.0|6990|If the projectile is a satchel charge, returns the [[element]] at which it is glued to (or ''nil'' if it isn't glued to any).}}"), oop=FunctionOOP(class_name='projectile', method_name='getTarget', field="target}}\n\n===Required Arguments===\n*'''theProjectile:''' The [[projectiles"), url=FunctionUrl(url='/wiki/GetProjectileTarget', name='getProjectileTarget', category='Projectile functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getProjectileType', return_types=['int'], arguments=[FunctionArgument(name='theProjectile', argument_type='projectile', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the type of the specified projectile.', arguments={'theProjectile': 'The Element/Projectile|projectile element which type you want to retrieve.'}, result="Returns an [[int]]eger over the type of the projectile or ''false'' if invalid arguments were passed.\n{{Projectiles}}"), oop=FunctionOOP(class_name='projectile', method_name='getType', field="type}}\n\n===Required Arguments===\n*'''theProjectile:''' The [[Element/Projectile"), url=FunctionUrl(url='/wiki/GetProjectileType', name='getProjectileType', category='Projectile functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setProjectileCounter', return_types=['bool'], arguments=[FunctionArgument(name='projectile', argument_type='projectile', default_value=None, optional=False), FunctionArgument(name='timeToDetonate', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="Will change the projectile counter timer which depending on the projectile type will do different things:\n* Rockets and Grenades will explode when it hits 0\n* Teargas may be a duration timer\n* Satchels restart (we currently assume it doesn't cause an effect)\n* Molotov will explode with search ground level when it hits 0", arguments={'projectile': 'The projectile to edit the timer of.', 'timeToDetonate': 'The time in milliseconds to detonation.'}, result="Returns ''true'' on success, ''false'' otherwise."), oop=FunctionOOP(class_name='projectile', method_name='setCounter', field='counter'), url=FunctionUrl(url='/wiki/SetProjectileCounter', name='setProjectileCounter', category='Projectile functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createRadarArea', return_types=['radararea'], arguments=[FunctionArgument(name='startPosX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startPosY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='sizeX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='sizeY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='r', argument_type='int', default_value='255', optional=False), FunctionArgument(name='g', argument_type='int', default_value='0', optional=False), FunctionArgument(name='b', argument_type='int', default_value='0', optional=False), FunctionArgument(name='a', argument_type='int', default_value='255', optional=False), FunctionArgument(name='visibleTo', argument_type='element', default_value='root', optional=False)]), docs=FunctionDoc(description='This function can be used to create custom radar areas on the radar.', arguments={'startPosX': 'A float representing the origin x position of the radar area.', 'startPosY': 'A float representing the origin y position of the radar area.', 'sizeX': 'A float representing the width of the radar area.', 'sizeY': 'A float representing the height of the radar area.\n{{OptionalArg}} ', 'r': 'An integer representing the amount of red in the color.  Maximum value is 255', 'g': 'An integer representing the amount of green in the color.  Maximum value is 255', 'b': 'An integer representing the amount of blue in the color.  Maximum value is 255', 'a': 'An integer representing the amount of alpha in the color.  This allows setting the transparency of the radar area.  255 is opaque and 0 is transparent.', 'visibleTo': 'An element that you wish to restrict the visibility of the radar area to. (Server function only)'}, result=''), oop=None, url=FunctionUrl(url='/wiki/CreateRadarArea', name='createRadarArea', category='Radar area functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createRadarArea', return_types=['radararea'], arguments=[FunctionArgument(name='startPosX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startPosY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='sizeX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='sizeY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='r', argument_type='int', default_value='255', optional=False), FunctionArgument(name='g', argument_type='int', default_value='0', optional=False), FunctionArgument(name='b', argument_type='int', default_value='0', optional=False), FunctionArgument(name='a', argument_type='int', default_value='255', optional=False), FunctionArgument(name='visibleTo', argument_type='element', default_value='root', optional=False)]), docs=FunctionDoc(description='This function can be used to create custom radar areas on the radar.', arguments={'startPosX': 'A float representing the origin x position of the radar area.', 'startPosY': 'A float representing the origin y position of the radar area.', 'sizeX': 'A float representing the width of the radar area.', 'sizeY': 'A float representing the height of the radar area.\n{{OptionalArg}} ', 'r': 'An integer representing the amount of red in the color.  Maximum value is 255', 'g': 'An integer representing the amount of green in the color.  Maximum value is 255', 'b': 'An integer representing the amount of blue in the color.  Maximum value is 255', 'a': 'An integer representing the amount of alpha in the color.  This allows setting the transparency of the radar area.  255 is opaque and 0 is transparent.', 'visibleTo': 'An element that you wish to restrict the visibility of the radar area to. (Server function only)'}, result=''), oop=None, url=FunctionUrl(url='/wiki/CreateRadarArea', name='createRadarArea', category='Radar area functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getRadarAreaColor', return_types=['int,', 'int,', 'int,', 'int'], arguments=[FunctionArgument(name='theRadararea', argument_type='radararea', default_value=None, optional=False)]), docs=FunctionDoc(description='This function can be used to retrieve the current color of a [[radararea|radar area]].', arguments={'theRadararea': 'The radararea|radar area you wish to retrieve the colour of.'}, result="Returns four integers in RGBA format (''red'', ''green'', ''blue'', ''alpha''), with a maximum value of 255 for each.  Alpha decides transparency where 255 is opaque and 0 is transparent.  Returns ''false'' if the radararea is invalid."), oop=FunctionOOP(class_name='radararea', method_name="getColor}}\n\n===Required Arguments=== \n*'''theRadararea:''' The [[radararea", field="radar area]] you wish to retrieve the colour of.\n\n===Returns===\nReturns four integers in RGBA format (''red'', ''green'', ''blue'', ''alpha''), with a maximum value of 255 for each.  Alpha decides transparency where 255 is opaque and 0 is transparent.  Returns ''false'' if the radararea is invalid.\n\n"), url=FunctionUrl(url='/wiki/GetRadarAreaColor', name='getRadarAreaColor', category='Radar area functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getRadarAreaColor', return_types=['int,', 'int,', 'int,', 'int'], arguments=[FunctionArgument(name='theRadararea', argument_type='radararea', default_value=None, optional=False)]), docs=FunctionDoc(description='This function can be used to retrieve the current color of a [[radararea|radar area]].', arguments={'theRadararea': 'The radararea|radar area you wish to retrieve the colour of.'}, result="Returns four integers in RGBA format (''red'', ''green'', ''blue'', ''alpha''), with a maximum value of 255 for each.  Alpha decides transparency where 255 is opaque and 0 is transparent.  Returns ''false'' if the radararea is invalid."), oop=FunctionOOP(class_name='radararea', method_name="getColor}}\n\n===Required Arguments=== \n*'''theRadararea:''' The [[radararea", field="radar area]] you wish to retrieve the colour of.\n\n===Returns===\nReturns four integers in RGBA format (''red'', ''green'', ''blue'', ''alpha''), with a maximum value of 255 for each.  Alpha decides transparency where 255 is opaque and 0 is transparent.  Returns ''false'' if the radararea is invalid.\n\n"), url=FunctionUrl(url='/wiki/GetRadarAreaColor', name='getRadarAreaColor', category='Radar area functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getRadarAreaSize', return_types=['float,', 'float'], arguments=[FunctionArgument(name='theRadararea', argument_type='radararea', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used for getting the X and Y size of an existing [[radararea|radar area]].', arguments={'theRadararea': 'The radararea|radar area element whose size you wish to get.'}, result="Returns two ''floats'' indicating the X and Y length of the radar area respectively, ''false'' if the radar area is invalid."), oop=FunctionOOP(class_name='radararea', method_name="getSize}}\n\n===Required Arguments=== \n*'''theRadararea:''' The [[radararea", field="radar area]] element whose size you wish to get.\n\n===Returns===\nReturns two ''floats'' indicating the X and Y length of the radar area respectively, ''false'' if the radar area is invalid.\n\n"), url=FunctionUrl(url='/wiki/GetRadarAreaSize', name='getRadarAreaSize', category='Radar area functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getRadarAreaSize', return_types=['float,', 'float'], arguments=[FunctionArgument(name='theRadararea', argument_type='radararea', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used for getting the X and Y size of an existing [[radararea|radar area]].', arguments={'theRadararea': 'The radararea|radar area element whose size you wish to get.'}, result="Returns two ''floats'' indicating the X and Y length of the radar area respectively, ''false'' if the radar area is invalid."), oop=FunctionOOP(class_name='radararea', method_name="getSize}}\n\n===Required Arguments=== \n*'''theRadararea:''' The [[radararea", field="radar area]] element whose size you wish to get.\n\n===Returns===\nReturns two ''floats'' indicating the X and Y length of the radar area respectively, ''false'' if the radar area is invalid.\n\n"), url=FunctionUrl(url='/wiki/GetRadarAreaSize', name='getRadarAreaSize', category='Radar area functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isInsideRadarArea', return_types=['bool'], arguments=[FunctionArgument(name='theArea', argument_type='radararea', default_value=None, optional=False), FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if a 2D position is inside a [[radararea|radar area]] or not.', arguments={'theArea': 'The radararea|radar area youre checking the position against.', 'posX': 'The X coordinate of the position youre checking.', 'posY': 'The Y coordinate of the position youre checking.'}, result="Returns ''true'' if the position is inside the radar area, ''false'' if it isn't or if any parameters are invalid."), oop=FunctionOOP(class_name='radararea', method_name="isInside}}\n\n===Required Arguments=== \n*'''theArea:''' The [[radararea", field="radar area]] you're checking the position against.\n*'''posX:''' The X coordinate of the position you're checking.\n*'''posY:''' The Y coordinate of the position you're checking.\n\n===Returns===\nReturns ''true'' if the position is inside the radar area, ''false'' if it isn't or if any parameters are invalid.\n\n"), url=FunctionUrl(url='/wiki/IsInsideRadarArea', name='isInsideRadarArea', category='Radar area functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isInsideRadarArea', return_types=['bool'], arguments=[FunctionArgument(name='theArea', argument_type='radararea', default_value=None, optional=False), FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if a 2D position is inside a [[radararea|radar area]] or not.', arguments={'theArea': 'The radararea|radar area youre checking the position against.', 'posX': 'The X coordinate of the position youre checking.', 'posY': 'The Y coordinate of the position youre checking.'}, result="Returns ''true'' if the position is inside the radar area, ''false'' if it isn't or if any parameters are invalid."), oop=FunctionOOP(class_name='radararea', method_name="isInside}}\n\n===Required Arguments=== \n*'''theArea:''' The [[radararea", field="radar area]] you're checking the position against.\n*'''posX:''' The X coordinate of the position you're checking.\n*'''posY:''' The Y coordinate of the position you're checking.\n\n===Returns===\nReturns ''true'' if the position is inside the radar area, ''false'' if it isn't or if any parameters are invalid.\n\n"), url=FunctionUrl(url='/wiki/IsInsideRadarArea', name='isInsideRadarArea', category='Radar area functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isRadarAreaFlashing', return_types=['bool'], arguments=[FunctionArgument(name='theRadararea', argument_type='radararea', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows detection of whether a radar area is flashing or not.', arguments={'theRadararea': 'The radar area you wish to check the state of flashing'}, result="Returns ''true'' if the radar area is flashing, ''false'' if it is not or if it doesn't exist."), oop=FunctionOOP(class_name='radararea', method_name='isFlashing', field='flashing'), url=FunctionUrl(url='/wiki/IsRadarAreaFlashing', name='isRadarAreaFlashing', category='Radar area functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isRadarAreaFlashing', return_types=['bool'], arguments=[FunctionArgument(name='theRadararea', argument_type='radararea', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows detection of whether a radar area is flashing or not.', arguments={'theRadararea': 'The radar area you wish to check the state of flashing'}, result="Returns ''true'' if the radar area is flashing, ''false'' if it is not or if it doesn't exist."), oop=FunctionOOP(class_name='radararea', method_name='isFlashing', field='flashing'), url=FunctionUrl(url='/wiki/IsRadarAreaFlashing', name='isRadarAreaFlashing', category='Radar area functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setRadarAreaColor', return_types=['bool'], arguments=[FunctionArgument(name='theRadarArea', argument_type='radararea', default_value=None, optional=False), FunctionArgument(name='r', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b', argument_type='int', default_value=None, optional=False), FunctionArgument(name='a', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the color of an existing radar area.', arguments={'theRadarArea': 'the radararea element whose color you wish to set.', 'r': 'an integer representing the amount of red in the color (0 for no red, 255 for solid red)', 'g': 'an integer representing the amount of green in the color (0 for no green, 255 for solid green)', 'b': 'an integer representing the amount of blue in the color (0 for no blue, 255 for solid blue)', 'a': 'an integer representing the colors alpha (0 for transparent, 255 for opaque)'}, result="Returns ''true'' if the color was set successfully, ''false'' if the radar area doesn't exist or the color arguments are improper."), oop=None, url=FunctionUrl(url='/wiki/SetRadarAreaColor', name='setRadarAreaColor', category='Radar area functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setRadarAreaColor', return_types=['bool'], arguments=[FunctionArgument(name='theRadarArea', argument_type='radararea', default_value=None, optional=False), FunctionArgument(name='r', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b', argument_type='int', default_value=None, optional=False), FunctionArgument(name='a', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the color of an existing radar area.', arguments={'theRadarArea': 'the radararea element whose color you wish to set.', 'r': 'an integer representing the amount of red in the color (0 for no red, 255 for solid red)', 'g': 'an integer representing the amount of green in the color (0 for no green, 255 for solid green)', 'b': 'an integer representing the amount of blue in the color (0 for no blue, 255 for solid blue)', 'a': 'an integer representing the colors alpha (0 for transparent, 255 for opaque)'}, result="Returns ''true'' if the color was set successfully, ''false'' if the radar area doesn't exist or the color arguments are improper."), oop=None, url=FunctionUrl(url='/wiki/SetRadarAreaColor', name='setRadarAreaColor', category='Radar area functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setRadarAreaFlashing', return_types=['bool'], arguments=[FunctionArgument(name='theRadarArea', argument_type='radararea', default_value=None, optional=False), FunctionArgument(name='flash', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function makes an existing radar area flash in transparency.', arguments={'theRadarArea': 'the radararea element we want to change flashing state of.', 'flash': 'a bool indicating whether the radar area should flash (true to flash, false to not flash).'}, result="Returns ''true'' if the new flash state was successfully set, ''false'' if the radar area doesn't exist or invalid arguments were passed."), oop=FunctionOOP(class_name='radararea', method_name='setFlashing', field='flashing'), url=FunctionUrl(url='/wiki/SetRadarAreaFlashing', name='setRadarAreaFlashing', category='Radar area functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setRadarAreaFlashing', return_types=['bool'], arguments=[FunctionArgument(name='theRadarArea', argument_type='radararea', default_value=None, optional=False), FunctionArgument(name='flash', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function makes an existing radar area flash in transparency.', arguments={'theRadarArea': 'the radararea element we want to change flashing state of.', 'flash': 'a bool indicating whether the radar area should flash (true to flash, false to not flash).'}, result="Returns ''true'' if the new flash state was successfully set, ''false'' if the radar area doesn't exist or invalid arguments were passed."), oop=FunctionOOP(class_name='radararea', method_name='setFlashing', field='flashing'), url=FunctionUrl(url='/wiki/SetRadarAreaFlashing', name='setRadarAreaFlashing', category='Radar area functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setRadarAreaSize', return_types=['bool'], arguments=[FunctionArgument(name='theRadararea', argument_type='radararea', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the size of an existing [[radararea|radar area]].', arguments={'theRadararea': 'the radararea element whose size is to be changed.', 'x': 'the x length of the radar area.', 'y': 'the y length of the radar area.'}, result="Returns ''true'' if the size was set successfully, ''false'' if invalid arguments are passed."), oop=None, url=FunctionUrl(url='/wiki/SetRadarAreaSize', name='setRadarAreaSize', category='Radar area functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setRadarAreaSize', return_types=['bool'], arguments=[FunctionArgument(name='theRadararea', argument_type='radararea', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the size of an existing [[radararea|radar area]].', arguments={'theRadararea': 'the radararea element whose size is to be changed.', 'x': 'the x length of the radar area.', 'y': 'the y length of the radar area.'}, result="Returns ''true'' if the size was set successfully, ''false'' if invalid arguments are passed."), oop=None, url=FunctionUrl(url='/wiki/SetRadarAreaSize', name='setRadarAreaSize', category='Radar area functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fetchRemote', return_types=['bool'], arguments=[FunctionArgument(name='URL', argument_type='string', default_value=None, optional=False), FunctionArgument(name='queueName', argument_type='string', default_value='"default"', optional=False), FunctionArgument(name='connectionAttempts', argument_type='int', default_value='10', optional=False), FunctionArgument(name='connectTimeout', argument_type='int', default_value='10000', optional=False), FunctionArgument(name='callbackFunction', argument_type='function', default_value=None, optional=False), FunctionArgument(name='postData', argument_type='string', default_value='""', optional=False), FunctionArgument(name='postIsBinary', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function allows you to post and receive data from HTTP servers. The calls are asynchronous so you do not get an immediate result from the call, instead a callback function you specify is called when the download completes.\nIn the case when the call fails, a string containing "ERROR" followed by an integer containing the error reason will be passed to the callback function. The reason for failure will be similar to errors found with websites - file not found, server not found and timeouts.\nIf you are using fetchRemote to connect to a PHP script, you can use \'\'file_get_contents("php://input")\'\' to read the \'\'\'postData\'\'\' sent from this function.', arguments={'URL': 'A full URL in the format <nowiki>http://hostname/path/file.ext</nowiki>. A port can be specified with a colon followed by a port number appended to the hostname.', 'callbackFunction': 'This is the function that should receive the data returned from the remote server. The callback argument list should be:', 'responseData': '- A string containing the remote response or ERROR if there was a problem', 'error': '- A number containing the error number or zero if there was no error. A list of possible error values are:\n{{Error_codes_for_callRemote_and_fetchRemote}}\n<div style="padding-left:19px;">', 'arguments...': '- The arguments that were passed into fetchRemote\n</div>\n{{New items|4.0153|1.5.3-9.11270|', 'queueName': 'Name of the queue to use. Any name can be used. If not set, the queue name is default. Requests in the same queue are processed in order, one at a time.\n}}', 'connectionAttempts': 'Number of times to retry if the remote host does not respond. In the case of a non-responding remote server, each connection attempt will timeout after 10 seconds. Therefore, the default setting of 10 connection attempts means it will be 100 seconds before your script gets a callback about the error. Reducing this value to 2 for example, will decrease that period to 20 seconds', 'connectTimeout': 'Number of milliseconds each connection attempt will take before timing out', 'postData': 'A string specifying any data you want to send to the remote HTTP server.', 'postIsBinary ': 'A boolean specifying if the data is text, or binary.', 'arguments': 'Any arguments you may want to pass to the callback.\n{{New items|5.0154|1.5.4-9.11342|'}, result="{{New items|5.0154|1.5.7-9.20307|\nReturns a '''''request''''' value which can be used with [[GetRemoteRequestInfo|getRemoteRequestInfo]] or [[AbortRemoteRequest|abortRemoteRequest]]\n}}"), oop=None, url=FunctionUrl(url='/wiki/FetchRemote', name='fetchRemote', category='Resource functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fetchRemote', return_types=['bool'], arguments=[FunctionArgument(name='URL', argument_type='string', default_value=None, optional=False), FunctionArgument(name='queueName', argument_type='string', default_value='"default"', optional=False), FunctionArgument(name='connectionAttempts', argument_type='int', default_value='10', optional=False), FunctionArgument(name='connectTimeout', argument_type='int', default_value='10000', optional=False), FunctionArgument(name='callbackFunction', argument_type='function', default_value=None, optional=False), FunctionArgument(name='postData', argument_type='string', default_value='""', optional=False), FunctionArgument(name='postIsBinary', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function allows you to post and receive data from HTTP servers. The calls are asynchronous so you do not get an immediate result from the call, instead a callback function you specify is called when the download completes.\nIn the case when the call fails, a string containing "ERROR" followed by an integer containing the error reason will be passed to the callback function. The reason for failure will be similar to errors found with websites - file not found, server not found and timeouts.\nIf you are using fetchRemote to connect to a PHP script, you can use \'\'file_get_contents("php://input")\'\' to read the \'\'\'postData\'\'\' sent from this function.', arguments={'URL': 'A full URL in the format <nowiki>http://hostname/path/file.ext</nowiki>. A port can be specified with a colon followed by a port number appended to the hostname.', 'callbackFunction': 'This is the function that should receive the data returned from the remote server. The callback argument list should be:', 'responseData': '- A string containing the remote response or ERROR if there was a problem', 'error': '- A number containing the error number or zero if there was no error. A list of possible error values are:\n{{Error_codes_for_callRemote_and_fetchRemote}}\n<div style="padding-left:19px;">', 'arguments...': '- The arguments that were passed into fetchRemote\n</div>\n{{New items|4.0153|1.5.3-9.11270|', 'queueName': 'Name of the queue to use. Any name can be used. If not set, the queue name is default. Requests in the same queue are processed in order, one at a time.\n}}', 'connectionAttempts': 'Number of times to retry if the remote host does not respond. In the case of a non-responding remote server, each connection attempt will timeout after 10 seconds. Therefore, the default setting of 10 connection attempts means it will be 100 seconds before your script gets a callback about the error. Reducing this value to 2 for example, will decrease that period to 20 seconds', 'connectTimeout': 'Number of milliseconds each connection attempt will take before timing out', 'postData': 'A string specifying any data you want to send to the remote HTTP server.', 'postIsBinary ': 'A boolean specifying if the data is text, or binary.', 'arguments': 'Any arguments you may want to pass to the callback.\n{{New items|5.0154|1.5.4-9.11342|'}, result="{{New items|5.0154|1.5.7-9.20307|\nReturns a '''''request''''' value which can be used with [[GetRemoteRequestInfo|getRemoteRequestInfo]] or [[AbortRemoteRequest|abortRemoteRequest]]\n}}"), oop=None, url=FunctionUrl(url='/wiki/FetchRemote', name='fetchRemote', category='Resource functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResourceConfig', return_types=['xmlnode'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to return the root node of a configuration file. Config files must be predefined in a resource's [[Meta.xml|meta file]].  An alternative way to load XML files is to use [[xmlLoadFile]].", arguments={'filePath': 'The filepath of the file in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file.\n:For example, if there is a file named \'settings.xml\' in the resource \'ctf\', it can be accessed from another resource this way: \'\'getResourceConfig(":ctf/settings.xml")\'\'.\n:If the file is in the current resource, only the file path is necessary, e.g. \'\'getResourceConfig("settings.xml")\'\'.'}, result="Returns the root node of the specified configuration file. If the file is corrupted, not defined in the meta file or doesn't exist, returns false."), oop=None, url=FunctionUrl(url='/wiki/GetResourceConfig', name='getResourceConfig', category='Resource functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getResourceConfig', return_types=['xmlnode'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to return the root node of a configuration file. Config files must be predefined in a resource's [[Meta.xml|meta file]].  An alternative way to load XML files is to use [[xmlLoadFile]].", arguments={'filePath': 'The filepath of the file in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file.\n:For example, if there is a file named \'settings.xml\' in the resource \'ctf\', it can be accessed from another resource this way: \'\'getResourceConfig(":ctf/settings.xml")\'\'.\n:If the file is in the current resource, only the file path is necessary, e.g. \'\'getResourceConfig("settings.xml")\'\'.'}, result="Returns the root node of the specified configuration file. If the file is corrupted, not defined in the meta file or doesn't exist, returns false."), oop=None, url=FunctionUrl(url='/wiki/GetResourceConfig', name='getResourceConfig', category='Resource functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResourceDynamicElementRoot', return_types=['element'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description="This function retrieves the ''dynamic element root'' of a specified [[resource]]. The ''dynamic element root'' is the parent of elements that are created by scripts (e.g. with [[createObject]]) unless they specify a different parent.", arguments={'theResource': 'the resource of which dynamic element root we want.\n{{OOP||[[resource]]:getDynamicElementRoot}}'}, result="Returns an [[element]] of the resource's dynamic element root if the resource specified was valid and active (currently running), ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetResourceDynamicElementRoot', name='getResourceDynamicElementRoot', category='Resource functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getResourceDynamicElementRoot', return_types=['element'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description="This function retrieves the ''dynamic element root'' of a specified [[resource]]. The ''dynamic element root'' is the parent of elements that are created by scripts (e.g. with [[createObject]]) unless they specify a different parent.", arguments={'theResource': 'the resource of which dynamic element root we want.\n{{OOP||[[resource]]:getDynamicElementRoot}}'}, result="Returns an [[element]] of the resource's dynamic element root if the resource specified was valid and active (currently running), ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetResourceDynamicElementRoot', name='getResourceDynamicElementRoot', category='Resource functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResourceExportedFunctions', return_types=['table'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value='getThisResource(', optional=False)]), docs=FunctionDoc(description='Returns a table containing the names of the functions that a resource exports. It will return the exports of the current resource if there is no argument passed in.', arguments={'theResource': 'the resource of which you want to know the call|exported functions.'}, result="Returns a [[table]] of function names if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetResourceExportedFunctions', name='getResourceExportedFunctions', category='Resource functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getResourceExportedFunctions', return_types=['table'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value='getThisResource(', optional=False)]), docs=FunctionDoc(description='Returns a table containing the names of the functions that a resource exports. It will return the exports of the current resource if there is no argument passed in.', arguments={'theResource': 'the resource of which you want to know the call|exported functions.'}, result="Returns a [[table]] of function names if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetResourceExportedFunctions', name='getResourceExportedFunctions', category='Resource functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResourceFromName', return_types=['resource'], arguments=[FunctionArgument(name='resourceName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to retrieve a resource from its name. A resource's name is the same as its folder or file archive name on the server (without the extension).", arguments={'resourceName': 'the name of the resource you wish to get.'}, result="Returns the [[resource]] with the specified name, or ''false'' if no resource of that name exists. Note that clientside this will also return ''false'' for resources that are in the ''loaded'' state, since the client is unaware of resources that have not been started."), oop=None, url=FunctionUrl(url='/wiki/GetResourceFromName', name='getResourceFromName', category='Resource functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getResourceFromName', return_types=['resource'], arguments=[FunctionArgument(name='resourceName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to retrieve a resource from its name. A resource's name is the same as its folder or file archive name on the server (without the extension).", arguments={'resourceName': 'the name of the resource you wish to get.'}, result="Returns the [[resource]] with the specified name, or ''false'' if no resource of that name exists. Note that clientside this will also return ''false'' for resources that are in the ''loaded'' state, since the client is unaware of resources that have not been started."), oop=None, url=FunctionUrl(url='/wiki/GetResourceFromName', name='getResourceFromName', category='Resource functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getResourceGUIElement', return_types=['element'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value='getThisResource(', optional=False)]), docs=FunctionDoc(description="This function retrieves a resource's GUI element. The resource's GUI element is the element in the element tree which is the default parent of all GUI elements that belong to a particular resource. It has a predefined variable called '''guiRoot''', and each resource has one of these. You can attach event handlers to this element to easily capture events that originate from your resource (and global events that originate from the root element).", arguments={'theResource': 'the resource whose GUI element we are getting. If not specified, assumes the current resource.'}, result='Returns the root GUI element that contains all the other GUI elements.'), oop=None, url=FunctionUrl(url='/wiki/GetResourceGUIElement', name='getResourceGUIElement', category='Resource functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResourceName', return_types=['string'], arguments=[FunctionArgument(name='res', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the name of the specified resource.', arguments={'res': 'The resource you wish to get the name of.'}, result="Returns a string with the resource name in it, or ''false'' if the resource does not exist."), oop=FunctionOOP(class_name='resource', method_name='getName', field="name}}\n\n===Required Arguments=== \n*'''res:''' The resource you wish to get the name of.\n\n===Returns===\nReturns a string with the resource name in it, or ''false'' if the resource does not exist.\n\n"), url=FunctionUrl(url='/wiki/GetResourceName', name='getResourceName', category='Resource functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getResourceName', return_types=['string'], arguments=[FunctionArgument(name='res', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the name of the specified resource.', arguments={'res': 'The resource you wish to get the name of.'}, result="Returns a string with the resource name in it, or ''false'' if the resource does not exist."), oop=FunctionOOP(class_name='resource', method_name='getName', field="name}}\n\n===Required Arguments=== \n*'''res:''' The resource you wish to get the name of.\n\n===Returns===\nReturns a string with the resource name in it, or ''false'' if the resource does not exist.\n\n"), url=FunctionUrl(url='/wiki/GetResourceName', name='getResourceName', category='Resource functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResourceRootElement', return_types=['element'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value='getThisResource(', optional=False)]), docs=FunctionDoc(description="This function retrieves a resource's root element. The resource's root element is the element in the element tree which is the parent of all elements that belong to a particular resource (except for elements specifically created elsewhere). You can attach event handlers to this element to easily capture events that originate from your resource (and global events that originate from the root element).\nNote: every resource has a [[Predefined_variables_list|predefined global variable]] called ''resourceRoot'' whose value is the root element of that resource.", arguments={'theResource': 'the resource whose root element we are getting. If not specified, assumes the current resource. (the resource returned from getThisResource)'}, result="Returns an ''element'' representing the resource's root, ''false'' if the specified resource doesn't exist."), oop=FunctionOOP(class_name='resource', method_name='getRootElement', field="rootElement}}\n===Optional Arguments===\n{{OptionalArg}}\n*'''theResource:''' the resource whose root element we are getting. If not specified, assumes the current resource. (the resource returned from [[getThisResource]])\n\n===Returns===\nReturns an ''element'' representing the resource's root, ''false'' if the specified resource doesn't exist.\n\n"), url=FunctionUrl(url='/wiki/GetResourceRootElement', name='getResourceRootElement', category='Resource functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getResourceRootElement', return_types=['element'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value='getThisResource(', optional=False)]), docs=FunctionDoc(description="This function retrieves a resource's root element. The resource's root element is the element in the element tree which is the parent of all elements that belong to a particular resource (except for elements specifically created elsewhere). You can attach event handlers to this element to easily capture events that originate from your resource (and global events that originate from the root element).\nNote: every resource has a [[Predefined_variables_list|predefined global variable]] called ''resourceRoot'' whose value is the root element of that resource.", arguments={'theResource': 'the resource whose root element we are getting. If not specified, assumes the current resource. (the resource returned from getThisResource)'}, result="Returns an ''element'' representing the resource's root, ''false'' if the specified resource doesn't exist."), oop=FunctionOOP(class_name='resource', method_name='getRootElement', field="rootElement}}\n===Optional Arguments===\n{{OptionalArg}}\n*'''theResource:''' the resource whose root element we are getting. If not specified, assumes the current resource. (the resource returned from [[getThisResource]])\n\n===Returns===\nReturns an ''element'' representing the resource's root, ''false'' if the specified resource doesn't exist.\n\n"), url=FunctionUrl(url='/wiki/GetResourceRootElement', name='getResourceRootElement', category='Resource functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getResourceState', return_types=['string'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function returns the state of a given resource", arguments={'theResource': 'The resource you wish to get the state of.\n{{OOP||[[resource]]:getState|state}}'}, result="If successful returns a string with the resource state in it, ''false'' otherwise.\nThe state can be one of:\n*'''loaded'''\n*'''running'''\n{{New feature|3|1.0|\n*'''starting'''\n*'''stopping'''\n*'''failed to load''' - Use [[getResourceLoadFailureReason]] to find out why it failed.\n}}"), oop=FunctionOOP(class_name='resource', method_name='getState', field="state}}\n===Returns===\nIf successful returns a string with the resource state in it, ''false'' otherwise.\nThe state can be one of:\n*'''loaded'''\n*'''running'''\n{{New feature"), url=FunctionUrl(url='/wiki/GetResourceState', name='getResourceState', category='Resource functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getResourceState', return_types=['string'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value=None, optional=False)]), docs=FunctionDoc(description="<!-- Describe in plain english what this function does. Don't go into details, just give an overview -->\nThis function returns the state of a given resource", arguments={'theResource': 'The resource you wish to get the state of.\n{{OOP||[[resource]]:getState|state}}'}, result="If successful returns a string with the resource state in it, ''false'' otherwise.\nThe state can be one of:\n*'''loaded'''\n*'''running'''\n{{New feature|3|1.0|\n*'''starting'''\n*'''stopping'''\n*'''failed to load''' - Use [[getResourceLoadFailureReason]] to find out why it failed.\n}}"), oop=FunctionOOP(class_name='resource', method_name='getState', field="state}}\n===Returns===\nIf successful returns a string with the resource state in it, ''false'' otherwise.\nThe state can be one of:\n*'''loaded'''\n*'''running'''\n{{New feature"), url=FunctionUrl(url='/wiki/GetResourceState', name='getResourceState', category='Resource functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getThisResource', return_types=['resource'], arguments=[]), docs=FunctionDoc(description='This function retrieves the resource from which the function call was made.', arguments={}, result='Returns the resource in which the current script is.'), oop=None, url=FunctionUrl(url='/wiki/GetThisResource', name='getThisResource', category='Resource functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getThisResource', return_types=['resource'], arguments=[]), docs=FunctionDoc(description='This function retrieves the resource from which the function call was made.', arguments={}, result='Returns the resource in which the current script is.'), oop=None, url=FunctionUrl(url='/wiki/GetThisResource', name='getThisResource', category='Resource functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getRemoteRequests', return_types=['table'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value='nil', optional=False)]), docs=FunctionDoc(description='Gets all [[FetchRemote|fetchRemote]] and [[CallRemote|callRemote]] requests currently running.\n}}', arguments={'theResource': ': the resource to get all requests from'}, result='Returns a table with all requests, false if an invalid resource was provided'), oop=None, url=FunctionUrl(url='/wiki/GetRemoteRequests', name='getRemoteRequests', category='Resource functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getRemoteRequests', return_types=['table'], arguments=[FunctionArgument(name='theResource', argument_type='resource', default_value='nil', optional=False)]), docs=FunctionDoc(description='Gets all [[FetchRemote|fetchRemote]] and [[CallRemote|callRemote]] requests currently running.\n}}', arguments={'theResource': ': the resource to get all requests from'}, result='Returns a table with all requests, false if an invalid resource was provided'), oop=None, url=FunctionUrl(url='/wiki/GetRemoteRequests', name='getRemoteRequests', category='Resource functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getRemoteRequestInfo', return_types=['table'], arguments=[FunctionArgument(name='theRequest', argument_type='request', default_value=None, optional=False), FunctionArgument(name='postDataLength', argument_type='int', default_value='0 [', optional=True), FunctionArgument(name='includeHeaders', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='Gets informations of an [[FetchRemote|fetchRemote]] or [[CallRemote|callRemote]] request info.\n}}', arguments={'theRequest': ': returned from FetchRemote|fetchRemote, CallRemote|callRemote or GetRemoteRequests|getRemoteRequests'}, result='Returns a table when valid, false otherwise\nThe table contains:\n*\'\'\'bytesReceived:\'\'\' A number specifying the amount of data received so far. Zero means the download is queued\n*\'\'\'bytesTotal:\'\'\' A number specifying the final download size. Will be zero if the remote HTTP server has not set the \'Content-Length\' header\n*\'\'\'currentAttempt:\'\'\' A number specifying the current connection attempt\n*\'\'\'type:\'\'\' A string specifying either "fetch" or "call"\n*\'\'\'url:\'\'\' A string specifying the URL\n*\'\'\'resource:\'\'\' The resource which started the request, or false if the resource has since been stopped/restarted\n*\'\'\'queue:\'\'\' A string specifying the queue name\n*\'\'\'method:\'\'\' A string specifying the HTTP method. e.g. "GET" or "POST"\n*\'\'\'connectionAttempts:\'\'\' A number specifying max number connection attempts as declared in the fetchRemote call\n*\'\'\'connectionTimeout:\'\'\' A number specifying connection attempt timeout as declared in the fetchRemote call\n*\'\'\'postData:\'\'\' A string containing the request post data as declared in the fetchRemote call\n*\'\'\'headers:\'\'\' A table containing the request HTTP headers as declared in the fetchRemote call'), oop=None, url=FunctionUrl(url='/wiki/GetRemoteRequestInfo', name='getRemoteRequestInfo', category='Resource functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getRemoteRequestInfo', return_types=['table'], arguments=[FunctionArgument(name='theRequest', argument_type='request', default_value=None, optional=False), FunctionArgument(name='postDataLength', argument_type='int', default_value='0 [', optional=True), FunctionArgument(name='includeHeaders', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='Gets informations of an [[FetchRemote|fetchRemote]] or [[CallRemote|callRemote]] request info.\n}}', arguments={'theRequest': ': returned from FetchRemote|fetchRemote, CallRemote|callRemote or GetRemoteRequests|getRemoteRequests'}, result='Returns a table when valid, false otherwise\nThe table contains:\n*\'\'\'bytesReceived:\'\'\' A number specifying the amount of data received so far. Zero means the download is queued\n*\'\'\'bytesTotal:\'\'\' A number specifying the final download size. Will be zero if the remote HTTP server has not set the \'Content-Length\' header\n*\'\'\'currentAttempt:\'\'\' A number specifying the current connection attempt\n*\'\'\'type:\'\'\' A string specifying either "fetch" or "call"\n*\'\'\'url:\'\'\' A string specifying the URL\n*\'\'\'resource:\'\'\' The resource which started the request, or false if the resource has since been stopped/restarted\n*\'\'\'queue:\'\'\' A string specifying the queue name\n*\'\'\'method:\'\'\' A string specifying the HTTP method. e.g. "GET" or "POST"\n*\'\'\'connectionAttempts:\'\'\' A number specifying max number connection attempts as declared in the fetchRemote call\n*\'\'\'connectionTimeout:\'\'\' A number specifying connection attempt timeout as declared in the fetchRemote call\n*\'\'\'postData:\'\'\' A string containing the request post data as declared in the fetchRemote call\n*\'\'\'headers:\'\'\' A table containing the request HTTP headers as declared in the fetchRemote call'), oop=None, url=FunctionUrl(url='/wiki/GetRemoteRequestInfo', name='getRemoteRequestInfo', category='Resource functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='abortRemoteRequest', return_types=['bool'], arguments=[FunctionArgument(name='theRequest', argument_type='request', default_value=None, optional=False)]), docs=FunctionDoc(description='Aborts a [[FetchRemote|fetchRemote]] or [[CallRemote|callRemote]] request.\n}}', arguments={'theRequest': ': returned from FetchRemote|fetchRemote, CallRemote|callRemote or GetRemoteRequests|getRemoteRequests'}, result='Returns true on success, false when invalid request was provided'), oop=None, url=FunctionUrl(url='/wiki/AbortRemoteRequest', name='abortRemoteRequest', category='Resource functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='abortRemoteRequest', return_types=['bool'], arguments=[FunctionArgument(name='theRequest', argument_type='request', default_value=None, optional=False)]), docs=FunctionDoc(description='Aborts a [[FetchRemote|fetchRemote]] or [[CallRemote|callRemote]] request.\n}}', arguments={'theRequest': ': returned from FetchRemote|fetchRemote, CallRemote|callRemote or GetRemoteRequests|getRemoteRequests'}, result='Returns true on success, false when invalid request was provided'), oop=None, url=FunctionUrl(url='/wiki/AbortRemoteRequest', name='abortRemoteRequest', category='Resource functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='createSearchLight', return_types=['searchlight'], arguments=[FunctionArgument(name='startX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startRadius', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endRadius', argument_type='float', default_value=None, optional=False), FunctionArgument(name='renderSpot', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description='', arguments={'startX': ': the X coordinate where the searchlight light cone will start.', 'startY': ': the Y coordinate where the searchlight light cone will start.', 'startZ': ': the Z coordinate where the searchlight light cone will start.', 'endX': ': the X coordinate of the direction where the searchlight will point to.', 'endY': ': the Y coordinate of the direction where the searchlight will point to.', 'endZ': ': the Z coordinate of the direction where the searchlight will point to.', 'startRadius': ': the radius of the searchlights light cone in its beginning.', 'endRadius': ': the radius of the searchlights light cone in its end.\n{{OptionalArg}}', 'renderSpot': ': if true, the searchlight will lighten the surface where it ends.'}, result="If every argument is correct and the limit of 1000 searchlights has not been reached, this function returns a [[Element/Searchlight|searchlight element]]. Otherwise, it returns ''false''."), oop=None, url=FunctionUrl(url='/wiki/CreateSearchLight', name='createSearchLight', category='Searchlight functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSearchLightEndPosition', return_types=['float', 'float', 'float'], arguments=[FunctionArgument(name='theSearchLight', argument_type='searchlight', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the end position of a [[Element/Searchlight|searchlight]] element.', arguments={'theSearchLight': ': the searchlight to get the position where the searchlights light cone ends.'}, result="If the specified searchlight element is valid, this function will return three ''float'', which are the three coordinates of searchlight's end position. If not, it will return ''false'' plus an error message."), oop=FunctionOOP(class_name='searchLight', method_name='getEndPosition', field='endPosition'), url=FunctionUrl(url='/wiki/GetSearchLightEndPosition', name='getSearchLightEndPosition', category='Searchlight functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSearchLightEndRadius', return_types=['float'], arguments=[FunctionArgument(name='theSearchLight', argument_type='searchlight', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the end radius of a [[Element/Searchlight|searchlight]] element.', arguments={'theSearchLight': ': the searchlight to get the radius of the searchlights light cone in its end.'}, result="If the specified searchlight element is valid, this function will return one ''float'', which is the searchlight's end radius. If not, it will return ''false'' plus an error message."), oop=FunctionOOP(class_name='searchLight', method_name='getEndRadius', field='endRadius'), url=FunctionUrl(url='/wiki/GetSearchLightEndRadius', name='getSearchLightEndRadius', category='Searchlight functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSearchLightStartPosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theSearchLight', argument_type='searchlight', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the start position of a [[Element/Searchlight|searchlight]] element.', arguments={'theSearchLight': ': the searchlight to get the position where the searchlights light cone starts.'}, result="If the specified searchlight element is valid, this function will return three ''float'', which are the three coordinates of searchlight's start position. If not, it will return ''false'' plus an error message."), oop=FunctionOOP(class_name='searchLight', method_name='getStartPosition', field='startPosition'), url=FunctionUrl(url='/wiki/GetSearchLightStartPosition', name='getSearchLightStartPosition', category='Searchlight functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getSearchLightStartRadius', return_types=['float'], arguments=[FunctionArgument(name='theSearchLight', argument_type='searchlight', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the start radius of a [[Element/Searchlight|searchlight]] element.', arguments={'theSearchLight': ': the searchlight to get the radius of the searchlights light cone in its beginning.'}, result="If the specified searchlight element is valid, this function will return one ''float'', which is the searchlight's start radius. If not, it will return ''false'' plus an error message."), oop=FunctionOOP(class_name='searchLight', method_name='getStartRadius', field='startRadius'), url=FunctionUrl(url='/wiki/GetSearchLightStartRadius', name='getSearchLightStartRadius', category='Searchlight functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSearchLightEndPosition', return_types=['bool'], arguments=[FunctionArgument(name='theSearchLight', argument_type='searchlight', default_value=None, optional=False), FunctionArgument(name='endX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theSearchLight': ': the searchlight to modify the property of.', 'endX': ': the X coordinate where the searchlight light cone will end.', 'endY': ': the Y coordinate where the searchlight light cone will end.', 'endZ': ': the Z coordinate where the searchlight light cone will end.'}, result="If every argument is correct, this function returns ''true''. If not, it will return ''false'' plus an error message."), oop=FunctionOOP(class_name='searchLight', method_name='setEndPosition', field='endPosition'), url=FunctionUrl(url='/wiki/SetSearchLightEndPosition', name='setSearchLightEndPosition', category='Searchlight functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSearchLightEndRadius', return_types=['bool'], arguments=[FunctionArgument(name='theSearchlight', argument_type='searchlight', default_value=None, optional=False), FunctionArgument(name='endRadius', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the end radius of a [[Element/Searchlight|searchlight]] element.', arguments={'theSearchLight': ': the searchlight to modify the property of.', 'endRadius': ': the radius of the searchlights light cone in its end.'}, result="If every argument is correct, this function returns ''true''. If not, it will return ''false'' plus an error message."), oop=FunctionOOP(class_name='searchLight', method_name='setEndRadius', field='endRadius'), url=FunctionUrl(url='/wiki/SetSearchLightEndRadius', name='setSearchLightEndRadius', category='Searchlight functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSearchLightStartPosition', return_types=['bool'], arguments=[FunctionArgument(name='theSearchLight', argument_type='searchlight', default_value=None, optional=False), FunctionArgument(name='startX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the start position of a [[Element/Searchlight|searchlight]] element.', arguments={'theSearchLight': ': the searchlight to modify the property of.', 'startX': ': the X coordinate where the searchlight light cone will start.', 'startY': ': the Y coordinate where the searchlight light cone will start.', 'startZ': ': the Z coordinate where the searchlight light cone will start.'}, result="If every argument is correct, this function returns ''true''. If not, it will return ''false'' plus an error message."), oop=FunctionOOP(class_name='searchLight', method_name='setStartPosition', field='startPosition'), url=FunctionUrl(url='/wiki/SetSearchLightStartPosition', name='setSearchLightStartPosition', category='Searchlight functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setSearchLightStartRadius', return_types=['bool'], arguments=[FunctionArgument(name='theSearchlight', argument_type='searchlight', default_value=None, optional=False), FunctionArgument(name='startRadius', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the start radius of a [[Element/Searchlight|searchlight]] element.', arguments={'theSearchLight': ': the searchlight to modify the property of.', 'startRadius': ': the radius of the searchlights light cone in its beginning.'}, result="If every argument is correct, this function returns ''true''. If not, it will return ''false'' plus an error message."), oop=FunctionOOP(class_name='searchLight', method_name='setStartRadius', field='startRadius'), url=FunctionUrl(url='/wiki/SetSearchLightStartRadius', name='setSearchLightStartRadius', category='Searchlight functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='countPlayersInTeam', return_types=['int'], arguments=[FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is for returning the number of players in the specified team.', arguments={'theTeam': 'The team you wish to retrieve the player count of.'}, result="Returns an integer containing the number of players in the team, ''false'' if it could not be retrieved."), oop=FunctionOOP(class_name='team', method_name='countPlayers', field='playerCount'), url=FunctionUrl(url='/wiki/CountPlayersInTeam', name='countPlayersInTeam', category='Team functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='countPlayersInTeam', return_types=['int'], arguments=[FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is for returning the number of players in the specified team.', arguments={'theTeam': 'The team you wish to retrieve the player count of.'}, result="Returns an integer containing the number of players in the team, ''false'' if it could not be retrieved."), oop=FunctionOOP(class_name='team', method_name='countPlayers', field='playerCount'), url=FunctionUrl(url='/wiki/CountPlayersInTeam', name='countPlayersInTeam', category='Team functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerTeam', return_types=['team'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the current [[team]] a [[player]] is on.', arguments={'thePlayer': ': The player whose team you want to find out.'}, result="Returns a ''team'' element representing the team the player is on, ''false'' if the player is not part of a team."), oop=FunctionOOP(class_name='player', method_name='getTeam', field='team'), url=FunctionUrl(url='/wiki/GetPlayerTeam', name='getPlayerTeam', category='Team functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPlayerTeam', return_types=['team'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the current [[team]] a [[player]] is on.', arguments={'thePlayer': ': The player whose team you want to find out.'}, result="Returns a ''team'' element representing the team the player is on, ''false'' if the player is not part of a team."), oop=FunctionOOP(class_name='player', method_name='getTeam', field='team'), url=FunctionUrl(url='/wiki/GetPlayerTeam', name='getPlayerTeam', category='Team functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayersInTeam', return_types=['table'], arguments=[FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves all the players of the specified team.', arguments={'theTeam': 'The team you wish to retrieve all the players from.'}, result='Returns a [[table]] of all the players in the team, or an empty one if there are none else false if invalid arguments are passed.'), oop=FunctionOOP(class_name='team', method_name='getPlayers', field='players'), url=FunctionUrl(url='/wiki/GetPlayersInTeam', name='getPlayersInTeam', category='Team functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPlayersInTeam', return_types=['table'], arguments=[FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves all the players of the specified team.', arguments={'theTeam': 'The team you wish to retrieve all the players from.'}, result='Returns a [[table]] of all the players in the team, or an empty one if there are none else false if invalid arguments are passed.'), oop=FunctionOOP(class_name='team', method_name='getPlayers', field='players'), url=FunctionUrl(url='/wiki/GetPlayersInTeam', name='getPlayersInTeam', category='Team functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getTeamColor', return_types=['int,', 'int,', 'int'], arguments=[FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the color of a team.', arguments={'theTeam': 'The team you want to get the color of.'}, result="Returns 3 integers representing the red, green, and blue color components of the team if it's valid, ''false'' otherwise."), oop=FunctionOOP(class_name='team', method_name='getColor', field=None), url=FunctionUrl(url='/wiki/GetTeamColor', name='getTeamColor', category='Team functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getTeamColor', return_types=['int,', 'int,', 'int'], arguments=[FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the color of a team.', arguments={'theTeam': 'The team you want to get the color of.'}, result="Returns 3 integers representing the red, green, and blue color components of the team if it's valid, ''false'' otherwise."), oop=FunctionOOP(class_name='team', method_name='getColor', field=None), url=FunctionUrl(url='/wiki/GetTeamColor', name='getTeamColor', category='Team functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getTeamFriendlyFire', return_types=['bool'], arguments=[FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False)]), docs=FunctionDoc(description='This function tells you if friendly fire is turned on for the specified team.', arguments={'theTeam': 'The team object that will be checked'}, result="Returns ''true'' if friendly fire is on for the specified team, ''false'' if it is turned off or if invalid arguments are specified."), oop=FunctionOOP(class_name='team', method_name='getFriendlyFire', field='friendlyFire'), url=FunctionUrl(url='/wiki/GetTeamFriendlyFire', name='getTeamFriendlyFire', category='Team functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getTeamFriendlyFire', return_types=['bool'], arguments=[FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False)]), docs=FunctionDoc(description='This function tells you if friendly fire is turned on for the specified team.', arguments={'theTeam': 'The team object that will be checked'}, result="Returns ''true'' if friendly fire is on for the specified team, ''false'' if it is turned off or if invalid arguments are specified."), oop=FunctionOOP(class_name='team', method_name='getFriendlyFire', field='friendlyFire'), url=FunctionUrl(url='/wiki/GetTeamFriendlyFire', name='getTeamFriendlyFire', category='Team functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getTeamFromName', return_types=['team'], arguments=[FunctionArgument(name='teamName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function finds a [[team]] element using the provided team name.', arguments={'teamName': 'A string determining the name of the team you wish to find.'}, result="Returns the [[team]] element if it was found, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetTeamFromName', name='getTeamFromName', category='Team functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getTeamFromName', return_types=['team'], arguments=[FunctionArgument(name='teamName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function finds a [[team]] element using the provided team name.', arguments={'teamName': 'A string determining the name of the team you wish to find.'}, result="Returns the [[team]] element if it was found, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetTeamFromName', name='getTeamFromName', category='Team functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getTeamName', return_types=['string'], arguments=[FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the team name of a team object.', arguments={'theTeam': 'The team you want to retrieve the name of.'}, result="Returns a string representing the team's name if the team object was valid, ''false'' otherwise."), oop=FunctionOOP(class_name='team', method_name='getName', field='name'), url=FunctionUrl(url='/wiki/GetTeamName', name='getTeamName', category='Team functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getTeamName', return_types=['string'], arguments=[FunctionArgument(name='theTeam', argument_type='team', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the team name of a team object.', arguments={'theTeam': 'The team you want to retrieve the name of.'}, result="Returns a string representing the team's name if the team object was valid, ''false'' otherwise."), oop=FunctionOOP(class_name='team', method_name='getName', field='name'), url=FunctionUrl(url='/wiki/GetTeamName', name='getTeamName', category='Team functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='addDebugHook', return_types=['bool'], arguments=[FunctionArgument(name='hookType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='callbackFunction', argument_type='function', default_value=None, optional=False), FunctionArgument(name='nameList', argument_type='table', default_value=None, optional=True)]), docs=FunctionDoc(description='This function allows tracing of MTA functions and events. It should only be used when debugging scripts as it may degrade script performance.\nDebug hooks are not recursive, so functions and events triggered inside the hook callback will not be traced.\n}}', arguments={'hookType': 'The type of hook to add. This can be:\n** preEvent\n** postEvent\n** preFunction\n** postFunction\n{{New feature/item|3.0158|1.5.5|11856|\n* preEventFunction\n* postEventFunction\n}}', 'callbackFunction': 'The function to call\n** Returning the string "skip" from the callback function will cause the original function/event to be skipped', 'nameList': 'Table of strings for restricting which functions and events the hook will be triggered on\n** addDebugHook and removeDebugHook will only be hooked if they are specified in the name list'}, result="Returns ''true'' if the hook was successfully added, or ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/AddDebugHook', name='addDebugHook', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='addDebugHook', return_types=['bool'], arguments=[FunctionArgument(name='hookType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='callbackFunction', argument_type='function', default_value=None, optional=False), FunctionArgument(name='nameList', argument_type='table', default_value=None, optional=True)]), docs=FunctionDoc(description='This function allows tracing of MTA functions and events. It should only be used when debugging scripts as it may degrade script performance.\nDebug hooks are not recursive, so functions and events triggered inside the hook callback will not be traced.\n}}', arguments={'hookType': 'The type of hook to add. This can be:\n** preEvent\n** postEvent\n** preFunction\n** postFunction\n{{New feature/item|3.0158|1.5.5|11856|\n* preEventFunction\n* postEventFunction\n}}', 'callbackFunction': 'The function to call\n** Returning the string "skip" from the callback function will cause the original function/event to be skipped', 'nameList': 'Table of strings for restricting which functions and events the hook will be triggered on\n** addDebugHook and removeDebugHook will only be hooked if they are specified in the name list'}, result="Returns ''true'' if the hook was successfully added, or ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/AddDebugHook', name='addDebugHook', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='base64Decode', return_types=['string'], arguments=[FunctionArgument(name='data', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the decrypted data from [https://en.wikipedia.org/wiki/Base64 base64] representation of the encrypted block', arguments={'data': 'The block of data you want to decrypt'}, result="Returns the decrypted data from [https://en.wikipedia.org/wiki/Base64 base64] representation of the encrypted block if the decryption process was successfully completed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Base64Decode', name='base64Decode', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='base64Decode', return_types=['string'], arguments=[FunctionArgument(name='data', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the decrypted data from [https://en.wikipedia.org/wiki/Base64 base64] representation of the encrypted block', arguments={'data': 'The block of data you want to decrypt'}, result="Returns the decrypted data from [https://en.wikipedia.org/wiki/Base64 base64] representation of the encrypted block if the decryption process was successfully completed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Base64Decode', name='base64Decode', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='base64Encode', return_types=['string'], arguments=[FunctionArgument(name='data', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the [https://en.wikipedia.org/wiki/Base64 base64] representation of the encoded block of data', arguments={'data': 'The block of data you want to encode'}, result="Returns the [https://en.wikipedia.org/wiki/Base64 base64] representation of the encoded data if the encoding process was successfully completed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Base64Encode', name='base64Encode', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='base64Encode', return_types=['string'], arguments=[FunctionArgument(name='data', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the [https://en.wikipedia.org/wiki/Base64 base64] representation of the encoded block of data', arguments={'data': 'The block of data you want to encode'}, result="Returns the [https://en.wikipedia.org/wiki/Base64 base64] representation of the encoded data if the encoding process was successfully completed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Base64Encode', name='base64Encode', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='bitAnd', return_types=['uint'], arguments=[FunctionArgument(name='var1', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='var2', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function performs a bitwise AND-conjunction on two or more (unsigned) 32-bit [[Int|integers]]. See [http://en.wikipedia.org/wiki/Bitwise_operation#AND Bitwise operation] for more details.\n}}', arguments={'varN': 'The value you want to perform an AND-conjunction on'}, result='Returns the conjuncted value.'), oop=None, url=FunctionUrl(url='/wiki/BitAnd', name='bitAnd', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='bitAnd', return_types=['uint'], arguments=[FunctionArgument(name='var1', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='var2', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function performs a bitwise AND-conjunction on two or more (unsigned) 32-bit [[Int|integers]]. See [http://en.wikipedia.org/wiki/Bitwise_operation#AND Bitwise operation] for more details.\n}}', arguments={'varN': 'The value you want to perform an AND-conjunction on'}, result='Returns the conjuncted value.'), oop=None, url=FunctionUrl(url='/wiki/BitAnd', name='bitAnd', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='bitNot', return_types=['uint'], arguments=[FunctionArgument(name='var', argument_type='uint', default_value=None, optional=False)]), docs=FunctionDoc(description='This function performs a bitwise NOT on an (unsigned) 32-bit [[Int|integer]]. See [http://en.wikipedia.org/wiki/Bitwise_operation#NOT Bitwise operation] for more details.\n}}', arguments={'var': 'The value you want to perform a bitwise NOT on'}, result='Returns the value on which the operation has been performed.'), oop=None, url=FunctionUrl(url='/wiki/BitNot', name='bitNot', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='bitNot', return_types=['uint'], arguments=[FunctionArgument(name='var', argument_type='uint', default_value=None, optional=False)]), docs=FunctionDoc(description='This function performs a bitwise NOT on an (unsigned) 32-bit [[Int|integer]]. See [http://en.wikipedia.org/wiki/Bitwise_operation#NOT Bitwise operation] for more details.\n}}', arguments={'var': 'The value you want to perform a bitwise NOT on'}, result='Returns the value on which the operation has been performed.'), oop=None, url=FunctionUrl(url='/wiki/BitNot', name='bitNot', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='bitOr', return_types=['uint'], arguments=[FunctionArgument(name='var1', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='var2', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function performs a bitwise OR-conjunction on two or more (unsigned) 32-bit [[Int|integers]]. See [http://en.wikipedia.org/wiki/Bitwise_operation#OR Bitwise operation] for more details.\n}}', arguments={'varN': 'The value you want to perform an OR-conjunction on'}, result='Returns the conjuncted value.'), oop=None, url=FunctionUrl(url='/wiki/BitOr', name='bitOr', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='bitOr', return_types=['uint'], arguments=[FunctionArgument(name='var1', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='var2', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function performs a bitwise OR-conjunction on two or more (unsigned) 32-bit [[Int|integers]]. See [http://en.wikipedia.org/wiki/Bitwise_operation#OR Bitwise operation] for more details.\n}}', arguments={'varN': 'The value you want to perform an OR-conjunction on'}, result='Returns the conjuncted value.'), oop=None, url=FunctionUrl(url='/wiki/BitOr', name='bitOr', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='bitXor', return_types=['uint'], arguments=[FunctionArgument(name='var1', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='var2', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function performs a bitwise XOR-conjunction (exclusive OR) on two or more (unsigned) 32-bit [[Int|integers]]. See [http://en.wikipedia.org/wiki/Bitwise_operation#XOR Bitwise operation] for more details.\n}}', arguments={'varN': 'The value you want to perform a XOR-conjunction on'}, result='Returns the conjuncted value.'), oop=None, url=FunctionUrl(url='/wiki/BitXor', name='bitXor', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='bitXor', return_types=['uint'], arguments=[FunctionArgument(name='var1', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='var2', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function performs a bitwise XOR-conjunction (exclusive OR) on two or more (unsigned) 32-bit [[Int|integers]]. See [http://en.wikipedia.org/wiki/Bitwise_operation#XOR Bitwise operation] for more details.\n}}', arguments={'varN': 'The value you want to perform a XOR-conjunction on'}, result='Returns the conjuncted value.'), oop=None, url=FunctionUrl(url='/wiki/BitXor', name='bitXor', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='bitTest', return_types=['bool'], arguments=[FunctionArgument(name='var1', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='var2', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function performs an AND-conjunction on two or more (unsigned) 32-bit [[Int|integers]] and checks, whether the conjuncted value is zero or not. See [http://en.wikipedia.org/wiki/Bitwise_operation#AND Bitwise operation] for more details.\n}}', arguments={'varN': 'The value you want to perform the operation on (see above)'}, result="Returns ''true'' if the conjuncted value is '''not''' zero, ''false'' otherwise. If a bad argument was passed to [[bitTest]], you'll get ''nil''."), oop=None, url=FunctionUrl(url='/wiki/BitTest', name='bitTest', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='bitTest', return_types=['bool'], arguments=[FunctionArgument(name='var1', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='var2', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='This function performs an AND-conjunction on two or more (unsigned) 32-bit [[Int|integers]] and checks, whether the conjuncted value is zero or not. See [http://en.wikipedia.org/wiki/Bitwise_operation#AND Bitwise operation] for more details.\n}}', arguments={'varN': 'The value you want to perform the operation on (see above)'}, result="Returns ''true'' if the conjuncted value is '''not''' zero, ''false'' otherwise. If a bad argument was passed to [[bitTest]], you'll get ''nil''."), oop=None, url=FunctionUrl(url='/wiki/BitTest', name='bitTest', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='bitLRotate', return_types=['int'], arguments=[FunctionArgument(name='value', argument_type='int', default_value=None, optional=False), FunctionArgument(name='n', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This functions performs a bitwise circular left-rotation on the integer '''value''' by integer '''n''' positions.\nSee [https://en.wikipedia.org/wiki/Bitwise_operation#Rotate_no_carry Bitwise operation] for more details.", arguments={'value': 'The value you want to perform the rotation on.', 'n': 'The amount of positions to rotate the value by.'}, result="Returns the circular left-rotated value as ''integer''."), oop=None, url=FunctionUrl(url='/wiki/BitLRotate', name='bitLRotate', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='bitLRotate', return_types=['int'], arguments=[FunctionArgument(name='value', argument_type='int', default_value=None, optional=False), FunctionArgument(name='n', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This functions performs a bitwise circular left-rotation on the integer '''value''' by integer '''n''' positions.\nSee [https://en.wikipedia.org/wiki/Bitwise_operation#Rotate_no_carry Bitwise operation] for more details.", arguments={'value': 'The value you want to perform the rotation on.', 'n': 'The amount of positions to rotate the value by.'}, result="Returns the circular left-rotated value as ''integer''."), oop=None, url=FunctionUrl(url='/wiki/BitLRotate', name='bitLRotate', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='bitRRotate', return_types=['int'], arguments=[FunctionArgument(name='value', argument_type='int', default_value=None, optional=False), FunctionArgument(name='n', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This functions performs a bitwise circular right-rotation on the integer '''value''' by integer '''n''' positions.\nSee [https://en.wikipedia.org/wiki/Bitwise_operation#Rotate_no_carry Bitwise operation] for more details.", arguments={'value': 'The value you want to perform the rotation on.', 'n': 'The amount of positions to rotate the value by.'}, result="Returns the circular right-rotated value as ''integer''."), oop=None, url=FunctionUrl(url='/wiki/BitRRotate', name='bitRRotate', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='bitRRotate', return_types=['int'], arguments=[FunctionArgument(name='value', argument_type='int', default_value=None, optional=False), FunctionArgument(name='n', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This functions performs a bitwise circular right-rotation on the integer '''value''' by integer '''n''' positions.\nSee [https://en.wikipedia.org/wiki/Bitwise_operation#Rotate_no_carry Bitwise operation] for more details.", arguments={'value': 'The value you want to perform the rotation on.', 'n': 'The amount of positions to rotate the value by.'}, result="Returns the circular right-rotated value as ''integer''."), oop=None, url=FunctionUrl(url='/wiki/BitRRotate', name='bitRRotate', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='bitLShift', return_types=['int'], arguments=[FunctionArgument(name='value', argument_type='int', default_value=None, optional=False), FunctionArgument(name='n', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This functions performs a logical left shift on the integer '''value''' by integer '''n''' positions. In a ''logical shift'', zeros are shifted in to replace the discarded bits.\nSee [https://en.wikipedia.org/wiki/Bitwise_operation#Logical_shift Bitwise operation] for more details.", arguments={'value': 'The value you want to perform the shift on.', 'n': 'The amount of positions to shift the value by.'}, result="Returns the logical left shifted value as ''integer''."), oop=None, url=FunctionUrl(url='/wiki/BitLShift', name='bitLShift', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='bitLShift', return_types=['int'], arguments=[FunctionArgument(name='value', argument_type='int', default_value=None, optional=False), FunctionArgument(name='n', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This functions performs a logical left shift on the integer '''value''' by integer '''n''' positions. In a ''logical shift'', zeros are shifted in to replace the discarded bits.\nSee [https://en.wikipedia.org/wiki/Bitwise_operation#Logical_shift Bitwise operation] for more details.", arguments={'value': 'The value you want to perform the shift on.', 'n': 'The amount of positions to shift the value by.'}, result="Returns the logical left shifted value as ''integer''."), oop=None, url=FunctionUrl(url='/wiki/BitLShift', name='bitLShift', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='bitRShift', return_types=['int'], arguments=[FunctionArgument(name='value', argument_type='int', default_value=None, optional=False), FunctionArgument(name='n', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This functions performs a logical right shift on the integer '''value''' by integer '''n''' positions. In a ''logical shift'', zeros are shifted in to replace the discarded bits.\nSee [https://en.wikipedia.org/wiki/Bitwise_operation#Logical_shift Bitwise operation] for more details.", arguments={'value': 'The value you want to perform the shift on.', 'n': 'The amount of positions to shift the value by.'}, result="Returns the logical right shifted value as ''integer''."), oop=None, url=FunctionUrl(url='/wiki/BitRShift', name='bitRShift', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='bitRShift', return_types=['int'], arguments=[FunctionArgument(name='value', argument_type='int', default_value=None, optional=False), FunctionArgument(name='n', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This functions performs a logical right shift on the integer '''value''' by integer '''n''' positions. In a ''logical shift'', zeros are shifted in to replace the discarded bits.\nSee [https://en.wikipedia.org/wiki/Bitwise_operation#Logical_shift Bitwise operation] for more details.", arguments={'value': 'The value you want to perform the shift on.', 'n': 'The amount of positions to shift the value by.'}, result="Returns the logical right shifted value as ''integer''."), oop=None, url=FunctionUrl(url='/wiki/BitRShift', name='bitRShift', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='bitArShift', return_types=['int'], arguments=[FunctionArgument(name='value', argument_type='int', default_value=None, optional=False), FunctionArgument(name='n', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This functions performs an arithmetic shift on the integer '''value''' by integer '''n''' positions. In an ''arithmetic shift'', zeros are shifted in to replace the discarded bits. In a ''right arithmetic'' shift, the [https://en.wikipedia.org/wiki/Sign_bit sign bit] is shifted in on the left, thus preserving the sign of the operand.\nSee [https://en.wikipedia.org/wiki/Bitwise_operation#Arithmetic_shift Bitwise operation] for more details.", arguments={'value': 'The value you want to perform the arithmetic shift on.', 'n': 'The amount of positions to shift the value by.'}, result="Returns the arithmetic shifted value as ''integer''."), oop=None, url=FunctionUrl(url='/wiki/BitArShift', name='bitArShift', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='bitArShift', return_types=['int'], arguments=[FunctionArgument(name='value', argument_type='int', default_value=None, optional=False), FunctionArgument(name='n', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This functions performs an arithmetic shift on the integer '''value''' by integer '''n''' positions. In an ''arithmetic shift'', zeros are shifted in to replace the discarded bits. In a ''right arithmetic'' shift, the [https://en.wikipedia.org/wiki/Sign_bit sign bit] is shifted in on the left, thus preserving the sign of the operand.\nSee [https://en.wikipedia.org/wiki/Bitwise_operation#Arithmetic_shift Bitwise operation] for more details.", arguments={'value': 'The value you want to perform the arithmetic shift on.', 'n': 'The amount of positions to shift the value by.'}, result="Returns the arithmetic shifted value as ''integer''."), oop=None, url=FunctionUrl(url='/wiki/BitArShift', name='bitArShift', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='bitExtract', return_types=['uint'], arguments=[FunctionArgument(name='var', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='field', argument_type='int', default_value=None, optional=False), FunctionArgument(name='width', argument_type='int', default_value='1', optional=True)]), docs=FunctionDoc(description='This function returns the unsigned number formed by the bits field to field + width - 1 (range: 0-31).\n}}', arguments={'var': 'The value', 'field': 'The field number', 'width': 'Number of bits to extract'}, result='Returns the extracted value/bit sequence.'), oop=None, url=FunctionUrl(url='/wiki/BitExtract', name='bitExtract', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='bitExtract', return_types=['uint'], arguments=[FunctionArgument(name='var', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='field', argument_type='int', default_value=None, optional=False), FunctionArgument(name='width', argument_type='int', default_value='1', optional=True)]), docs=FunctionDoc(description='This function returns the unsigned number formed by the bits field to field + width - 1 (range: 0-31).\n}}', arguments={'var': 'The value', 'field': 'The field number', 'width': 'Number of bits to extract'}, result='Returns the extracted value/bit sequence.'), oop=None, url=FunctionUrl(url='/wiki/BitExtract', name='bitExtract', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='bitReplace', return_types=['uint'], arguments=[FunctionArgument(name='var', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='replaceValue', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='field', argument_type='int', default_value=None, optional=False), FunctionArgument(name='width', argument_type='int', default_value='1', optional=False)]), docs=FunctionDoc(description='This function returns the unsigned number formed by var value with replacement specified at bits field to field + width - 1\n}}', arguments={'var': 'The value', 'replaceValue': 'The replaceValue', 'field': 'The field number', 'width': 'Number of bits to extract'}, result='Returns the replaced value/bit sequence.'), oop=None, url=FunctionUrl(url='/wiki/BitReplace', name='bitReplace', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='bitReplace', return_types=['uint'], arguments=[FunctionArgument(name='var', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='replaceValue', argument_type='uint', default_value=None, optional=False), FunctionArgument(name='field', argument_type='int', default_value=None, optional=False), FunctionArgument(name='width', argument_type='int', default_value='1', optional=False)]), docs=FunctionDoc(description='This function returns the unsigned number formed by var value with replacement specified at bits field to field + width - 1\n}}', arguments={'var': 'The value', 'replaceValue': 'The replaceValue', 'field': 'The field number', 'width': 'Number of bits to extract'}, result='Returns the replaced value/bit sequence.'), oop=None, url=FunctionUrl(url='/wiki/BitReplace', name='bitReplace', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='createTrayNotification', return_types=['bool'], arguments=[FunctionArgument(name='notificationText', argument_type='string', default_value=None, optional=False), FunctionArgument(name='iconType', argument_type='string', default_value='"default"', optional=True), FunctionArgument(name='useSound', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description='This functions creates a notification ballon on the desktop.', arguments={'notificationText': 'The text to send in the notification.', 'iconType': 'The notification icon type. Possible values are: default (the MTA icon), info, warning, error', 'useSound': 'A boolean value indicating whether or not to play a sound when receiving the notification.'}, result="Returns ''true'' if the notification is correctly created, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/CreateTrayNotification', name='createTrayNotification', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='debugSleep', return_types=['bool'], arguments=[FunctionArgument(name='sleep', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='[[debugSleep]] freezes the client/server for the specified time. This means that all synchronization, rendering and script execution will stop except HTTP processing invoked by [[fetchRemote]]. This function only works, if development mode is enabled by [[setDevelopmentMode]] and can be utilised to build a debugger that communicates via HTTP requests with the editor/IDE.', arguments={'sleep ': ': An integer value in milliseconds.'}, result="Returns ''true'' if the development mode is enabled and arguments are correct, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DebugSleep', name='debugSleep', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='debugSleep', return_types=['bool'], arguments=[FunctionArgument(name='sleep', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='[[debugSleep]] freezes the client/server for the specified time. This means that all synchronization, rendering and script execution will stop except HTTP processing invoked by [[fetchRemote]]. This function only works, if development mode is enabled by [[setDevelopmentMode]] and can be utilised to build a debugger that communicates via HTTP requests with the editor/IDE.', arguments={'sleep ': ': An integer value in milliseconds.'}, result="Returns ''true'' if the development mode is enabled and arguments are correct, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DebugSleep', name='debugSleep', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='downloadFile', return_types=['bool'], arguments=[FunctionArgument(name='fileName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function ensures the requested resource file is correct and then triggers [[onClientFileDownloadComplete]].  If the file has been previously downloaded and the CRC matches, the file will not be downloaded again but [[onClientFileDownloadComplete]] will still run. The \'\'\'file\'\'\' should also be included in the resource meta.xml with the \'\'\'download\'\'\' attribute set to "false", see [[meta.xml]] for more details.\n}}', arguments={'fileName': ': A string referencing the name of the file to download'}, result="Returns ''true'' if file download has been queued, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/DownloadFile', name='downloadFile', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='decodeString', return_types=['string'], arguments=[FunctionArgument(name='algorithm', argument_type='string', default_value=None, optional=False), FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='options', argument_type='table', default_value=None, optional=False), FunctionArgument(name='callback', argument_type='function', default_value=None, optional=True)]), docs=FunctionDoc(description='This function decodes an encoded [[string]] using the specified algorithm. The counterpart of this function is [[encodeString]].\n}}', arguments={'algorithm': 'The algorithm to use.', 'input': 'The input to decode.', 'options': 'A table with options and other neccessary data for the algorithm, as detailed below.'}, result="Returns the decoded string if successful, ''false'' otherwise. If a callback was provided, the decoded string is argument to the callback."), oop=None, url=FunctionUrl(url='/wiki/DecodeString', name='decodeString', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='decodeString', return_types=['string'], arguments=[FunctionArgument(name='algorithm', argument_type='string', default_value=None, optional=False), FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='options', argument_type='table', default_value=None, optional=False), FunctionArgument(name='callback', argument_type='function', default_value=None, optional=True)]), docs=FunctionDoc(description='This function decodes an encoded [[string]] using the specified algorithm. The counterpart of this function is [[encodeString]].\n}}', arguments={'algorithm': 'The algorithm to use.', 'input': 'The input to decode.', 'options': 'A table with options and other neccessary data for the algorithm, as detailed below.'}, result="Returns the decoded string if successful, ''false'' otherwise. If a callback was provided, the decoded string is argument to the callback."), oop=None, url=FunctionUrl(url='/wiki/DecodeString', name='decodeString', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='encodeString', return_types=['string'], arguments=[FunctionArgument(name='algorithm', argument_type='string', default_value=None, optional=False), FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='options', argument_type='table', default_value=None, optional=False), FunctionArgument(name='callback', argument_type='function', default_value=None, optional=True)]), docs=FunctionDoc(description='This function encodes a [[string]] using the specified algorithm. The counterpart of this function is [[decodeString]].\n}}', arguments={'algorithm': 'The algorithm to use.', 'input': 'The input to encode.', 'options': 'A table with options and other neccessary data for the algorithm, as detailed below.'}, result="Returns the encoded string if successful, ''false'' otherwise. If a callback was provided, ''true'' is returned immediately, and the encoded string is passed as an argument to the callback."), oop=None, url=FunctionUrl(url='/wiki/EncodeString', name='encodeString', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='encodeString', return_types=['string'], arguments=[FunctionArgument(name='algorithm', argument_type='string', default_value=None, optional=False), FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='options', argument_type='table', default_value=None, optional=False), FunctionArgument(name='callback', argument_type='function', default_value=None, optional=True)]), docs=FunctionDoc(description='This function encodes a [[string]] using the specified algorithm. The counterpart of this function is [[decodeString]].\n}}', arguments={'algorithm': 'The algorithm to use.', 'input': 'The input to encode.', 'options': 'A table with options and other neccessary data for the algorithm, as detailed below.'}, result="Returns the encoded string if successful, ''false'' otherwise. If a callback was provided, ''true'' is returned immediately, and the encoded string is passed as an argument to the callback."), oop=None, url=FunctionUrl(url='/wiki/EncodeString', name='encodeString', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fromJSON', return_types=['var'], arguments=[FunctionArgument(name='json', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function parses a [[JSON]] formatted string into variables. You can use [[toJSON]] to encode variables into a JSON string that can be read by this function.', arguments={'json': 'A JSON formatted string'}, result='Returns variables read from the JSON string.\n\'\'\'Note:\'\'\' Indices of a JSON object such as "1": "cat" are being returned as [[string]], not as [[int]]eger.'), oop=None, url=FunctionUrl(url='/wiki/FromJSON', name='fromJSON', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fromJSON', return_types=['var'], arguments=[FunctionArgument(name='json', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function parses a [[JSON]] formatted string into variables. You can use [[toJSON]] to encode variables into a JSON string that can be read by this function.', arguments={'json': 'A JSON formatted string'}, result='Returns variables read from the JSON string.\n\'\'\'Note:\'\'\' Indices of a JSON object such as "1": "cat" are being returned as [[string]], not as [[int]]eger.'), oop=None, url=FunctionUrl(url='/wiki/FromJSON', name='fromJSON', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getColorFromString', return_types=['int,', 'int,', 'int,', 'int'], arguments=[FunctionArgument(name='theColor', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will extract Red, Green, Blue and Alpha values from a hex string you provide it. These strings follow the same format as used in HTML, with addition of the Alpha values.', arguments={'theColor': 'A string containing a valid color code.\n:Valid strings are:', '#RRGGBB': ': Colors specified, Alpha assumed to be 255.', '#RRGGBBAA': ': All values specified.', '#RGB': ': Shortened form, will be expanded internally to RRGGBB, as such it provides a smaller number of colors.', '#RGBA': ': As above, shortened - each character is duplicated.\n:For example:', '#FF00FF': 'is Red: 255, Green: 0, Blue: 255, Alpha: 255', '#F0F': 'is Red: 255, Green: 0, Blue: 255, Alpha: 255 (the same as the example above)', '#34455699': 'is Red: 52, Green: 69, Blue: 86, Alpha: 153\nAll colors used must begin with a # sign.'}, result="Returns four integers in RGBA format, with a maximum value of 255 for each.  Each stands for ''red'', ''green'', ''blue'', and ''alpha''.  Alpha decides transparancy where 255 is opaque and 0 is transparent.  ''false'' is returned if the string passed is invalid (for example, is missing the preceeding # sign)."), oop=None, url=FunctionUrl(url='/wiki/GetColorFromString', name='getColorFromString', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getColorFromString', return_types=['int,', 'int,', 'int,', 'int'], arguments=[FunctionArgument(name='theColor', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will extract Red, Green, Blue and Alpha values from a hex string you provide it. These strings follow the same format as used in HTML, with addition of the Alpha values.', arguments={'theColor': 'A string containing a valid color code.\n:Valid strings are:', '#RRGGBB': ': Colors specified, Alpha assumed to be 255.', '#RRGGBBAA': ': All values specified.', '#RGB': ': Shortened form, will be expanded internally to RRGGBB, as such it provides a smaller number of colors.', '#RGBA': ': As above, shortened - each character is duplicated.\n:For example:', '#FF00FF': 'is Red: 255, Green: 0, Blue: 255, Alpha: 255', '#F0F': 'is Red: 255, Green: 0, Blue: 255, Alpha: 255 (the same as the example above)', '#34455699': 'is Red: 52, Green: 69, Blue: 86, Alpha: 153\nAll colors used must begin with a # sign.'}, result="Returns four integers in RGBA format, with a maximum value of 255 for each.  Each stands for ''red'', ''green'', ''blue'', and ''alpha''.  Alpha decides transparancy where 255 is opaque and 0 is transparent.  ''false'' is returned if the string passed is invalid (for example, is missing the preceeding # sign)."), oop=None, url=FunctionUrl(url='/wiki/GetColorFromString', name='getColorFromString', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getDevelopmentMode', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function is used to get the development mode of the client. For more information see [[setDevelopmentMode]]', arguments={}, result="Returns ''true'' if the development mode is on, ''false'' if off."), oop=None, url=FunctionUrl(url='/wiki/GetDevelopmentMode', name='getDevelopmentMode', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getDevelopmentMode', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function is used to get the development mode of the client. For more information see [[setDevelopmentMode]]', arguments={}, result="Returns ''true'' if the development mode is on, ''false'' if off."), oop=None, url=FunctionUrl(url='/wiki/GetDevelopmentMode', name='getDevelopmentMode', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getDistanceBetweenPoints2D', return_types=['float'], arguments=[FunctionArgument(name='x1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y2', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the distance between two 2 dimensional points using the pythagorean theorem.', arguments={'x1': ': The X position of the first point', 'y1': ': The Y position of the first point', 'x2': ': The X position of the second point', 'y2': ': The Y position of the second point'}, result="Returns a float containing the 2D distance between the two points. Returns ''false'' if invalid parameters are passed."), oop=None, url=FunctionUrl(url='/wiki/GetDistanceBetweenPoints2D', name='getDistanceBetweenPoints2D', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getDistanceBetweenPoints2D', return_types=['float'], arguments=[FunctionArgument(name='x1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y2', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the distance between two 2 dimensional points using the pythagorean theorem.', arguments={'x1': ': The X position of the first point', 'y1': ': The Y position of the first point', 'x2': ': The X position of the second point', 'y2': ': The Y position of the second point'}, result="Returns a float containing the 2D distance between the two points. Returns ''false'' if invalid parameters are passed."), oop=None, url=FunctionUrl(url='/wiki/GetDistanceBetweenPoints2D', name='getDistanceBetweenPoints2D', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getDistanceBetweenPoints3D', return_types=['float'], arguments=[FunctionArgument(name='x1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z2', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the distance between two 3 dimensional points using the pythagorean theorem.', arguments={'x1': ': The X position of the first point', 'y1': ': The Y position of the first point', 'z1': ': The Z position of the first point', 'x2': ': The X position of the second point', 'y2': ': The Y position of the second point', 'z2': ': The Z position of the second point'}, result="Returns a float containing the distance between the two points as a [[float]]. Returns ''false'' if an argument passed was invalid."), oop=None, url=FunctionUrl(url='/wiki/GetDistanceBetweenPoints3D', name='getDistanceBetweenPoints3D', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getDistanceBetweenPoints3D', return_types=['float'], arguments=[FunctionArgument(name='x1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z2', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the distance between two 3 dimensional points using the pythagorean theorem.', arguments={'x1': ': The X position of the first point', 'y1': ': The Y position of the first point', 'z1': ': The Z position of the first point', 'x2': ': The X position of the second point', 'y2': ': The Y position of the second point', 'z2': ': The Z position of the second point'}, result="Returns a float containing the distance between the two points as a [[float]]. Returns ''false'' if an argument passed was invalid."), oop=None, url=FunctionUrl(url='/wiki/GetDistanceBetweenPoints3D', name='getDistanceBetweenPoints3D', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getEasingValue', return_types=['float'], arguments=[FunctionArgument(name='fProgress', argument_type='float', default_value=None, optional=False), FunctionArgument(name='strEasingType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='fEasingPeriod', argument_type='float', default_value=None, optional=True), FunctionArgument(name='fEasingAmplitude', argument_type='float', default_value=None, optional=True), FunctionArgument(name='fEasingOvershoot', argument_type='float', default_value=None, optional=True)]), docs=FunctionDoc(description='Used for custom Lua based interpolation, returns the easing value (animation time to use in your custom interpolation) given a progress and an [[Easing|easing function]].\nIn most cases, either [[moveObject]] or [[interpolateBetween]] can do the job. getEasingValue is only provided in case you want to do your own custom interpolation based on easing.', arguments={'fProgress': 'float between 0 and 1 indicating the interpolation progress (0 at the beginning of the interpolation, 1 at the end).', 'strEasingType': 'the Easing|easing function to use for the interpolation', 'fEasingPeriod': 'the period of the Easing|easing function (only some easing functions use this parameter)', 'fEasingAmplitude': 'the amplitude of the Easing|easing function (only some easing functions use this parameter)', 'fEasingOvershoot': 'the overshoot of the Easing|easing function (only some easing functions use this parameter)'}, result="Returns ''fAnimationTime '' the animation time given by the easing function (can be < 0 or > 1 since some [[Easing|easing functions]] have overshoot or bounce/spring effects, ''false'' otherwise (error in parameters)."), oop=None, url=FunctionUrl(url='/wiki/GetEasingValue', name='getEasingValue', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getEasingValue', return_types=['float'], arguments=[FunctionArgument(name='fProgress', argument_type='float', default_value=None, optional=False), FunctionArgument(name='strEasingType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='fEasingPeriod', argument_type='float', default_value=None, optional=True), FunctionArgument(name='fEasingAmplitude', argument_type='float', default_value=None, optional=True), FunctionArgument(name='fEasingOvershoot', argument_type='float', default_value=None, optional=True)]), docs=FunctionDoc(description='Used for custom Lua based interpolation, returns the easing value (animation time to use in your custom interpolation) given a progress and an [[Easing|easing function]].\nIn most cases, either [[moveObject]] or [[interpolateBetween]] can do the job. getEasingValue is only provided in case you want to do your own custom interpolation based on easing.', arguments={'fProgress': 'float between 0 and 1 indicating the interpolation progress (0 at the beginning of the interpolation, 1 at the end).', 'strEasingType': 'the Easing|easing function to use for the interpolation', 'fEasingPeriod': 'the period of the Easing|easing function (only some easing functions use this parameter)', 'fEasingAmplitude': 'the amplitude of the Easing|easing function (only some easing functions use this parameter)', 'fEasingOvershoot': 'the overshoot of the Easing|easing function (only some easing functions use this parameter)'}, result="Returns ''fAnimationTime '' the animation time given by the easing function (can be < 0 or > 1 since some [[Easing|easing functions]] have overshoot or bounce/spring effects, ''false'' otherwise (error in parameters)."), oop=None, url=FunctionUrl(url='/wiki/GetEasingValue', name='getEasingValue', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getFPSLimit', return_types=['int'], arguments=[]), docs=FunctionDoc(description='This function retrieves the maximum [http://en.wikipedia.org/wiki/Frame_rate FPS (Frames per second)] that players on the server can run their game at.  ', arguments={}, result="Returns an integer between '''25''' and '''100''' of the maximum FPS that players can run their game at."), oop=None, url=FunctionUrl(url='/wiki/GetFPSLimit', name='getFPSLimit', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getFPSLimit', return_types=['int'], arguments=[]), docs=FunctionDoc(description='This function retrieves the maximum [http://en.wikipedia.org/wiki/Frame_rate FPS (Frames per second)] that players on the server can run their game at.  ', arguments={}, result="Returns an integer between '''25''' and '''100''' of the maximum FPS that players can run their game at."), oop=None, url=FunctionUrl(url='/wiki/GetFPSLimit', name='getFPSLimit', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getKeyboardLayout', return_types=['table'], arguments=[]), docs=FunctionDoc(description='', arguments={}, result='Returns a \'\'table\'\' with keyboard layout properties:\n{| class="wikitable" style="cellpadding: 10px;"\n|-\n! Property || Values and description\n|-\n| <code>readingLayout</code> ||\n    {| class="prettytable"\n    |-\n    | <code>"ltr"</code> || Left to right (English)\n    |-\n    | <code>"rtl"</code> || Right to left (Arabic, Hebrew)\n    |-\n    | <code>"ttb-rtl-ltr"</code> || Either read vertically from top to bottom with columns going from right to left, or read in horizontal rows from left to right, as for the Japanese (Japan) locale.\n    |-\n    | <code>"ttb-ltr"</code> || Read vertically from top to bottom with columns going from left to right, as for the Mongolian (Mongolian) locale.\n    |}\n|}'), oop=None, url=FunctionUrl(url='/wiki/GetKeyboardLayout', name='getKeyboardLayout', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getLocalization', return_types=['table'], arguments=[]), docs=FunctionDoc(description="This function gets the player's localization setting as set in the MTA client.\n}}", arguments={}, result='Returns a [[table]] with the following entries:\n*\'\'\'code :\'\'\' The language code \'\'(eg. "en_US" for "English (United States)" or "ar" for "Arabic")\'\'.\n*\'\'\'name :\'\'\' The name of the language \'\'(eg. "English (United States)" or "Arabic")\'\'.'), oop=None, url=FunctionUrl(url='/wiki/GetLocalization', name='getLocalization', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getNetworkStats', return_types=['table'], arguments=[FunctionArgument(name='thePlayer', argument_type='element', default_value='nil', optional=False)]), docs=FunctionDoc(description='This function returns network status information.', arguments={}, result="Returns a table, the indexes in the table are the following:\n* '''bytesReceived''' - Total number of bytes received since the connection was started\n* '''bytesSent''' - Total number of bytes sent since the connection was started\n* '''packetsReceived''' - Total number of packets received since the connection was started\n* '''packetsSent''' - Total number of packets sent since the connection was started\n* '''packetlossTotal''' - (0-100) Total packet loss percentage of sent data, since the connection was started\n* '''packetlossLastSecond''' - (0-100) Packet loss percentage of sent data, during the previous second\n* '''messagesInSendBuffer'''\n* '''messagesInResendBuffer''' - Number of packets queued to be resent (due to packet loss)\n* '''isLimitedByCongestionControl'''\n* '''isLimitedByOutgoingBandwidthLimit'''\n* '''encryptionStatus'''"), oop=None, url=FunctionUrl(url='/wiki/GetNetworkStats', name='getNetworkStats', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getNetworkStats', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function returns network status information.', arguments={}, result="Returns a table, the indexes in the table are the following:\n* '''bytesReceived''' - Total number of bytes received since the connection was started\n* '''bytesSent''' - Total number of bytes sent since the connection was started\n* '''packetsReceived''' - Total number of packets received since the connection was started\n* '''packetsSent''' - Total number of packets sent since the connection was started\n* '''packetlossTotal''' - (0-100) Total packet loss percentage of sent data, since the connection was started\n* '''packetlossLastSecond''' - (0-100) Packet loss percentage of sent data, during the previous second\n* '''messagesInSendBuffer'''\n* '''messagesInResendBuffer''' - Number of packets queued to be resent (due to packet loss)\n* '''isLimitedByCongestionControl'''\n* '''isLimitedByOutgoingBandwidthLimit'''\n* '''encryptionStatus'''"), oop=None, url=FunctionUrl(url='/wiki/GetNetworkStats', name='getNetworkStats', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getNetworkUsageData', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function returns a [[table]] containing network usage information about inbound and outbound packets.', arguments={}, result='Returns a [[table]] with two fields: "in" and "out". Each of these contain a table with two fields: "bits" and "count". Each of these contain a table with 256 numeric fields ranging from 0 to 255, containing the appropriate network usage data for such packet id.'), oop=None, url=FunctionUrl(url='/wiki/GetNetworkUsageData', name='getNetworkUsageData', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getNetworkUsageData', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function returns a [[table]] containing network usage information about inbound and outbound packets.', arguments={}, result='Returns a [[table]] with two fields: "in" and "out". Each of these contain a table with two fields: "bits" and "count". Each of these contain a table with 256 numeric fields ranging from 0 to 255, containing the appropriate network usage data for such packet id.'), oop=None, url=FunctionUrl(url='/wiki/GetNetworkUsageData', name='getNetworkUsageData', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPerformanceStats', return_types=['table', 'table'], arguments=[FunctionArgument(name='category', argument_type='string', default_value=None, optional=False), FunctionArgument(name='options', argument_type='string', default_value='""', optional=True), FunctionArgument(name='filter', argument_type='string', default_value='""', optional=True)]), docs=FunctionDoc(description='This function returns performance information.', arguments={'category': 'Performance statistics category. If empty string is given, list of all categories is returned.See categories for more information.', 'options': 'Category specific , separated options. All categories supports h option for help.', 'filter': 'Case-sensitive filter used to select returned rows. Only name column is filtered.'}, result='Returns two tables. First contains column names. The second contains result rows. Each row is table of cells.'), oop=None, url=FunctionUrl(url='/wiki/GetPerformanceStats', name='getPerformanceStats', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getPerformanceStats', return_types=['table', 'table'], arguments=[FunctionArgument(name='category', argument_type='string', default_value=None, optional=False), FunctionArgument(name='options', argument_type='string', default_value='""', optional=True), FunctionArgument(name='filter', argument_type='string', default_value='""', optional=True)]), docs=FunctionDoc(description='This function returns performance information.', arguments={'category': 'Performance statistics category. If empty string is given, list of all categories is returned.See categories for more information.', 'options': 'Category specific , separated options. All categories supports h option for help.', 'filter': 'Case-sensitive filter used to select returned rows. Only name column is filtered.'}, result='Returns two tables. First contains column names. The second contains result rows. Each row is table of cells.'), oop=None, url=FunctionUrl(url='/wiki/GetPerformanceStats', name='getPerformanceStats', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getRealTime', return_types=['table'], arguments=[FunctionArgument(name='seconds', argument_type='int', default_value='current', optional=False), FunctionArgument(name='localTime', argument_type='bool', default_value='true', optional=False)]), docs=FunctionDoc(description="This function gets the server or client (if used client sided it returns time as set on client's computer) real time and returns it in a table. If you want to get the in-game time (shown on GTA's clock) use [[getTime]].", arguments={'seconds': 'A count in seconds from the year 1970.  Useful for storing points in time, or for retrieving time information for getBanTime. The valid range of this argument is 0 to 32,000,000,000\n{{New feature/item|3.0141|1.4.1|6976|', 'localTime': 'Set to true to adjust for the locally set timezone.\n}}'}, result='Returns a \'\'table\'\' of substrings with different time format or \'\'false\'\' if the \'\'\'seconds\'\'\' argument is out of range.\n{| border="2" cellpadding="2" cellspacing="0" style="margin: 1em 1em 1em 0; background: #f9f9f9; border: 1px #aaa solid; border-collapse: collapse; font-size: 95%;"\n|\'\'\'Member\'\'\'\n|\'\'\'Meaning\'\'\'\n|\'\'\'Range\'\'\'\n|-\n|second\n|seconds after the minute\n|0-61*\n|-\n|minute\n|minutes after the hour\n|0-59\n|-\n|hour\n|hours since midnight\n|0-23\n|-\n|monthday\n|day of the month\n|1-31\n|-\n|month\n|months since January\n|0-11\n|-\n|year\n|years since 1900\n|-\n|weekday\n|days since Sunday\n|0-6\n|-\n|yearday\n|days since January 1\n|0-365\n|-\n|isdst\n|Daylight Saving Time flag\n|-\n|timestamp\n|seconds since 1970 (Ignoring set timezone)\n|\n|}\n\'\'* second\'\' is generally 0-59. Extra range to accommodate for leap seconds in certain systems.'), oop=None, url=FunctionUrl(url='/wiki/GetRealTime', name='getRealTime', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getRealTime', return_types=['table'], arguments=[FunctionArgument(name='seconds', argument_type='int', default_value='current', optional=False), FunctionArgument(name='localTime', argument_type='bool', default_value='true', optional=False)]), docs=FunctionDoc(description="This function gets the server or client (if used client sided it returns time as set on client's computer) real time and returns it in a table. If you want to get the in-game time (shown on GTA's clock) use [[getTime]].", arguments={'seconds': 'A count in seconds from the year 1970.  Useful for storing points in time, or for retrieving time information for getBanTime. The valid range of this argument is 0 to 32,000,000,000\n{{New feature/item|3.0141|1.4.1|6976|', 'localTime': 'Set to true to adjust for the locally set timezone.\n}}'}, result='Returns a \'\'table\'\' of substrings with different time format or \'\'false\'\' if the \'\'\'seconds\'\'\' argument is out of range.\n{| border="2" cellpadding="2" cellspacing="0" style="margin: 1em 1em 1em 0; background: #f9f9f9; border: 1px #aaa solid; border-collapse: collapse; font-size: 95%;"\n|\'\'\'Member\'\'\'\n|\'\'\'Meaning\'\'\'\n|\'\'\'Range\'\'\'\n|-\n|second\n|seconds after the minute\n|0-61*\n|-\n|minute\n|minutes after the hour\n|0-59\n|-\n|hour\n|hours since midnight\n|0-23\n|-\n|monthday\n|day of the month\n|1-31\n|-\n|month\n|months since January\n|0-11\n|-\n|year\n|years since 1900\n|-\n|weekday\n|days since Sunday\n|0-6\n|-\n|yearday\n|days since January 1\n|0-365\n|-\n|isdst\n|Daylight Saving Time flag\n|-\n|timestamp\n|seconds since 1970 (Ignoring set timezone)\n|\n|}\n\'\'* second\'\' is generally 0-59. Extra range to accommodate for leap seconds in certain systems.'), oop=None, url=FunctionUrl(url='/wiki/GetRealTime', name='getRealTime', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getTickCount', return_types=['int'], arguments=[]), docs=FunctionDoc(description='This function returns amount of time that your system has been running in milliseconds. By comparing two values of [[getTickCount]], you can determine how much time has passed (in milliseconds) between two events. This could be used to determine how efficient your code is, or to time how long a player takes to complete a task.', arguments={}, result='Returns an integer containing the number of milliseconds since the system the server is running on started. This has the potential to wrap-around.'), oop=None, url=FunctionUrl(url='/wiki/GetTickCount', name='getTickCount', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getTickCount', return_types=['int'], arguments=[]), docs=FunctionDoc(description='This function returns amount of time that your system has been running in milliseconds. By comparing two values of [[getTickCount]], you can determine how much time has passed (in milliseconds) between two events. This could be used to determine how efficient your code is, or to time how long a player takes to complete a task.', arguments={}, result='Returns an integer containing the number of milliseconds since the system the server is running on started. This has the potential to wrap-around.'), oop=None, url=FunctionUrl(url='/wiki/GetTickCount', name='getTickCount', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getTimers', return_types=['table'], arguments=[FunctionArgument(name='theTime', argument_type='int', default_value='nil', optional=False)]), docs=FunctionDoc(description='This function returns a table of all active timers that the resource that calls it has created. Alternatively, only the timers with a remaining time less than or equal to a certain value can be retrieved.', arguments={'theTime': 'The maximum time left (in milliseconds) on the timers you wish to retrieve.'}, result='Returns a table of all the active timers.'), oop=None, url=FunctionUrl(url='/wiki/GetTimers', name='getTimers', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getTimers', return_types=['table'], arguments=[FunctionArgument(name='theTime', argument_type='int', default_value='nil', optional=False)]), docs=FunctionDoc(description='This function returns a table of all active timers that the resource that calls it has created. Alternatively, only the timers with a remaining time less than or equal to a certain value can be retrieved.', arguments={'theTime': 'The maximum time left (in milliseconds) on the timers you wish to retrieve.'}, result='Returns a table of all the active timers.'), oop=None, url=FunctionUrl(url='/wiki/GetTimers', name='getTimers', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getTimerDetails', return_types=['int,', 'int,', 'int'], arguments=[FunctionArgument(name='theTimer', argument_type='timer', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is for getting the details of a running timer.', arguments={'theTimer': 'A timer element.'}, result='* Integer one represents the time left in miliseconds (1000th of a second) of the current time left in the loop.\n* Integer two represents the amount of times the timer has left to execute.\n* Integer three represents the time interval of timer.\n* Returns false if the timer doesn\'t exist or stopped running. Also, debugscript will say "Bad Argument @ \'getTimerDetails\'". To prevent this, you can check if the timer exists with [[isTimer]]().'), oop=FunctionOOP(class_name='timer', method_name='getDetails', field=None), url=FunctionUrl(url='/wiki/GetTimerDetails', name='getTimerDetails', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getTimerDetails', return_types=['int,', 'int,', 'int'], arguments=[FunctionArgument(name='theTimer', argument_type='timer', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is for getting the details of a running timer.', arguments={'theTimer': 'A timer element.'}, result='* Integer one represents the time left in miliseconds (1000th of a second) of the current time left in the loop.\n* Integer two represents the amount of times the timer has left to execute.\n* Integer three represents the time interval of timer.\n* Returns false if the timer doesn\'t exist or stopped running. Also, debugscript will say "Bad Argument @ \'getTimerDetails\'". To prevent this, you can check if the timer exists with [[isTimer]]().'), oop=FunctionOOP(class_name='timer', method_name='getDetails', field=None), url=FunctionUrl(url='/wiki/GetTimerDetails', name='getTimerDetails', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='gettok', return_types=['string'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='tokenNumber', argument_type='int', default_value=None, optional=False), FunctionArgument(name='int', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function splits a string using the given separating character and returns one specified substring.', arguments={'text': 'the string that should be split.', 'tokenNumber': 'which token should be returned (1 for the first, 2 for the second, and so on).', 'separatingCharacter': 'the ASCII|ASCII number representing the character you want to use to separate the tokens. You can easily retrieve this by running string.byte on a string containing the separating character.'}, result="Returns a [[string]] containing the token if it exists, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Gettok', name='gettok', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='gettok', return_types=['string'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='tokenNumber', argument_type='int', default_value=None, optional=False), FunctionArgument(name='int', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function splits a string using the given separating character and returns one specified substring.', arguments={'text': 'the string that should be split.', 'tokenNumber': 'which token should be returned (1 for the first, 2 for the second, and so on).', 'separatingCharacter': 'the ASCII|ASCII number representing the character you want to use to separate the tokens. You can easily retrieve this by running string.byte on a string containing the separating character.'}, result="Returns a [[string]] containing the token if it exists, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Gettok', name='gettok', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getUserdataType', return_types=['string'], arguments=[FunctionArgument(name='value', argument_type='userdata', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'value': ': A userdata value to get the type of. Userdata types can be:', 'Shared': '', 'resource-data': ': a Resource|resource pointer.', 'xml-node': ': a Xmlnode|XML node.', 'lua-timer': ': a timer.', 'vector2': ': a 2D vector, used in the Vector/Vector2|Vector2 class.', 'vector3': ': a 3D vector, used in the Vector/Vector3|Vector3 class.', 'vector4': ': a 4D vector, used in the Vector/Vector4|Vector4 class.', 'matrix': ': a matrix, used in the Matrix class.', 'userdata': ': a fallback userdata type return value, when no other type could be found for the object.', 'Server only': '', 'account': ': a Account|player account.', 'db-query': ': a dbQuery|database query handle.', 'acl': ': an ACL|ACL entry.', 'acl-group': ': an Aclgroup|ACL group.', 'ban': ': a Ban|player ban.', 'text-item': ': a Textitem|text display item.', 'text-display': ": a Textdisplay|text display item.\n<!-- I don't think that this userdata type is used in current MTA versions. According to the source, is serverside only.\n     Source code commit: https://github.com/multitheftauto/mtasa-blue/commit/df8576fc3f80fa2d7a73e70a68e8f116b591cb68#diff-09a3546021ff952dc0f94a99aae11356R297", 'weapon': ': a Weapon|custom weapon.\n-->'}, result="Returns a [[string]] containing the specified userdata's type, or ''false'' plus an error message if the given value is not userdata."), oop=None, url=FunctionUrl(url='/wiki/GetUserdataType', name='getUserdataType', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getUserdataType', return_types=['string'], arguments=[FunctionArgument(name='value', argument_type='userdata', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'value': ': A userdata value to get the type of. Userdata types can be:', 'Shared': '', 'resource-data': ': a Resource|resource pointer.', 'xml-node': ': a Xmlnode|XML node.', 'lua-timer': ': a timer.', 'vector2': ': a 2D vector, used in the Vector/Vector2|Vector2 class.', 'vector3': ': a 3D vector, used in the Vector/Vector3|Vector3 class.', 'vector4': ': a 4D vector, used in the Vector/Vector4|Vector4 class.', 'matrix': ': a matrix, used in the Matrix class.', 'userdata': ': a fallback userdata type return value, when no other type could be found for the object.', 'Server only': '', 'account': ': a Account|player account.', 'db-query': ': a dbQuery|database query handle.', 'acl': ': an ACL|ACL entry.', 'acl-group': ': an Aclgroup|ACL group.', 'ban': ': a Ban|player ban.', 'text-item': ': a Textitem|text display item.', 'text-display': ": a Textdisplay|text display item.\n<!-- I don't think that this userdata type is used in current MTA versions. According to the source, is serverside only.\n     Source code commit: https://github.com/multitheftauto/mtasa-blue/commit/df8576fc3f80fa2d7a73e70a68e8f116b591cb68#diff-09a3546021ff952dc0f94a99aae11356R297", 'weapon': ': a Weapon|custom weapon.\n-->'}, result="Returns a [[string]] containing the specified userdata's type, or ''false'' plus an error message if the given value is not userdata."), oop=None, url=FunctionUrl(url='/wiki/GetUserdataType', name='getUserdataType', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVersion', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function gives you various version information about MTA and the operating system.', arguments={}, result='Returns a table with version information. Specifically these keys are present in the table:\n*\'\'\'number:\'\'\' the MTA server or client version (depending where the function was called) in pure numerical form, e.g. \'\'"256"\'\'\n*\'\'\'mta:\'\'\' the MTA server or client version (depending where the function was called) in textual form, e.g. \'\'"1.0"\'\'\n*\'\'\'name:\'\'\' the full MTA product name, either \'\'"MTA:SA Server"\'\' or \'\'"MTA:SA Client"\'\'.\n*\'\'\'netcode:\'\'\' the netcode version number.\n*\'\'\'os:\'\'\' returns the operating system on which the server or client is running\n*\'\'\'type:\'\'\' the type of build.  can be:\n**\'\'\'"Nightly rX"\'\'\' - A nightly development build.  \'\'\'X\'\'\' represents the nightly build revision.\n**\'\'\'"Custom"\'\'\' - A build compiled manually\n**\'\'\'"Release"\'\'\' - A build that is publicly released (provisional).\n*\'\'\'tag:\'\'\' the build tag (from 1.0.3 onwards). Contains infomation about the underlying version used. i.e. The final version of 1.0.3 has the build tag of "1.0.3 rc-9". (This can be confirmed by using the console command \'ver\'.)\n*\'\'\'sortable:\'\'\' a 15 character sortable version string (from 1.0.4 onwards). Format of the string is described in [[getPlayerVersion]].'), oop=None, url=FunctionUrl(url='/wiki/GetVersion', name='getVersion', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVersion', return_types=['table'], arguments=[]), docs=FunctionDoc(description='This function gives you various version information about MTA and the operating system.', arguments={}, result='Returns a table with version information. Specifically these keys are present in the table:\n*\'\'\'number:\'\'\' the MTA server or client version (depending where the function was called) in pure numerical form, e.g. \'\'"256"\'\'\n*\'\'\'mta:\'\'\' the MTA server or client version (depending where the function was called) in textual form, e.g. \'\'"1.0"\'\'\n*\'\'\'name:\'\'\' the full MTA product name, either \'\'"MTA:SA Server"\'\' or \'\'"MTA:SA Client"\'\'.\n*\'\'\'netcode:\'\'\' the netcode version number.\n*\'\'\'os:\'\'\' returns the operating system on which the server or client is running\n*\'\'\'type:\'\'\' the type of build.  can be:\n**\'\'\'"Nightly rX"\'\'\' - A nightly development build.  \'\'\'X\'\'\' represents the nightly build revision.\n**\'\'\'"Custom"\'\'\' - A build compiled manually\n**\'\'\'"Release"\'\'\' - A build that is publicly released (provisional).\n*\'\'\'tag:\'\'\' the build tag (from 1.0.3 onwards). Contains infomation about the underlying version used. i.e. The final version of 1.0.3 has the build tag of "1.0.3 rc-9". (This can be confirmed by using the console command \'ver\'.)\n*\'\'\'sortable:\'\'\' a 15 character sortable version string (from 1.0.4 onwards). Format of the string is described in [[getPlayerVersion]].'), oop=None, url=FunctionUrl(url='/wiki/GetVersion', name='getVersion', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='hash', return_types=['string'], arguments=[FunctionArgument(name='algorithm', argument_type='string', default_value=None, optional=False), FunctionArgument(name='dataToHash', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a hash of the specified string in the specified algorithm.\n}}', arguments={'algorithm': ': A string which must be one of these: md5, sha1, sha224, sha256, sha384, sha512', 'dataToHash': ': A string of the data to hash.'}, result='Returns the hash of the data, false if an invalid argument was used.'), oop=None, url=FunctionUrl(url='/wiki/Hash', name='hash', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='hash', return_types=['string'], arguments=[FunctionArgument(name='algorithm', argument_type='string', default_value=None, optional=False), FunctionArgument(name='dataToHash', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a hash of the specified string in the specified algorithm.\n}}', arguments={'algorithm': ': A string which must be one of these: md5, sha1, sha224, sha256, sha384, sha512', 'dataToHash': ': A string of the data to hash.'}, result='Returns the hash of the data, false if an invalid argument was used.'), oop=None, url=FunctionUrl(url='/wiki/Hash', name='hash', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='inspect', return_types=['string'], arguments=[FunctionArgument(name='var', argument_type='mixed', default_value=None, optional=False), FunctionArgument(name='options', argument_type='table', default_value=None, optional=True)]), docs=FunctionDoc(description='This function returns human-readable representations of tables and MTA datatypes as a string.\n}}', arguments={'var': 'A variable of any datatype.', 'options': 'A table of options. It is not mandatory, but when it is provided, it must be a table. For a list of options, see the https://github.com/kikito/inspect.lua#options Inspects GitHub page.'}, result='Always returns a string. The contents can change if we update the inspect library, so it is not expected to be consistent across Lua versions.'), oop=None, url=FunctionUrl(url='/wiki/Inspect', name='inspect', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='inspect', return_types=['string'], arguments=[FunctionArgument(name='var', argument_type='mixed', default_value=None, optional=False), FunctionArgument(name='options', argument_type='table', default_value=None, optional=True)]), docs=FunctionDoc(description='This function returns human-readable representations of tables and MTA datatypes as a string.\n}}', arguments={'var': 'A variable of any datatype.', 'options': 'A table of options. It is not mandatory, but when it is provided, it must be a table. For a list of options, see the https://github.com/kikito/inspect.lua#options Inspects GitHub page.'}, result='Always returns a string. The contents can change if we update the inspect library, so it is not expected to be consistent across Lua versions.'), oop=None, url=FunctionUrl(url='/wiki/Inspect', name='inspect', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='interpolateBetween', return_types=['float', 'float', 'float'], arguments=[FunctionArgument(name='x1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fProgress', argument_type='float', default_value=None, optional=False), FunctionArgument(name='strEasingType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='fEasingPeriod', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fEasingAmplitude', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fEasingOvershoot', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='Interpolates a 3D Vector between a source value and a target value using either linear interpolation or any other [[Easing|easing function]].\nIt can also be used to interpolate 2D vectors or scalars by only setting some of the x, y, z values and putting 0 to the others.', arguments={'x1, y1, z1': '3D coordinates of source vector/value', 'x2, y2, z2': '3D coordinates of target vector/value', 'fProgress': 'float between 0 and 1 indicating the interpolation progress (0 at the beginning of the interpolation, 1 at the end). If it is higher than 1, it will start from the beginning.', 'strEasingType': 'the Easing|easing function to use for the interpolation', 'fEasingPeriod': 'the period of the Easing|easing function (only some easing functions use this parameter)', 'fEasingAmplitude': 'the amplitude of the Easing|easing function (only some easing functions use this parameter)', 'fEasingOvershoot': 'the overshoot of the Easing|easing function (only some easing functions use this parameter)'}, result="Returns ''x, y, z'' the interpolated 3D vector/value if successful, ''false'' otherwise (error in parameters).\nAs mentioned before, interpolateBetween can be used on 2D vectors or scalars in which case only some (x, y or just x) of the returned values are to be used (cf. alpha interpolation in marker example or size interpolation in window example)."), oop=None, url=FunctionUrl(url='/wiki/InterpolateBetween', name='interpolateBetween', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='interpolateBetween', return_types=['float', 'float', 'float'], arguments=[FunctionArgument(name='x1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fProgress', argument_type='float', default_value=None, optional=False), FunctionArgument(name='strEasingType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='fEasingPeriod', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fEasingAmplitude', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fEasingOvershoot', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='Interpolates a 3D Vector between a source value and a target value using either linear interpolation or any other [[Easing|easing function]].\nIt can also be used to interpolate 2D vectors or scalars by only setting some of the x, y, z values and putting 0 to the others.', arguments={'x1, y1, z1': '3D coordinates of source vector/value', 'x2, y2, z2': '3D coordinates of target vector/value', 'fProgress': 'float between 0 and 1 indicating the interpolation progress (0 at the beginning of the interpolation, 1 at the end). If it is higher than 1, it will start from the beginning.', 'strEasingType': 'the Easing|easing function to use for the interpolation', 'fEasingPeriod': 'the period of the Easing|easing function (only some easing functions use this parameter)', 'fEasingAmplitude': 'the amplitude of the Easing|easing function (only some easing functions use this parameter)', 'fEasingOvershoot': 'the overshoot of the Easing|easing function (only some easing functions use this parameter)'}, result="Returns ''x, y, z'' the interpolated 3D vector/value if successful, ''false'' otherwise (error in parameters).\nAs mentioned before, interpolateBetween can be used on 2D vectors or scalars in which case only some (x, y or just x) of the returned values are to be used (cf. alpha interpolation in marker example or size interpolation in window example)."), oop=None, url=FunctionUrl(url='/wiki/InterpolateBetween', name='interpolateBetween', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='iprint', return_types=['bool'], arguments=[FunctionArgument(name='var1', argument_type='mixed', default_value=None, optional=False), FunctionArgument(name='var2', argument_type='mixed', default_value=None, optional=True), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description="This function intelligently outputs debug messages into the Debug Console.  It is similar to [[outputDebugString]], but outputs useful information for '''any''' variable type, and does not require use of Lua's tostring.  This includes information about element types, and table structures.  It is especially useful for quick debug tasks.\n}}", arguments={'var1': 'A variable of any type to print intelligent information for.\n{{OptionalArg}} ', 'var2+': 'Another variable to be output.  An unlimited number of arguments can be supplied'}, result="Always returns ''nil''."), oop=None, url=FunctionUrl(url='/wiki/Iprint', name='iprint', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='iprint', return_types=['bool'], arguments=[FunctionArgument(name='var1', argument_type='mixed', default_value=None, optional=False), FunctionArgument(name='var2', argument_type='mixed', default_value=None, optional=True), FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description="This function intelligently outputs debug messages into the Debug Console.  It is similar to [[outputDebugString]], but outputs useful information for '''any''' variable type, and does not require use of Lua's tostring.  This includes information about element types, and table structures.  It is especially useful for quick debug tasks.\n}}", arguments={'var1': 'A variable of any type to print intelligent information for.\n{{OptionalArg}} ', 'var2+': 'Another variable to be output.  An unlimited number of arguments can be supplied'}, result="Always returns ''nil''."), oop=None, url=FunctionUrl(url='/wiki/Iprint', name='iprint', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isOOPEnabled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='', arguments={}, result="Returns ''true'' or ''false'' if ''[[OOP]]'' is enabled or not. Returns ''nil'' if an error arised."), oop=None, url=FunctionUrl(url='/wiki/IsOOPEnabled', name='isOOPEnabled', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isOOPEnabled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='', arguments={}, result="Returns ''true'' or ''false'' if ''[[OOP]]'' is enabled or not. Returns ''nil'' if an error arised."), oop=None, url=FunctionUrl(url='/wiki/IsOOPEnabled', name='isOOPEnabled', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isTimer', return_types=['bool'], arguments=[FunctionArgument(name='theTimer', argument_type='timer', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if a variable is a [[timer]].', arguments={'theTimer': ': The variable that we want to check.'}, result="Returns ''true'' if the passed value is a timer, ''false'' otherwise."), oop=FunctionOOP(class_name='timer', method_name='isValid', field='valid'), url=FunctionUrl(url='/wiki/IsTimer', name='isTimer', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isTimer', return_types=['bool'], arguments=[FunctionArgument(name='theTimer', argument_type='timer', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if a variable is a [[timer]].', arguments={'theTimer': ': The variable that we want to check.'}, result="Returns ''true'' if the passed value is a timer, ''false'' otherwise."), oop=FunctionOOP(class_name='timer', method_name='isValid', field='valid'), url=FunctionUrl(url='/wiki/IsTimer', name='isTimer', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isTransferBoxVisible', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='', arguments={}, result="On '''server''' this returns a boolean, whether the transfer box should be visible during downloads or not.\nOn '''client''' this returns a boolean, whether the transfer box should be visible or not at the time of invocation."), oop=None, url=FunctionUrl(url='/wiki/IsTransferBoxVisible', name='isTransferBoxVisible', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isTransferBoxVisible', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='', arguments={}, result="On '''server''' this returns a boolean, whether the transfer box should be visible during downloads or not.\nOn '''client''' this returns a boolean, whether the transfer box should be visible or not at the time of invocation."), oop=None, url=FunctionUrl(url='/wiki/IsTransferBoxVisible', name='isTransferBoxVisible', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isTrayNotificationEnabled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function returns a boolean value whether the client has enabled tray notifications in his settings or not.', arguments={}, result="Returns ''true'' if the tray notifications are enabled in the settings, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsTrayNotificationEnabled', name='isTrayNotificationEnabled', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='killTimer', return_types=['bool'], arguments=[FunctionArgument(name='theTimer', argument_type='timer', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to kill/halt existing timers.', arguments={'theTimer': 'The timer you wish to halt.'}, result="Returns ''true'' if the timer was successfully killed, ''false'' if no such timer existed."), oop=FunctionOOP(class_name='timer', method_name='destroy', field=None), url=FunctionUrl(url='/wiki/KillTimer', name='killTimer', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='killTimer', return_types=['bool'], arguments=[FunctionArgument(name='theTimer', argument_type='timer', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to kill/halt existing timers.', arguments={'theTimer': 'The timer you wish to halt.'}, result="Returns ''true'' if the timer was successfully killed, ''false'' if no such timer existed."), oop=FunctionOOP(class_name='timer', method_name='destroy', field=None), url=FunctionUrl(url='/wiki/KillTimer', name='killTimer', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='md5', return_types=['string'], arguments=[FunctionArgument(name='str', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Calculates the MD5 hash of the specified string and returns its hexadecimal representation.', arguments={'str': 'the string to hash.'}, result="Returns the MD5 hash of the input string if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Md5', name='md5', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='md5', return_types=['string'], arguments=[FunctionArgument(name='str', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Calculates the MD5 hash of the specified string and returns its hexadecimal representation.', arguments={'str': 'the string to hash.'}, result="Returns the MD5 hash of the input string if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Md5', name='md5', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='passwordHash', return_types=['string'], arguments=[FunctionArgument(name='password', argument_type='string', default_value=None, optional=False), FunctionArgument(name='algorithm', argument_type='string', default_value=None, optional=False), FunctionArgument(name='options', argument_type='table', default_value=None, optional=False), FunctionArgument(name='callback', argument_type='function', default_value=None, optional=True)]), docs=FunctionDoc(description='This function creates a new password hash using a specified hashing algorithm.\n}}', arguments={'password': 'The password to hash.', 'algorithm': 'The algorithm to use:', 'bcrypt': ': use the bcrypt hashing algorithm. Hash length: 60 characters. <span style=color:red>Note that only the prefix $2y$ is supported (older prefixes can cause security issues).</span>', 'options': 'table with options for the hashing algorithm, as detailed below.\n{{New feature/item|3.0154|1.5.4|11281|', 'callback': 'providing a callback will run this function asynchronously, the arguments to the callback are the same as the returned values below.\n}}'}, result="Returns the hash as a string if hashing was successful, ''false'' otherwise. If a callback was provided, the aforementioned values are arguments to the callback, and this function will always return ''true''."), oop=None, url=FunctionUrl(url='/wiki/PasswordHash', name='passwordHash', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='passwordHash', return_types=['string'], arguments=[FunctionArgument(name='password', argument_type='string', default_value=None, optional=False), FunctionArgument(name='algorithm', argument_type='string', default_value=None, optional=False), FunctionArgument(name='options', argument_type='table', default_value=None, optional=False), FunctionArgument(name='callback', argument_type='function', default_value=None, optional=True)]), docs=FunctionDoc(description='This function creates a new password hash using a specified hashing algorithm.\n}}', arguments={'password': 'The password to hash.', 'algorithm': 'The algorithm to use:', 'bcrypt': ': use the bcrypt hashing algorithm. Hash length: 60 characters. <span style=color:red>Note that only the prefix $2y$ is supported (older prefixes can cause security issues).</span>', 'options': 'table with options for the hashing algorithm, as detailed below.\n{{New feature/item|3.0154|1.5.4|11281|', 'callback': 'providing a callback will run this function asynchronously, the arguments to the callback are the same as the returned values below.\n}}'}, result="Returns the hash as a string if hashing was successful, ''false'' otherwise. If a callback was provided, the aforementioned values are arguments to the callback, and this function will always return ''true''."), oop=None, url=FunctionUrl(url='/wiki/PasswordHash', name='passwordHash', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='passwordVerify', return_types=['bool'], arguments=[FunctionArgument(name='password', argument_type='string', default_value=None, optional=False), FunctionArgument(name='hash', argument_type='string', default_value=None, optional=False), FunctionArgument(name='options', argument_type='table', default_value=None, optional=True), FunctionArgument(name='callback', argument_type='function', default_value=None, optional=True)]), docs=FunctionDoc(description='This function verifies whether a password matches a password hash.\n}}', arguments={'password': 'The password to check.', 'hash': 'A supported hash (see passwordHash). <span style=color:red>Note that only the prefix $2y$ is supported for type bcrypt (older prefixes can cause security issues).</span>\n{{New feature/item|3.0156|1.5.6||', 'options': 'advanced options', 'insecureBcrypt': 'If set to true, you can use the $2a$ prefix for bcrypt hashes as well. It is strongly not recommended to use it though, because the underlying implementation has a bug that leads to such hashes being relatively easy to crack. This bug was fixed for $2y$.\n}}\n{{New feature/item|3.0154|1.5.4|11281|', 'callback': 'providing a callback will run this function asynchronously, the arguments to the callback are the same as the returned values below.\n}}'}, result="Returns true if the password matches the hash. Returns false if the password does not match, or if an unknown hash was passed. If a callback was provided, the aforementioned values are arguments to the callback, and this function will always return ''true''."), oop=None, url=FunctionUrl(url='/wiki/PasswordVerify', name='passwordVerify', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='passwordVerify', return_types=['bool'], arguments=[FunctionArgument(name='password', argument_type='string', default_value=None, optional=False), FunctionArgument(name='hash', argument_type='string', default_value=None, optional=False), FunctionArgument(name='options', argument_type='table', default_value=None, optional=True), FunctionArgument(name='callback', argument_type='function', default_value=None, optional=True)]), docs=FunctionDoc(description='This function verifies whether a password matches a password hash.\n}}', arguments={'password': 'The password to check.', 'hash': 'A supported hash (see passwordHash). <span style=color:red>Note that only the prefix $2y$ is supported for type bcrypt (older prefixes can cause security issues).</span>\n{{New feature/item|3.0156|1.5.6||', 'options': 'advanced options', 'insecureBcrypt': 'If set to true, you can use the $2a$ prefix for bcrypt hashes as well. It is strongly not recommended to use it though, because the underlying implementation has a bug that leads to such hashes being relatively easy to crack. This bug was fixed for $2y$.\n}}\n{{New feature/item|3.0154|1.5.4|11281|', 'callback': 'providing a callback will run this function asynchronously, the arguments to the callback are the same as the returned values below.\n}}'}, result="Returns true if the password matches the hash. Returns false if the password does not match, or if an unknown hash was passed. If a callback was provided, the aforementioned values are arguments to the callback, and this function will always return ''true''."), oop=None, url=FunctionUrl(url='/wiki/PasswordVerify', name='passwordVerify', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='pregFind', return_types=['bool'], arguments=[FunctionArgument(name='subject', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pattern', argument_type='string', default_value=None, optional=False), FunctionArgument(name='string', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='This function stops at the first occurrence of the pattern in the input string and returns the result of the search.\n}}', arguments={'subject': 'The input string', 'pattern': 'The pattern string to search for in the input string.', 'flags': 'Conjuncted value that contains flags ( 1 - ignorecase, 2 - multiline, 4 - dotall, 8 - extended, 16 - unicode ) or ( i - Ignore case, m - Multiline, d - Dotall, e - Extended, u - Unicode )'}, result="Returns ''true'' if the pattern was found in the input string, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/PregFind', name='pregFind', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='pregFind', return_types=['bool'], arguments=[FunctionArgument(name='subject', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pattern', argument_type='string', default_value=None, optional=False), FunctionArgument(name='string', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='This function stops at the first occurrence of the pattern in the input string and returns the result of the search.\n}}', arguments={'subject': 'The input string', 'pattern': 'The pattern string to search for in the input string.', 'flags': 'Conjuncted value that contains flags ( 1 - ignorecase, 2 - multiline, 4 - dotall, 8 - extended, 16 - unicode ) or ( i - Ignore case, m - Multiline, d - Dotall, e - Extended, u - Unicode )'}, result="Returns ''true'' if the pattern was found in the input string, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/PregFind', name='pregFind', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='pregMatch', return_types=['table'], arguments=[FunctionArgument(name='base', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pattern', argument_type='string', default_value=None, optional=False), FunctionArgument(name='string', argument_type='int', default_value=None, optional=True), FunctionArgument(name='maxResults', argument_type='int', default_value='100000', optional=True)]), docs=FunctionDoc(description='This function returns all matches.\n}}', arguments={'base': 'The base string for replace.', 'pattern': 'The pattern for match in base string.', 'flags': 'Conjuncted value that contains flags ( 1 - ignorecase, 2 - multiline, 4 - dotall, 8 - extended, 16 - unicode ) or ( i - Ignore case, m - Multiline, d - Dotall, e - Extended, u - Unicode )', 'maxResults': 'Maximum number of results to return'}, result="Returns a ''[[table]]'' if one or more match is found, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/PregMatch', name='pregMatch', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='pregMatch', return_types=['table'], arguments=[FunctionArgument(name='base', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pattern', argument_type='string', default_value=None, optional=False), FunctionArgument(name='string', argument_type='int', default_value=None, optional=True), FunctionArgument(name='maxResults', argument_type='int', default_value='100000', optional=True)]), docs=FunctionDoc(description='This function returns all matches.\n}}', arguments={'base': 'The base string for replace.', 'pattern': 'The pattern for match in base string.', 'flags': 'Conjuncted value that contains flags ( 1 - ignorecase, 2 - multiline, 4 - dotall, 8 - extended, 16 - unicode ) or ( i - Ignore case, m - Multiline, d - Dotall, e - Extended, u - Unicode )', 'maxResults': 'Maximum number of results to return'}, result="Returns a ''[[table]]'' if one or more match is found, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/PregMatch', name='pregMatch', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='pregReplace', return_types=['string'], arguments=[FunctionArgument(name='subject', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pattern', argument_type='string', default_value=None, optional=False), FunctionArgument(name='replacement', argument_type='string', default_value=None, optional=False), FunctionArgument(name='string', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='This function performs a regular expression search and replace and returns the replaced string.\n}}', arguments={'subject': 'The input string.', 'pattern': 'The pattern string to search for in the input string.', 'replacement': 'The replacement string to replace all matches within the input string.', 'flags': 'Conjuncted value that contains flags ( 1 - ignorecase, 2 - multiline, 4 - dotall, 8 - extended, 16 - unicode ) or ( i - Ignore case, m - Multiline, d - Dotall, e - Extended, u - Unicode )'}, result="Returns the replaced ''[[string]]'', or [[bool]] ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/PregReplace', name='pregReplace', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='pregReplace', return_types=['string'], arguments=[FunctionArgument(name='subject', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pattern', argument_type='string', default_value=None, optional=False), FunctionArgument(name='replacement', argument_type='string', default_value=None, optional=False), FunctionArgument(name='string', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='This function performs a regular expression search and replace and returns the replaced string.\n}}', arguments={'subject': 'The input string.', 'pattern': 'The pattern string to search for in the input string.', 'replacement': 'The replacement string to replace all matches within the input string.', 'flags': 'Conjuncted value that contains flags ( 1 - ignorecase, 2 - multiline, 4 - dotall, 8 - extended, 16 - unicode ) or ( i - Ignore case, m - Multiline, d - Dotall, e - Extended, u - Unicode )'}, result="Returns the replaced ''[[string]]'', or [[bool]] ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/PregReplace', name='pregReplace', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removeDebugHook', return_types=['bool'], arguments=[FunctionArgument(name='hookType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='callbackFunction', argument_type='function', default_value=None, optional=False)]), docs=FunctionDoc(description='This function removes hooks added by [[addDebugHook]]\n}}', arguments={'hookType': 'The type of hook to remove. This can be:\n** preEvent\n** postEvent\n** preFunction\n** postFunction', 'callbackFunction ': 'The callback function to remove'}, result="Returns ''true'' if the hook was successfully removed, or ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/RemoveDebugHook', name='removeDebugHook', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='removeDebugHook', return_types=['bool'], arguments=[FunctionArgument(name='hookType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='callbackFunction', argument_type='function', default_value=None, optional=False)]), docs=FunctionDoc(description='This function removes hooks added by [[addDebugHook]]\n}}', arguments={'hookType': 'The type of hook to remove. This can be:\n** preEvent\n** postEvent\n** preFunction\n** postFunction', 'callbackFunction ': 'The callback function to remove'}, result="Returns ''true'' if the hook was successfully removed, or ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/RemoveDebugHook', name='removeDebugHook', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetTimer', return_types=['bool'], arguments=[FunctionArgument(name='theTimer', argument_type='timer', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows you to reset the elapsed time in existing timers to zero. The function does not reset the 'times to execute' count on timers which have a limited amout of repetitions.", arguments={'theTimer': 'The timer whose elapsed time you wish to reset.'}, result="Returns ''true'' if the timer was successfully reset, ''false'' otherwise."), oop=FunctionOOP(class_name='timer', method_name='reset', field=None), url=FunctionUrl(url='/wiki/ResetTimer', name='resetTimer', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='resetTimer', return_types=['bool'], arguments=[FunctionArgument(name='theTimer', argument_type='timer', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows you to reset the elapsed time in existing timers to zero. The function does not reset the 'times to execute' count on timers which have a limited amout of repetitions.", arguments={'theTimer': 'The timer whose elapsed time you wish to reset.'}, result="Returns ''true'' if the timer was successfully reset, ''false'' otherwise."), oop=FunctionOOP(class_name='timer', method_name='reset', field=None), url=FunctionUrl(url='/wiki/ResetTimer', name='resetTimer', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setClipboard', return_types=['bool'], arguments=[FunctionArgument(name='theText', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the players clipboard text (what appears when you paste with CTRL + V) Note that there is no getClipBoard function for safety reasons.', arguments={'theText': 'The new text to be in the players clipboard when the player pastes with CTRL + V.'}, result="Returns ''true'' if the text in the clip board was set correctly."), oop=None, url=FunctionUrl(url='/wiki/SetClipboard', name='setClipboard', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setDevelopmentMode', return_types=['bool'], arguments=[FunctionArgument(name='enable', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='enableWeb', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="This function is used to set the development mode. Setting development mode allows access to special commands which can assist with script debugging.\n'''Client-side''' development mode commands:\n* '''[[Client_Commands#showcol|showcol]]''': Enables colshapes to be viewed as a wireframe object.\n* '''[[Client_Commands#showsound|showsound]]''': Enables world sound ids to be printed in the debug output window.\n'''Shared''' development mode functions:\n* '''[[debugSleep]]''': Sets the freeze time for the client/server.", arguments={'enable': ': A boolean to indicate whether development mode is on (true) or off (false)\n{{New feature/item|3.0150|1.5||', 'enableWeb': ': A boolean to indicate whether browser debug messages will be filtered (false) or not (true)\n}}'}, result="Returns ''true'' if the mode was set correctly, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetDevelopmentMode', name='setDevelopmentMode', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setDevelopmentMode', return_types=['bool'], arguments=[FunctionArgument(name='enable', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='enableWeb', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="This function is used to set the development mode. Setting development mode allows access to special commands which can assist with script debugging.\n'''Client-side''' development mode commands:\n* '''[[Client_Commands#showcol|showcol]]''': Enables colshapes to be viewed as a wireframe object.\n* '''[[Client_Commands#showsound|showsound]]''': Enables world sound ids to be printed in the debug output window.\n'''Shared''' development mode functions:\n* '''[[debugSleep]]''': Sets the freeze time for the client/server.", arguments={'enable': ': A boolean to indicate whether development mode is on (true) or off (false)\n{{New feature/item|3.0150|1.5||', 'enableWeb': ': A boolean to indicate whether browser debug messages will be filtered (false) or not (true)\n}}'}, result="Returns ''true'' if the mode was set correctly, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetDevelopmentMode', name='setDevelopmentMode', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setFPSLimit', return_types=['bool'], arguments=[FunctionArgument(name='fpsLimit', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the maximum [http://en.wikipedia.org/wiki/Frame_rate FPS (Frames per second)] that players on the server can run their game at.  ', arguments={'fpsLimit': 'An integer value representing the maximum FPS. This value may be between 25 and 100 FPS. You can also pass 0 or false, in which case the FPS limit will be the one set in the client settings (by default, 100 FPS and the client fps limit should also be manually changed via fps_limit=0 in console or MTA San Andreas 1.5\\MTA\\config\\coreconfig.xml).'}, result="Returns ''true'' if successful, or ''false'' if it was not possible to set the limit or an invalid value was passed."), oop=None, url=FunctionUrl(url='/wiki/SetFPSLimit', name='setFPSLimit', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setFPSLimit', return_types=['bool'], arguments=[FunctionArgument(name='fpsLimit', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the maximum [http://en.wikipedia.org/wiki/Frame_rate FPS (Frames per second)] that players on the server can run their game at.  ', arguments={'fpsLimit': 'An integer value representing the maximum FPS. This value may be between 25 and 100 FPS. You can also pass 0 or false, in which case the FPS limit will be the one set in the client settings (by default, 100 FPS and the client fps limit should also be manually changed via fps_limit=0 in console or MTA San Andreas 1.5\\MTA\\config\\coreconfig.xml).'}, result="Returns ''true'' if successful, or ''false'' if it was not possible to set the limit or an invalid value was passed."), oop=None, url=FunctionUrl(url='/wiki/SetFPSLimit', name='setFPSLimit', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setTransferBoxVisible', return_types=['bool'], arguments=[FunctionArgument(name='visible', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'visible': 'The new visibility state.'}, result="Returns ''true'' if the visibility was set successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetTransferBoxVisible', name='setTransferBoxVisible', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setTransferBoxVisible', return_types=['bool'], arguments=[FunctionArgument(name='visible', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'visible': 'The new visibility state.'}, result="Returns ''true'' if the visibility was set successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetTransferBoxVisible', name='setTransferBoxVisible', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setWindowFlashing', return_types=['bool'], arguments=[FunctionArgument(name='shouldFlash', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='count', argument_type='int', default_value='10', optional=True)]), docs=FunctionDoc(description='', arguments={}, result=''), oop=None, url=FunctionUrl(url='/wiki/SetWindowFlashing', name='setWindowFlashing', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='sha256', return_types=['string'], arguments=[FunctionArgument(name='str', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="* The sha module and this function may conflict with eachother, if you use this function uninstall the module!\n* This function returns an uppercase string, so make sure you string.upper() anything else you are checking against that has been sha256'd elsewhere.}}\nCalculates the sha256 hash of the specified string.", arguments={'str': 'the string to hash.'}, result="Returns the sha256 hash of the input string if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Sha256', name='sha256', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='sha256', return_types=['string'], arguments=[FunctionArgument(name='str', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="* The sha module and this function may conflict with eachother, if you use this function uninstall the module!\n* This function returns an uppercase string, so make sure you string.upper() anything else you are checking against that has been sha256'd elsewhere.}}\nCalculates the sha256 hash of the specified string.", arguments={'str': 'the string to hash.'}, result="Returns the sha256 hash of the input string if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Sha256', name='sha256', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='split', return_types=['table'], arguments=[FunctionArgument(name='stringToSplit', argument_type='string', default_value=None, optional=False), FunctionArgument(name='int', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function splits a string into substrings. You specify a character that will act as a separating character; this will determine where to split the sub-strings. For example, it can split the string "Hello World" into two strings containing the two words, by spliting using a space as a separator.\n\'\'\'Note:\'\'\' You can use the function [[gettok]] to retrieve a single token from the string at a specific index. This may be faster for one-off lookups, but considerably slower if you are going to check each token in a long string.', arguments={'stringToSplit': 'The string you wish to split into parts.', 'separatingChar': 'A string of the character you want to split, or the ASCII|ASCII number representing the character you want to use to split.'}, result='Returns a \'\'table\'\' of substrings split from the original string if successful, \'\'false\'\' otherwise.\n{{note|Unicode characters work but when combined with others do not. E.g: #split("a€cb†", "€") returns 3 but #split("a€cb", "€") returns 2.\n}}\n{{note|You can\'t use same char twice as a separator. Eg.:  ||, ||| are the same as |.\n}}'), oop=None, url=FunctionUrl(url='/wiki/Split', name='split', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='split', return_types=['table'], arguments=[FunctionArgument(name='stringToSplit', argument_type='string', default_value=None, optional=False), FunctionArgument(name='int', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function splits a string into substrings. You specify a character that will act as a separating character; this will determine where to split the sub-strings. For example, it can split the string "Hello World" into two strings containing the two words, by spliting using a space as a separator.\n\'\'\'Note:\'\'\' You can use the function [[gettok]] to retrieve a single token from the string at a specific index. This may be faster for one-off lookups, but considerably slower if you are going to check each token in a long string.', arguments={'stringToSplit': 'The string you wish to split into parts.', 'separatingChar': 'A string of the character you want to split, or the ASCII|ASCII number representing the character you want to use to split.'}, result='Returns a \'\'table\'\' of substrings split from the original string if successful, \'\'false\'\' otherwise.\n{{note|Unicode characters work but when combined with others do not. E.g: #split("a€cb†", "€") returns 3 but #split("a€cb", "€") returns 2.\n}}\n{{note|You can\'t use same char twice as a separator. Eg.:  ||, ||| are the same as |.\n}}'), oop=None, url=FunctionUrl(url='/wiki/Split', name='split', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='teaDecode', return_types=['string'], arguments=[FunctionArgument(name='data', argument_type='string', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function decrypts given [https://en.wikipedia.org/wiki/Base64 base64] representation of encrypted data using the [https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm Tiny Encryption Algorithm].\n}}', arguments={'data': 'The block of data you want to decrypt', 'key': 'The key that should be used for decryption (Only first 16 characters are used)'}, result="Returns string containing the decrypted data if the decryption process was successfully completed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/TeaDecode', name='teaDecode', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='teaEncode', return_types=['string'], arguments=[FunctionArgument(name='text', argument_type='string', default_value=None, optional=False), FunctionArgument(name='key', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This functions performs the [https://en.wikipedia.org/wiki/Tiny_Encryption_Algorithm Tiny Encryption Algorithm] on the given string and returns the [https://en.wikipedia.org/wiki/Base64 base64] representation of the encrypted string.\n}}', arguments={'text': 'The string you want to encrypt. (See second example if you want to encode binary data)', 'key': 'The key that should be used for encryption (Only first 16 characters are used)'}, result="Returns the [https://en.wikipedia.org/wiki/Base64 base64] representation of the encrypted string if the encryption process was successfully completed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/TeaEncode', name='teaEncode', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='tocolor', return_types=['int'], arguments=[FunctionArgument(name='red', argument_type='int', default_value=None, optional=False), FunctionArgument(name='green', argument_type='int', default_value=None, optional=False), FunctionArgument(name='blue', argument_type='int', default_value=None, optional=False), FunctionArgument(name='alpha', argument_type='int', default_value='255', optional=True)]), docs=FunctionDoc(description='This function retrieves the hex number of a specified color, useful for the dx functions.', arguments={'red': 'The amount of http://en.wikipedia.org/wiki/RGBA_color_space red in the color (0-255).', 'green': 'The amount of http://en.wikipedia.org/wiki/RGBA_color_space green in the color (0-255).', 'blue': 'The amount of http://en.wikipedia.org/wiki/RGBA_color_space blue in the color (0-255).', 'alpha': 'The amount of http://en.wikipedia.org/wiki/RGBA_color_space alpha in the color (0-255).'}, result='Returns a single value representing the color.'), oop=None, url=FunctionUrl(url='/wiki/Tocolor', name='tocolor', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='tocolor', return_types=['int'], arguments=[FunctionArgument(name='red', argument_type='int', default_value=None, optional=False), FunctionArgument(name='green', argument_type='int', default_value=None, optional=False), FunctionArgument(name='blue', argument_type='int', default_value=None, optional=False), FunctionArgument(name='alpha', argument_type='int', default_value='255', optional=True)]), docs=FunctionDoc(description='This function retrieves the hex number of a specified color, useful for the dx functions.', arguments={'red': 'The amount of http://en.wikipedia.org/wiki/RGBA_color_space red in the color (0-255).', 'green': 'The amount of http://en.wikipedia.org/wiki/RGBA_color_space green in the color (0-255).', 'blue': 'The amount of http://en.wikipedia.org/wiki/RGBA_color_space blue in the color (0-255).', 'alpha': 'The amount of http://en.wikipedia.org/wiki/RGBA_color_space alpha in the color (0-255).'}, result='Returns a single value representing the color.'), oop=None, url=FunctionUrl(url='/wiki/Tocolor', name='tocolor', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='toJSON', return_types=['string'], arguments=[FunctionArgument(name='value', argument_type='var', default_value=None, optional=False), FunctionArgument(name='compact', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='prettyType', argument_type='string', default_value='"none"', optional=True)]), docs=FunctionDoc(description="This function converts a '''single''' value (preferably a Lua table) into a [[JSON]] encoded string. You can use this to store the data and then load it again using [[fromJSON]].", arguments={'var': 'An argument of any type. Arguments that are elements will be stored as element IDs that are liable to change between sessions. As such, do not save elements across sessions as you will get unpredictable results.\n{{OptionalArg}} \n{{New feature/item|3.0150|1.5||', 'compact': 'a boolean representing whether the string will contain whitespaces. To remove whitespaces from JSON string, use true. String will contain whitespaces per default.\n}}\n{{New feature/item|3.0154|1.5.3|8046|', 'prettyType': 'a type string from below:\n** none\n** spaces\n** tabs\n}}'}, result='Returns a JSON formatted string.'), oop=None, url=FunctionUrl(url='/wiki/ToJSON', name='toJSON', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='toJSON', return_types=['string'], arguments=[FunctionArgument(name='value', argument_type='var', default_value=None, optional=False), FunctionArgument(name='compact', argument_type='bool', default_value='false', optional=True), FunctionArgument(name='prettyType', argument_type='string', default_value='"none"', optional=True)]), docs=FunctionDoc(description="This function converts a '''single''' value (preferably a Lua table) into a [[JSON]] encoded string. You can use this to store the data and then load it again using [[fromJSON]].", arguments={'var': 'An argument of any type. Arguments that are elements will be stored as element IDs that are liable to change between sessions. As such, do not save elements across sessions as you will get unpredictable results.\n{{OptionalArg}} \n{{New feature/item|3.0150|1.5||', 'compact': 'a boolean representing whether the string will contain whitespaces. To remove whitespaces from JSON string, use true. String will contain whitespaces per default.\n}}\n{{New feature/item|3.0154|1.5.3|8046|', 'prettyType': 'a type string from below:\n** none\n** spaces\n** tabs\n}}'}, result='Returns a JSON formatted string.'), oop=None, url=FunctionUrl(url='/wiki/ToJSON', name='toJSON', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='utfChar', return_types=['string'], arguments=[FunctionArgument(name='characterCode', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='The function returns the string of the specified UTF code.', arguments={'characterCode': 'The UTF code, to get the string of.'}, result="Returns a ''[[string]]'' if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/UtfChar', name='utfChar', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='utfChar', return_types=['string'], arguments=[FunctionArgument(name='characterCode', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='The function returns the string of the specified UTF code.', arguments={'characterCode': 'The UTF code, to get the string of.'}, result="Returns a ''[[string]]'' if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/UtfChar', name='utfChar', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='utfCode', return_types=['int'], arguments=[FunctionArgument(name='theString', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='The function returns the UTF codes of the given string.', arguments={'theString': 'The string to get the UTF code of.'}, result="Returns an ''[[int]]'' if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/UtfCode', name='utfCode', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='utfCode', return_types=['int'], arguments=[FunctionArgument(name='theString', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='The function returns the UTF codes of the given string.', arguments={'theString': 'The string to get the UTF code of.'}, result="Returns an ''[[int]]'' if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/UtfCode', name='utfCode', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='utfLen', return_types=['int'], arguments=[FunctionArgument(name='theString', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='The function gets the real length of a string, in characters.', arguments={'theString': 'The string to get the length of.'}, result="Returns an ''[[int]]'' if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/UtfLen', name='utfLen', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='utfLen', return_types=['int'], arguments=[FunctionArgument(name='theString', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='The function gets the real length of a string, in characters.', arguments={'theString': 'The string to get the length of.'}, result="Returns an ''[[int]]'' if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/UtfLen', name='utfLen', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='utfSeek', return_types=['int'], arguments=[FunctionArgument(name='theString', argument_type='string', default_value=None, optional=False), FunctionArgument(name='position', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='The function returns the byte position at specified character position.', arguments={'theString': 'The string.', 'position': 'An int with the specified charachter position.'}, result="Returns an ''[[int]]'' if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/UtfSeek', name='utfSeek', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='utfSeek', return_types=['int'], arguments=[FunctionArgument(name='theString', argument_type='string', default_value=None, optional=False), FunctionArgument(name='position', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='The function returns the byte position at specified character position.', arguments={'theString': 'The string.', 'position': 'An int with the specified charachter position.'}, result="Returns an ''[[int]]'' if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/UtfSeek', name='utfSeek', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='utfSub', return_types=['string'], arguments=[FunctionArgument(name='theString', argument_type='string', default_value=None, optional=False), FunctionArgument(name='Start', argument_type='int', default_value=None, optional=False), FunctionArgument(name='End', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='The function returns a sub string, from the specified positions on a character.', arguments={'theString': 'The string.', 'Start': 'An int with the start position.', 'End': 'An int with the end position.'}, result="Returns a ''[[string]]'' if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/UtfSub', name='utfSub', category='Utility functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='utfSub', return_types=['string'], arguments=[FunctionArgument(name='theString', argument_type='string', default_value=None, optional=False), FunctionArgument(name='Start', argument_type='int', default_value=None, optional=False), FunctionArgument(name='End', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='The function returns a sub string, from the specified positions on a character.', arguments={'theString': 'The string.', 'Start': 'An int with the start position.', 'End': 'An int with the end position.'}, result="Returns a ''[[string]]'' if the function was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/UtfSub', name='utfSub', category='Utility functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='byte', return_types=['int,...', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='i', argument_type='int', default_value='1', optional=True), FunctionArgument(name='j', argument_type='int', default_value='1', optional=True)]), docs=FunctionDoc(description='Returns the codepoints for the i-th through j-th character of the string passed.', arguments={'input': 'A string character sequence\n{{OptionalArg}}', 'i': 'An integer representing the beginning position.', 'j': 'An integer representing the ending position.'}, result="Returns a sequence of ''integer'' values from the original string if successful, ''nil'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Utf8.byte', name='utf8.byte', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='byte', return_types=['int,...', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='i', argument_type='int', default_value='1', optional=True), FunctionArgument(name='j', argument_type='int', default_value='1', optional=True)]), docs=FunctionDoc(description='Returns the codepoints for the i-th through j-th character of the string passed.', arguments={'input': 'A string character sequence\n{{OptionalArg}}', 'i': 'An integer representing the beginning position.', 'j': 'An integer representing the ending position.'}, result="Returns a sequence of ''integer'' values from the original string if successful, ''nil'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Utf8.byte', name='utf8.byte', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='char', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='Generates a string representing the character codepoints as arguments.', arguments={'codepoints': 'An variable argument sequence of code points representing the desired unicode characters.'}, result="Returns a ''string'' representation of the codepoints passed."), oop=None, url=FunctionUrl(url='/wiki/Utf8.char', name='utf8.char', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='char', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='...args', argument_type='any[]', default_value=None, optional=True)]), docs=FunctionDoc(description='Generates a string representing the character codepoints as arguments.', arguments={'codepoints': 'An variable argument sequence of code points representing the desired unicode characters.'}, result="Returns a ''string'' representation of the codepoints passed."), oop=None, url=FunctionUrl(url='/wiki/Utf8.char', name='utf8.char', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='charpos', return_types=['int,', 'int', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='charpos', argument_type='int', default_value='0', optional=True), FunctionArgument(name='offset', argument_type='int', default_value='1', optional=True)]), docs=FunctionDoc(description='Converts the UTF-8 codepoint position to byte-string position.', arguments={'input': 'A string character sequence\n{{OptionalArg}}', 'charpos': 'An integer representing the beginning position (offset will be added/subtracted).', 'offset': 'An integer representing the offset to charpos.'}, result="Returns the ''integer'' position as in a byte string and the ''integer'' codepoint at this position, ''nil'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Utf8.charpos', name='utf8.charpos', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='charpos', return_types=['int,', 'int', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='charpos', argument_type='int', default_value='0', optional=True), FunctionArgument(name='offset', argument_type='int', default_value='1', optional=True)]), docs=FunctionDoc(description='Converts the UTF-8 codepoint position to byte-string position.', arguments={'input': 'A string character sequence\n{{OptionalArg}}', 'charpos': 'An integer representing the beginning position (offset will be added/subtracted).', 'offset': 'An integer representing the offset to charpos.'}, result="Returns the ''integer'' position as in a byte string and the ''integer'' codepoint at this position, ''nil'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Utf8.charpos', name='utf8.charpos', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='escape', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Escapes a string to a UTF-8 format string. It supports several escape formats, see the formatting table.', arguments={'input': 'A string character sequence'}, result="Returns a ''string'' containing the escaped UTF-8 characters from the original string."), oop=None, url=FunctionUrl(url='/wiki/Utf8.escape', name='utf8.escape', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='escape', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Escapes a string to a UTF-8 format string. It supports several escape formats, see the formatting table.', arguments={'input': 'A string character sequence'}, result="Returns a ''string'' containing the escaped UTF-8 characters from the original string."), oop=None, url=FunctionUrl(url='/wiki/Utf8.escape', name='utf8.escape', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='find', return_types=['int,', 'int', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pattern', argument_type='string', default_value=None, optional=False), FunctionArgument(name='startpos', argument_type='int', default_value='1', optional=True), FunctionArgument(name='plain', argument_type='boolean', default_value='false', optional=True)]), docs=FunctionDoc(description='Finds the first occurrence of the [http://lua-users.org/wiki/PatternsTutorial pattern] in the string passed. If an instance of the pattern is found, a pair of values representing the start and the end of the matched string is returned.', arguments={'input': 'A string character sequence', 'pattern': 'A string match http://lua-users.org/wiki/PatternsTutorial pattern (you can disable pattern matching by using the optional fourth argument plain)\n{{OptionalArg}}', 'startpos': 'An integer representing the beginning position.', 'plain': 'A boolean, if pattern matching should be turned off'}, result="Returns two ''number'' values for the beginning and ending position of the matched string, ''nil'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Utf8.find', name='utf8.find', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='find', return_types=['int,', 'int', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pattern', argument_type='string', default_value=None, optional=False), FunctionArgument(name='startpos', argument_type='int', default_value='1', optional=True), FunctionArgument(name='plain', argument_type='boolean', default_value='false', optional=True)]), docs=FunctionDoc(description='Finds the first occurrence of the [http://lua-users.org/wiki/PatternsTutorial pattern] in the string passed. If an instance of the pattern is found, a pair of values representing the start and the end of the matched string is returned.', arguments={'input': 'A string character sequence', 'pattern': 'A string match http://lua-users.org/wiki/PatternsTutorial pattern (you can disable pattern matching by using the optional fourth argument plain)\n{{OptionalArg}}', 'startpos': 'An integer representing the beginning position.', 'plain': 'A boolean, if pattern matching should be turned off'}, result="Returns two ''number'' values for the beginning and ending position of the matched string, ''nil'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Utf8.find', name='utf8.find', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='lower', return_types=['string|int', 'utf8.'], arguments=[FunctionArgument(name='int', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="Converts a UTF-8 string to folded case (lowercase), which can be used to compare two strings. If ''input'' is an integer, it's treat as a codepoint and a convert codepoint (integer) is returned.", arguments={'input': 'A string character sequence OR an integer value'}, result="Returns a ''string'' in lowercase OR returns an ''integer'' (see description)."), oop=None, url=FunctionUrl(url='/wiki/Utf8.fold', name='utf8.fold', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='lower', return_types=['string|int', 'utf8.'], arguments=[FunctionArgument(name='int', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="Converts a UTF-8 string to folded case (lowercase), which can be used to compare two strings. If ''input'' is an integer, it's treat as a codepoint and a convert codepoint (integer) is returned.", arguments={'input': 'A string character sequence OR an integer value'}, result="Returns a ''string'' in lowercase OR returns an ''integer'' (see description)."), oop=None, url=FunctionUrl(url='/wiki/Utf8.fold', name='utf8.fold', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='gmatch', return_types=['iterator', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pattern', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function returns a pattern finding iterator for UTF-8 strings. The iterator will search through the string '''input''' looking for instances of the pattern you passed. For more information on iterators read the [http://lua-users.org/wiki/ForTutorial ForTutorial] and [http://lua-users.org/wiki/IteratorsTutorial IteratorsTutorial].", arguments={'input': 'A string character sequence', 'pattern': 'A string match http://lua-users.org/wiki/PatternsTutorial pattern'}, result="Returns an ''function'' for iterations on the '''input''' string by using the passed '''pattern''' string."), oop=None, url=FunctionUrl(url='/wiki/Utf8.gmatch', name='utf8.gmatch', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='gmatch', return_types=['iterator', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pattern', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function returns a pattern finding iterator for UTF-8 strings. The iterator will search through the string '''input''' looking for instances of the pattern you passed. For more information on iterators read the [http://lua-users.org/wiki/ForTutorial ForTutorial] and [http://lua-users.org/wiki/IteratorsTutorial IteratorsTutorial].", arguments={'input': 'A string character sequence', 'pattern': 'A string match http://lua-users.org/wiki/PatternsTutorial pattern'}, result="Returns an ''function'' for iterations on the '''input''' string by using the passed '''pattern''' string."), oop=None, url=FunctionUrl(url='/wiki/Utf8.gmatch', name='utf8.gmatch', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='gsub', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pattern', argument_type='string', default_value=None, optional=False), FunctionArgument(name='replace', argument_type='mixed', default_value=None, optional=False), FunctionArgument(name='match', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='Returns a copy of the original input string with replaced matches from the pattern by the replacement value.', arguments={'input': 'A string character sequence', 'pattern': 'A string match http://lua-users.org/wiki/PatternsTutorial pattern', 'replace': 'A string literal OR an integer value OR a function (see examples below) OR a table ({ match = replacement })\n{{OptionalArg}}', 'match_limit': 'An integer to limit the number of substitutions made'}, result="Returns a pair of values, the modified ''string'' and the ''integer'' number of substitutions made."), oop=None, url=FunctionUrl(url='/wiki/Utf8.gsub', name='utf8.gsub', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='gsub', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pattern', argument_type='string', default_value=None, optional=False), FunctionArgument(name='replace', argument_type='mixed', default_value=None, optional=False), FunctionArgument(name='match', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='Returns a copy of the original input string with replaced matches from the pattern by the replacement value.', arguments={'input': 'A string character sequence', 'pattern': 'A string match http://lua-users.org/wiki/PatternsTutorial pattern', 'replace': 'A string literal OR an integer value OR a function (see examples below) OR a table ({ match = replacement })\n{{OptionalArg}}', 'match_limit': 'An integer to limit the number of substitutions made'}, result="Returns a pair of values, the modified ''string'' and the ''integer'' number of substitutions made."), oop=None, url=FunctionUrl(url='/wiki/Utf8.gsub', name='utf8.gsub', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='insert', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='insert', argument_type='int', default_value=None, optional=True), FunctionArgument(name='substring', argument_type='string', default_value=None, optional=True)]), docs=FunctionDoc(description='Inserts a substring into input string. If insert-position is given, the substring will be inserted before the character at this index, otherwise the substring will concatenate to input. The insert position may be negative.', arguments={'input': 'A string character sequence', 'substring': 'A string character sequence which should be inserted\n{{OptionalArg}}', 'insert_pos': 'An integer representing the position, where the substring will be inserted at.'}, result="Returns a ''string'' with the inserted substring value."), oop=None, url=FunctionUrl(url='/wiki/Utf8.insert', name='utf8.insert', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='insert', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='insert', argument_type='int', default_value=None, optional=True), FunctionArgument(name='substring', argument_type='string', default_value=None, optional=True)]), docs=FunctionDoc(description='Inserts a substring into input string. If insert-position is given, the substring will be inserted before the character at this index, otherwise the substring will concatenate to input. The insert position may be negative.', arguments={'input': 'A string character sequence', 'substring': 'A string character sequence which should be inserted\n{{OptionalArg}}', 'insert_pos': 'An integer representing the position, where the substring will be inserted at.'}, result="Returns a ''string'' with the inserted substring value."), oop=None, url=FunctionUrl(url='/wiki/Utf8.insert', name='utf8.insert', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='len', return_types=['int', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='i', argument_type='int', default_value='1', optional=True), FunctionArgument(name='j', argument_type='int', default_value='utf8.len( input', optional=True)]), docs=FunctionDoc(description='Returns the length of the string passed.', arguments={'input': 'A string character sequence\n{{OptionalArg}}', 'i': 'An integer representing the beginning position for measuring the length of the section (may be negative).', 'j': 'An integer representing the ending position for measuring the length of the section (may be negative).'}, result="Returns the length of the string as an ''integer''."), oop=None, url=FunctionUrl(url='/wiki/Utf8.len', name='utf8.len', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='len', return_types=['int', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='i', argument_type='int', default_value='1', optional=True), FunctionArgument(name='j', argument_type='int', default_value='utf8.len( input', optional=True)]), docs=FunctionDoc(description='Returns the length of the string passed.', arguments={'input': 'A string character sequence\n{{OptionalArg}}', 'i': 'An integer representing the beginning position for measuring the length of the section (may be negative).', 'j': 'An integer representing the ending position for measuring the length of the section (may be negative).'}, result="Returns the length of the string as an ''integer''."), oop=None, url=FunctionUrl(url='/wiki/Utf8.len', name='utf8.len', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='match', return_types=['string,...', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pattern', argument_type='string', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value='1', optional=True)]), docs=FunctionDoc(description='Extract substrings by matching patterns in the input string. This function can be used to extract specific information from a string.', arguments={'input': 'A string character sequence', 'pattern': 'A string match http://lua-users.org/wiki/PatternsTutorial pattern\n{{OptionalArg}}', 'index': 'An integer representing the beginning position for the pattern matching'}, result="Returns a sequence of ''string'' matches from the '''input''' string, ''nil'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Utf8.match', name='utf8.match', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='match', return_types=['string,...', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='pattern', argument_type='string', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value='1', optional=True)]), docs=FunctionDoc(description='Extract substrings by matching patterns in the input string. This function can be used to extract specific information from a string.', arguments={'input': 'A string character sequence', 'pattern': 'A string match http://lua-users.org/wiki/PatternsTutorial pattern\n{{OptionalArg}}', 'index': 'An integer representing the beginning position for the pattern matching'}, result="Returns a sequence of ''string'' matches from the '''input''' string, ''nil'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Utf8.match', name='utf8.match', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='ncasecmp', return_types=['int', 'utf8.'], arguments=[FunctionArgument(name='a', argument_type='string', default_value=None, optional=False), FunctionArgument(name='b', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Compares two strings in lower-case and returns the difference indicator (see table below) as an integer value.', arguments={'a': 'A string character sequence', 'b': 'A string character sequence'}, result="Returns an ''integer'', which indicates the difference, see the table below for further information."), oop=None, url=FunctionUrl(url='/wiki/Utf8.ncasecmp', name='utf8.ncasecmp', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='ncasecmp', return_types=['int', 'utf8.'], arguments=[FunctionArgument(name='a', argument_type='string', default_value=None, optional=False), FunctionArgument(name='b', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Compares two strings in lower-case and returns the difference indicator (see table below) as an integer value.', arguments={'a': 'A string character sequence', 'b': 'A string character sequence'}, result="Returns an ''integer'', which indicates the difference, see the table below for further information."), oop=None, url=FunctionUrl(url='/wiki/Utf8.ncasecmp', name='utf8.ncasecmp', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='next', return_types=['int,', 'int', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='charpos', argument_type='int', default_value='0', optional=True), FunctionArgument(name='offset', argument_type='int', default_value='1', optional=True)]), docs=FunctionDoc(description='This is an iteration function to traverse each single codepoint of a UTF-8 string.', arguments={'input': 'A string character sequence\n{{OptionalArg}}', 'charpos': 'An integer representing the beginning position (offset will be added/subtracted).', 'offset': 'An integer representing the offset to charpos.'}, result="Returns the ''integer'' position in bytes and the ''integer'' codepoint at this position, ''nil'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Utf8.next', name='utf8.next', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='next', return_types=['int,', 'int', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='charpos', argument_type='int', default_value='0', optional=True), FunctionArgument(name='offset', argument_type='int', default_value='1', optional=True)]), docs=FunctionDoc(description='This is an iteration function to traverse each single codepoint of a UTF-8 string.', arguments={'input': 'A string character sequence\n{{OptionalArg}}', 'charpos': 'An integer representing the beginning position (offset will be added/subtracted).', 'offset': 'An integer representing the offset to charpos.'}, result="Returns the ''integer'' position in bytes and the ''integer'' codepoint at this position, ''nil'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/Utf8.next', name='utf8.next', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='remove', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='start', argument_type='int', default_value='1 [', optional=False), FunctionArgument(name='stop', argument_type='int', default_value='-1', optional=True)]), docs=FunctionDoc(description='This function removes a substring in a UTF-8 string by using a position range.', arguments={'input': 'A string character sequence', 'start': 'An integer representing the beginning position.\n{{OptionalArg}}', 'stop': 'An integer representing the ending position.'}, result="Returns the ''string'' with the removed substring from the range."), oop=None, url=FunctionUrl(url='/wiki/Utf8.remove', name='utf8.remove', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='remove', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='start', argument_type='int', default_value='1 [', optional=False), FunctionArgument(name='stop', argument_type='int', default_value='-1', optional=True)]), docs=FunctionDoc(description='This function removes a substring in a UTF-8 string by using a position range.', arguments={'input': 'A string character sequence', 'start': 'An integer representing the beginning position.\n{{OptionalArg}}', 'stop': 'An integer representing the ending position.'}, result="Returns the ''string'' with the removed substring from the range."), oop=None, url=FunctionUrl(url='/wiki/Utf8.remove', name='utf8.remove', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='reverse', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Reverses the input string.', arguments={'input': 'A string character sequence'}, result="Returns a ''string'' containing the reversed original UTF-8 string."), oop=None, url=FunctionUrl(url='/wiki/Utf8.reverse', name='utf8.reverse', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='reverse', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Reverses the input string.', arguments={'input': 'A string character sequence'}, result="Returns a ''string'' containing the reversed original UTF-8 string."), oop=None, url=FunctionUrl(url='/wiki/Utf8.reverse', name='utf8.reverse', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='sub', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='i', argument_type='int', default_value='1', optional=True), FunctionArgument(name='j', argument_type='int', default_value='utf8.len( input', optional=True)]), docs=FunctionDoc(description="Returns a substring of the string passed. The substring starts at ''i''. If the third argument ''j'' is not given, the substring will end at the end of the string. If the third argument is given, the substring ends at and includes ''j''.", arguments={'input': 'A string character sequence\n{{OptionalArg}}', 'i': 'An integer representing the beginning position (may be negative).', 'j': 'An integer representing the ending position (may be negative).'}, result="Returns a ''string'' substring of the original string, containing the selected range from the original string."), oop=None, url=FunctionUrl(url='/wiki/Utf8.sub', name='utf8.sub', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='sub', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='i', argument_type='int', default_value='1', optional=True), FunctionArgument(name='j', argument_type='int', default_value='utf8.len( input', optional=True)]), docs=FunctionDoc(description="Returns a substring of the string passed. The substring starts at ''i''. If the third argument ''j'' is not given, the substring will end at the end of the string. If the third argument is given, the substring ends at and includes ''j''.", arguments={'input': 'A string character sequence\n{{OptionalArg}}', 'i': 'An integer representing the beginning position (may be negative).', 'j': 'An integer representing the ending position (may be negative).'}, result="Returns a ''string'' substring of the original string, containing the selected range from the original string."), oop=None, url=FunctionUrl(url='/wiki/Utf8.sub', name='utf8.sub', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='upper', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='int', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="Converts a UTF-8 string to title case (uppercase). If ''input'' is an integer, it is treated as a codepoint and a converted codepoint (integer) is returned.", arguments={'input': 'A string character sequence OR an integer value'}, result="Returns a ''string'' in uppercase OR returns an ''integer'' (see description)."), oop=None, url=FunctionUrl(url='/wiki/Utf8.title', name='utf8.title', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='upper', return_types=['string', 'utf8.'], arguments=[FunctionArgument(name='int', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="Converts a UTF-8 string to title case (uppercase). If ''input'' is an integer, it is treated as a codepoint and a converted codepoint (integer) is returned.", arguments={'input': 'A string character sequence OR an integer value'}, result="Returns a ''string'' in uppercase OR returns an ''integer'' (see description)."), oop=None, url=FunctionUrl(url='/wiki/Utf8.title', name='utf8.title', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='width', return_types=['int', 'utf8.'], arguments=[FunctionArgument(name='int', argument_type='string', default_value=None, optional=False), FunctionArgument(name='ambi', argument_type='bool', default_value=None, optional=True), FunctionArgument(name='default', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='Calculates the width of UTF-8 strings with special/unprintable characters, which require special width treatment.', arguments={'input': 'A string character sequence OR a codepoint integer\n{{OptionalArg}}', 'ambi_is_double': 'A boolean, if set to true, ambiguous characters width is 2 (see example below).', 'default_width': 'An integer, if given, is used as width for unprintable characters.'}, result="Returns the ''integer'' width of the input string OR the width of the codepoint integer."), oop=None, url=FunctionUrl(url='/wiki/Utf8.width', name='utf8.width', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='width', return_types=['int', 'utf8.'], arguments=[FunctionArgument(name='int', argument_type='string', default_value=None, optional=False), FunctionArgument(name='ambi', argument_type='bool', default_value=None, optional=True), FunctionArgument(name='default', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='Calculates the width of UTF-8 strings with special/unprintable characters, which require special width treatment.', arguments={'input': 'A string character sequence OR a codepoint integer\n{{OptionalArg}}', 'ambi_is_double': 'A boolean, if set to true, ambiguous characters width is 2 (see example below).', 'default_width': 'An integer, if given, is used as width for unprintable characters.'}, result="Returns the ''integer'' width of the input string OR the width of the codepoint integer."), oop=None, url=FunctionUrl(url='/wiki/Utf8.width', name='utf8.width', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='width', return_types=['int,', 'int,', 'int', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='location', argument_type='int', default_value=None, optional=False), FunctionArgument(name='ambi', argument_type='bool', default_value=None, optional=True), FunctionArgument(name='default', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='Returns the location, offset and width of the character at the given location in the UTF-8 string.', arguments={'input': 'A string character sequence\n{{OptionalArg}}', 'ambi_is_double': 'A boolean, if set to true, ambiguous characters width is 2 (see example).', 'default_width': 'An integer, if given, is used as width for unprintable characters.'}, result="Returns the given location, the offset in UTF-8 encoding (if cursor is in the middle of the wide char - offset will be 2) and the width of the character, otherwise only the location as ''integer'' will be returned."), oop=None, url=FunctionUrl(url='/wiki/Utf8.widthindex', name='utf8.widthindex', category='UTF8 Library', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='width', return_types=['int,', 'int,', 'int', 'utf8.'], arguments=[FunctionArgument(name='input', argument_type='string', default_value=None, optional=False), FunctionArgument(name='location', argument_type='int', default_value=None, optional=False), FunctionArgument(name='ambi', argument_type='bool', default_value=None, optional=True), FunctionArgument(name='default', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='Returns the location, offset and width of the character at the given location in the UTF-8 string.', arguments={'input': 'A string character sequence\n{{OptionalArg}}', 'ambi_is_double': 'A boolean, if set to true, ambiguous characters width is 2 (see example).', 'default_width': 'An integer, if given, is used as width for unprintable characters.'}, result="Returns the given location, the offset in UTF-8 encoding (if cursor is in the middle of the wide char - offset will be 2) and the width of the character, otherwise only the location as ''integer'' will be returned."), oop=None, url=FunctionUrl(url='/wiki/Utf8.widthindex', name='utf8.widthindex', category='UTF8 Library', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='addVehicleUpgrade', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='upgrade', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function adds an upgrade to a [[vehicle]], e.g. nitrous, hydraulics.', arguments={'theVehicle': ': The element representing the vehicle you wish to add the upgrade to.', 'upgrade': ": The id of the upgrade you wish to add. (1000 to 1193), see Vehicle Upgrades\n'''Note:''' setCameraTarget will behave strangely if you use hydraulics (upgrade id: 1087) server sided and when your camera target is the player inside the vehicle with hydraulics and if the player is not you."}, result="Returns ''true'' if the upgrade was successfully added to the vehicle, otherwise ''false''."), oop=None, url=FunctionUrl(url='/wiki/AddVehicleUpgrade', name='addVehicleUpgrade', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='addVehicleUpgrade', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='upgrade', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function adds an upgrade to a [[vehicle]], e.g. nitrous, hydraulics.', arguments={'theVehicle': ': The element representing the vehicle you wish to add the upgrade to.', 'upgrade': ": The id of the upgrade you wish to add. (1000 to 1193), see Vehicle Upgrades\n'''Note:''' setCameraTarget will behave strangely if you use hydraulics (upgrade id: 1087) server sided and when your camera target is the player inside the vehicle with hydraulics and if the player is not you."}, result="Returns ''true'' if the upgrade was successfully added to the vehicle, otherwise ''false''."), oop=None, url=FunctionUrl(url='/wiki/AddVehicleUpgrade', name='addVehicleUpgrade', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='areVehicleLightsOn', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="*This is different to [[getVehicleOverrideLights]] because this function will return '''true''' if the lights were turned on by natural causes.\n* Unless [[setVehicleOverrideLights]] is used, vehicles always automatically disable their lights at 06:25 and enable them at 20:26.}}", arguments={'theVehicle': ': the vehicle you wish to retrieve the lights state of.'}, result="Returns ''true'' if the lights are on, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='areLightsOn', field="lightsOn}}\n===Required Arguments===\n*'''theVehicle''': the [[vehicle]] you wish to retrieve the lights state of.\n\n===Returns===\nReturns ''true'' if the lights are on, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/AreVehicleLightsOn', name='areVehicleLightsOn', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='attachTrailerToVehicle', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theTrailer', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function attaches a trailer type vehicle to a trailer-towing-type vehicle.', arguments={'theVehicle': ': the vehicle you wish to attach a trailer to.', 'theTrailer': ': the trailer you wish to be attached.'}, result="Returns ''true'' if the vehicle's were successfully attached, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/AttachTrailerToVehicle', name='attachTrailerToVehicle', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='attachTrailerToVehicle', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theTrailer', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function attaches a trailer type vehicle to a trailer-towing-type vehicle.', arguments={'theVehicle': ': the vehicle you wish to attach a trailer to.', 'theTrailer': ': the trailer you wish to be attached.'}, result="Returns ''true'' if the vehicle's were successfully attached, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/AttachTrailerToVehicle', name='attachTrailerToVehicle', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='blowVehicle', return_types=['bool'], arguments=[FunctionArgument(name='vehicleToBlow', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='explode', argument_type='bool', default_value='true', optional=False)]), docs=FunctionDoc(description='This function will blow up a vehicle. This will cause an explosion and will kill the driver and any passengers inside it.', arguments={'vehicleToBlow': 'the vehicle that you wish to blow up.\n{{OptionalArg}} ', 'explode': 'if this argument is true then the vehicle will explode, otherwise it will just be blown up silently.'}, result="Returns ''true'' if the vehicle was blown up, ''false'' if invalid arguments were passed to the function."), oop=FunctionOOP(class_name='vehicle', method_name='blow', field='blown'), url=FunctionUrl(url='/wiki/BlowVehicle', name='blowVehicle', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='blowVehicle', return_types=['bool'], arguments=[FunctionArgument(name='vehicleToBlow', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will blow up a vehicle. This will cause an explosion and will kill the driver and any passengers inside it.', arguments={'vehicleToBlow': 'the vehicle that you wish to blow up.'}, result="Returns ''true'' if the vehicle was blown up, ''false'' if invalid arguments were passed to the function."), oop=None, url=FunctionUrl(url='/wiki/BlowVehicle', name='blowVehicle', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createVehicle', return_types=['vehicle'], arguments=[FunctionArgument(name='model', argument_type='int', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rx', argument_type='float', default_value=None, optional=True), FunctionArgument(name='ry', argument_type='float', default_value=None, optional=True), FunctionArgument(name='rz', argument_type='float', default_value=None, optional=True), FunctionArgument(name='numberplate', argument_type='string', default_value=None, optional=True), FunctionArgument(name='bDirection', argument_type='bool', default_value=None, optional=True), FunctionArgument(name='variant1', argument_type='int', default_value=None, optional=True), FunctionArgument(name='variant2', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='This function creates a vehicle at the specified location.\nIts worth nothing that the position of the vehicle is the center point of the vehicle, not its base. As such, you need to ensure that the z value (vertical axis) is some height above the ground. You can find the exact height using the client side function [[getElementDistanceFromCentreOfMassToBaseOfModel]], or you can estimate it yourself and just spawn the vehicle so it drops to the ground.', arguments={'model': ': The Vehicle IDs|vehicle ID of the vehicle being created.', 'x': ': A floating point number representing the X coordinate on the map.', 'y': ': A floating point number representing the Y coordinate on the map.', 'z': ': A floating point number representing the Z coordinate on the map.\n{{OptionalArg}}', 'rx': ': A floating point number representing the rotation about the X axis in degrees.', 'ry': ': A floating point number representing the rotation about the Y axis in degrees.', 'rz': ': A floating point number representing the rotation about the Z axis in degrees.', 'numberplate': ': A string that will go on the number plate of the vehicle (max 8 characters).', 'bDirection': '(serverside only): Placeholder boolean which provides backward compatibility with some scripts. It never had any effect, but it is read by the code. It is recommended to ignore this argument, passing false or the variant1 argument in its place.\n{{New feature/item|3.0120|1.2|| ', 'variant1': ': An integer for the first vehicle variant. See vehicle variants.', 'variant2': ': An integer for the second vehicle variant. See vehicle variants.\n}}'}, result="Returns the [[vehicle]] element that was created. Returns ''false'' if the arguments are incorrect, or if the vehicle limit of 65535 is exceeded."), oop=None, url=FunctionUrl(url='/wiki/CreateVehicle', name='createVehicle', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createVehicle', return_types=['vehicle'], arguments=[FunctionArgument(name='model', argument_type='int', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rx', argument_type='float', default_value=None, optional=True), FunctionArgument(name='ry', argument_type='float', default_value=None, optional=True), FunctionArgument(name='rz', argument_type='float', default_value=None, optional=True), FunctionArgument(name='numberplate', argument_type='string', default_value=None, optional=True), FunctionArgument(name='bDirection', argument_type='bool', default_value=None, optional=True), FunctionArgument(name='variant1', argument_type='int', default_value=None, optional=True), FunctionArgument(name='variant2', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='This function creates a vehicle at the specified location.\nIts worth nothing that the position of the vehicle is the center point of the vehicle, not its base. As such, you need to ensure that the z value (vertical axis) is some height above the ground. You can find the exact height using the client side function [[getElementDistanceFromCentreOfMassToBaseOfModel]], or you can estimate it yourself and just spawn the vehicle so it drops to the ground.', arguments={'model': ': The Vehicle IDs|vehicle ID of the vehicle being created.', 'x': ': A floating point number representing the X coordinate on the map.', 'y': ': A floating point number representing the Y coordinate on the map.', 'z': ': A floating point number representing the Z coordinate on the map.\n{{OptionalArg}}', 'rx': ': A floating point number representing the rotation about the X axis in degrees.', 'ry': ': A floating point number representing the rotation about the Y axis in degrees.', 'rz': ': A floating point number representing the rotation about the Z axis in degrees.', 'numberplate': ': A string that will go on the number plate of the vehicle (max 8 characters).', 'bDirection': '(serverside only): Placeholder boolean which provides backward compatibility with some scripts. It never had any effect, but it is read by the code. It is recommended to ignore this argument, passing false or the variant1 argument in its place.\n{{New feature/item|3.0120|1.2|| ', 'variant1': ': An integer for the first vehicle variant. See vehicle variants.', 'variant2': ': An integer for the second vehicle variant. See vehicle variants.\n}}'}, result="Returns the [[vehicle]] element that was created. Returns ''false'' if the arguments are incorrect, or if the vehicle limit of 65535 is exceeded."), oop=None, url=FunctionUrl(url='/wiki/CreateVehicle', name='createVehicle', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='detachTrailerFromVehicle', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theTrailer', argument_type='vehicle', default_value='nil', optional=True)]), docs=FunctionDoc(description='This function detaches an already attached trailer from a vehicle.', arguments={'theVehicle': ': The vehicle you wish to detach a trailer from.', 'theTrailer': ": The trailer you wish to be detached.\n{{Note|If 'theTrailer' is specified, it will only detach if this matches. If it is not specified, any trailer attached to 'theVehicle' will be detached.}}"}, result="Returns 'true' if the vehicle's were successfully detached, 'false' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name="detachTrailer}}\n===Required Arguments===\n*'''theVehicle''': The [[vehicle]] you wish to detach a trailer from.\n\n===Optional Arguments===\n*'''theTrailer''': The trailer you wish to be detached.\n{{Note", field="If 'theTrailer' is specified, it will only detach if this matches. If it is not specified, any trailer attached to 'theVehicle' will be detached.}}\n\n==Returns==\nReturns 'true' if the vehicle's were successfully detached, 'false' otherwise.\n\n"), url=FunctionUrl(url='/wiki/DetachTrailerFromVehicle', name='detachTrailerFromVehicle', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='detachTrailerFromVehicle', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theTrailer', argument_type='vehicle', default_value='nil', optional=True)]), docs=FunctionDoc(description='This function detaches an already attached trailer from a vehicle.', arguments={'theVehicle': ': The vehicle you wish to detach a trailer from.', 'theTrailer': ": The trailer you wish to be detached.\n{{Note|If 'theTrailer' is specified, it will only detach if this matches. If it is not specified, any trailer attached to 'theVehicle' will be detached.}}"}, result="Returns 'true' if the vehicle's were successfully detached, 'false' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name="detachTrailer}}\n===Required Arguments===\n*'''theVehicle''': The [[vehicle]] you wish to detach a trailer from.\n\n===Optional Arguments===\n*'''theTrailer''': The trailer you wish to be detached.\n{{Note", field="If 'theTrailer' is specified, it will only detach if this matches. If it is not specified, any trailer attached to 'theVehicle' will be detached.}}\n\n==Returns==\nReturns 'true' if the vehicle's were successfully detached, 'false' otherwise.\n\n"), url=FunctionUrl(url='/wiki/DetachTrailerFromVehicle', name='detachTrailerFromVehicle', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='fixVehicle', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="This function will set a [[vehicle]]'s health to full and fix its damage model. If you wish to only change the vehicle's health, without affecting its damage model, use [[setElementHealth]].", arguments={'theVehicle': 'the vehicle you wish to fix'}, result="Returns ''true'' if the vehicle was fixed, ''false'' if '''theVehicle''' is invalid."), oop=None, url=FunctionUrl(url='/wiki/FixVehicle', name='fixVehicle', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='fixVehicle', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="This function will set a [[vehicle]]'s health to full and fix its damage model. If you wish to only change the vehicle's health, without affecting its damage model, use [[setElementHealth]].", arguments={'theVehicle': 'the vehicle you wish to fix'}, result="Returns ''true'' if the vehicle was fixed, ''false'' if '''theVehicle''' is invalid."), oop=None, url=FunctionUrl(url='/wiki/FixVehicle', name='fixVehicle', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getHeliBladeCollisionsEnabled', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the state of the helicopter blades collisions on the specified vehicle.', arguments={'theVehicle': 'The vehicle that will be checked.'}, result="Returns ''true'' if the collisions are enabled for specified vehicle, ''false'' if the collisions aren't enabled for the specified vehicle, if the vehicle is not a helicopter or if invalid arguments are specified."), oop=FunctionOOP(class_name='vehicle', method_name='areHeliBladeCollisionsEnabled', field='heliBladeCollisionsEnabled'), url=FunctionUrl(url='/wiki/GetHeliBladeCollisionsEnabled', name='getHeliBladeCollisionsEnabled', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getHelicopterRotorSpeed', return_types=['float'], arguments=[FunctionArgument(name='heli', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='Retrieves the speed at which the rotor of a helicopter rotates.', arguments={'heli': 'the helicopter element to get the rotor speed of.'}, result="Returns the rotor speed if successful. This is 0 when the helicopter is parked, and about 0.2 when it is fully spun up. It can be negative if the rotor rotates counter-clockwise. Returns ''false'' in case of failure (an invalid element or a vehicle element that is not a helicopter was passed)."), oop=FunctionOOP(class_name='vehicle', method_name='getHelicopterRotorSpeed', field='helicopterRotorSpeed'), url=FunctionUrl(url='/wiki/GetHelicopterRotorSpeed', name='getHelicopterRotorSpeed', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getOriginalHandling', return_types=['table'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a table of the original vehicle handling. Use [[getVehicleHandling]] if you wish to get the current handling of a vehicle, or [[getModelHandling]] for a specific vehicle model.', arguments={'modelID': 'The vehicle ID you wish to get the original handling from.'}, result="Returns a ''table'' containing all the handling data, ''false'' otherwise. Here a list of valid table properties and what they return:\n{{Handling Properties}}"), oop=None, url=FunctionUrl(url='/wiki/GetOriginalHandling', name='getOriginalHandling', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getOriginalHandling', return_types=['table'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a table of the original vehicle handling. Use [[getVehicleHandling]] if you wish to get the current handling of a vehicle, or [[getModelHandling]] for a specific vehicle model.', arguments={'modelID': 'The vehicle ID you wish to get the original handling from.'}, result="Returns a ''table'' containing all the handling data, ''false'' otherwise. Here a list of valid table properties and what they return:\n{{Handling Properties}}"), oop=None, url=FunctionUrl(url='/wiki/GetOriginalHandling', name='getOriginalHandling', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getTrainDirection', return_types=['bool'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the direction in which a train is driving (clockwise or counterclockwise).', arguments={'train': 'the train of which to get the driving direction.'}, result="Returns ''true'' if the train is driving clockwise on the train track, ''false'' if it is going counterclockwise or a failure occured."), oop=FunctionOOP(class_name='vehicle', method_name='getDirection', field='direction'), url=FunctionUrl(url='/wiki/GetTrainDirection', name='getTrainDirection', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getTrainDirection', return_types=['bool'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the direction in which a train is driving (clockwise or counterclockwise).', arguments={'train': 'the train of which to get the driving direction.'}, result="Returns ''true'' if the train is driving clockwise on the train track, ''false'' if it is going counterclockwise or a failure occured."), oop=FunctionOOP(class_name='vehicle', method_name='getDirection', field='direction'), url=FunctionUrl(url='/wiki/GetTrainDirection', name='getTrainDirection', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getTrainPosition', return_types=['float'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the position the train is currently on the track\n}}', arguments={'train': 'the train to get the position of'}, result="Returns a float that represents how along the track it is, ''false'' if there is problem with train element."), oop=FunctionOOP(class_name='vehicle', method_name='getTrainPosition', field='trainPosition'), url=FunctionUrl(url='/wiki/GetTrainPosition', name='getTrainPosition', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getTrainPosition', return_types=['float'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the position the train is currently on the track\n}}', arguments={'train': 'the train to get the position of'}, result="Returns a float that represents how along the track it is, ''false'' if there is problem with train element."), oop=FunctionOOP(class_name='vehicle', method_name='getTrainPosition', field='trainPosition'), url=FunctionUrl(url='/wiki/GetTrainPosition', name='getTrainPosition', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getTrainSpeed', return_types=['float'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the speed at which a train is traveling on the rails.', arguments={'train': 'the train of which to retrieve the speed.'}, result="Returns the train's speed if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='getSpeed', field='trainSpeed'), url=FunctionUrl(url='/wiki/GetTrainSpeed', name='getTrainSpeed', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getTrainSpeed', return_types=['float'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the speed at which a train is traveling on the rails.', arguments={'train': 'the train of which to retrieve the speed.'}, result="Returns the train's speed if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='getSpeed', field='trainSpeed'), url=FunctionUrl(url='/wiki/GetTrainSpeed', name='getTrainSpeed', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getTrainTrack', return_types=['int'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the track of a train\n}}', arguments={'train': 'the train of which to get the track.'}, result="Returns an integer (whole number) that represents the train track, ''false'' if there is problem with train element."), oop=FunctionOOP(class_name='vehicle', method_name='getTrack', field='track'), url=FunctionUrl(url='/wiki/GetTrainTrack', name='getTrainTrack', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getTrainTrack', return_types=['int'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the track of a train\n}}', arguments={'train': 'the train of which to get the track.'}, result="Returns an integer (whole number) that represents the train track, ''false'' if there is problem with train element."), oop=FunctionOOP(class_name='vehicle', method_name='getTrack', field='track'), url=FunctionUrl(url='/wiki/GetTrainTrack', name='getTrainTrack', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleAdjustableProperty', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='Use this to get the value of a vehicles adjustable property. This property relates to movable parts of a model, for example hydra jets or dump truck tray.', arguments={'theVehicle': 'The vehicle you want to get the adjustable property of.'}, result="Returns a value from 0 upwards representing adjustment. 0 is default position. Maximum varies per vehicle, for example hydra horizontal flight is 5000, while dump truck tray max tilt is 2500. Or returns ''false'' if the vehicle passed to the function is invalid."), oop=None, url=FunctionUrl(url='/wiki/GetVehicleAdjustableProperty', name='getVehicleAdjustableProperty', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleColor', return_types=['int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='bRGB', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the color of the specified vehicle. A vehicle can have up to four colors.', arguments={'theVehicle': 'The vehicle that you wish to get the color of.', 'bRGB ': 'A boolean specifying whether to return RGB values. A setting of false will result in the function returning color ids instead.'}, result="*Returns 12 [[int|ints]] (if bRGB is ''true'') indicating the red, green and blue components of each of the 4 vehicle colors.\n*Returns 4 [[int|ints]] (if bRGB is ''false'') indicating the color ids of each of the 4 vehicle colors.\n*Returns ''false'' if the vehicle doesn't exist.\nValid color ids if bRGB is set to false:\n{{Vehicle_colors}}\n<br>"), oop=FunctionOOP(class_name='vehicle', method_name="getColor}}\n\n===Required Arguments=== \n*'''theVehicle:''' The [[vehicle]] that you wish to get the color of.\n*'''bRGB :''' A boolean specifying whether to return RGB values. A setting of ''false'' will result in the function returning color ids instead.\n\n===Returns===\n*Returns 12 [[int", field="ints]] (if bRGB is ''true'') indicating the red, green and blue components of each of the 4 vehicle colors.\n*Returns 4 [[int"), url=FunctionUrl(url='/wiki/GetVehicleColor', name='getVehicleColor', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleColor', return_types=['int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='bRGB', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the color of the specified vehicle. A vehicle can have up to four colors.', arguments={'theVehicle': 'The vehicle that you wish to get the color of.', 'bRGB ': 'A boolean specifying whether to return RGB values. A setting of false will result in the function returning color ids instead.'}, result="*Returns 12 [[int|ints]] (if bRGB is ''true'') indicating the red, green and blue components of each of the 4 vehicle colors.\n*Returns 4 [[int|ints]] (if bRGB is ''false'') indicating the color ids of each of the 4 vehicle colors.\n*Returns ''false'' if the vehicle doesn't exist.\nValid color ids if bRGB is set to false:\n{{Vehicle_colors}}\n<br>"), oop=FunctionOOP(class_name='vehicle', method_name="getColor}}\n\n===Required Arguments=== \n*'''theVehicle:''' The [[vehicle]] that you wish to get the color of.\n*'''bRGB :''' A boolean specifying whether to return RGB values. A setting of ''false'' will result in the function returning color ids instead.\n\n===Returns===\n*Returns 12 [[int", field="ints]] (if bRGB is ''true'') indicating the red, green and blue components of each of the 4 vehicle colors.\n*Returns 4 [[int"), url=FunctionUrl(url='/wiki/GetVehicleColor', name='getVehicleColor', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleCompatibleUpgrades', return_types=['table'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='slot', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='This function returns a table of all the compatible upgrades (or all for a specified slot, optionally) for a specified vehicle.', arguments={'theVehicle': 'the vehicle you wish to retrieve the list of compatible upgrades of.', 'slot': 'the upgrade slot number for which youre getting the list (from 0 to 16). Compatible upgrades for all slots are listed if this is not specified.'}, result="Returns a ''table'' with all the compatible upgrades, or ''false'' if invalid arguments are passed."), oop=FunctionOOP(class_name='vehicle', method_name='getCompatibleUpgrades', field="compatibleUpgrades}}\n===Required Arguments=== \n*'''theVehicle:''' the [[vehicle]] you wish to retrieve the list of compatible upgrades of.\n\n===Optional Arguments=== \n*'''slot:''' the upgrade slot number for which you're getting the list (from 0 to 16). Compatible upgrades for all slots are listed if this is not specified.\n\n===Returns===\nReturns a ''table'' with all the compatible upgrades, or ''false'' if invalid arguments are passed.\n\n"), url=FunctionUrl(url='/wiki/GetVehicleCompatibleUpgrades', name='getVehicleCompatibleUpgrades', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleCompatibleUpgrades', return_types=['table'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='slot', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description='This function returns a table of all the compatible upgrades (or all for a specified slot, optionally) for a specified vehicle.', arguments={'theVehicle': 'the vehicle you wish to retrieve the list of compatible upgrades of.', 'slot': 'the upgrade slot number for which youre getting the list (from 0 to 16). Compatible upgrades for all slots are listed if this is not specified.'}, result="Returns a ''table'' with all the compatible upgrades, or ''false'' if invalid arguments are passed."), oop=FunctionOOP(class_name='vehicle', method_name='getCompatibleUpgrades', field="compatibleUpgrades}}\n===Required Arguments=== \n*'''theVehicle:''' the [[vehicle]] you wish to retrieve the list of compatible upgrades of.\n\n===Optional Arguments=== \n*'''slot:''' the upgrade slot number for which you're getting the list (from 0 to 16). Compatible upgrades for all slots are listed if this is not specified.\n\n===Returns===\nReturns a ''table'' with all the compatible upgrades, or ''false'' if invalid arguments are passed.\n\n"), url=FunctionUrl(url='/wiki/GetVehicleCompatibleUpgrades', name='getVehicleCompatibleUpgrades', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleComponentPosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theComponent', argument_type='string', default_value=None, optional=False), FunctionArgument(name='base', argument_type='string', default_value='"root"', optional=True)]), docs=FunctionDoc(description='This function gets the component position of a [[vehicle]]. The vehicle must be streamed in.', arguments={'theVehicle': 'The vehicle you wish to get component position of.', 'theComponent': 'A Vehicle_Components|vehicle component (this is the frame name from the model file of the component you wish to modify)\n{{New feature/item|3.0141|1.4.0|7013|', 'base': 'A string representing what the returned position is relative to. It can be one of the following values:', 'parent': 'The position is relative to the parent component.', 'root': 'The position is relative to the root component.', 'world': 'The position is a world position.\n}}'}, result="Returns three ''floats'' indicating the position of the component, ''x'', ''y'' and ''z'' respectively."), oop=FunctionOOP(class_name='vehicle', method_name='getComponentPosition', field=None), url=FunctionUrl(url='/wiki/GetVehicleComponentPosition', name='getVehicleComponentPosition', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleComponentRotation', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theComponent', argument_type='string', default_value=None, optional=False), FunctionArgument(name='base', argument_type='string', default_value='"parent"', optional=True)]), docs=FunctionDoc(description='This function gets the component rotation of a [[vehicle]].', arguments={'theVehicle': 'The vehicle you wish to get component rotation of.', 'theComponent': 'A Vehicle_Components|vehicle component (this is the frame name from the model file of the component you wish to modify)\n{{New feature/item|3.0141|1.4.0|7013|', 'base': 'A string representing what the returned rotation is relative to. It can be one of the following values:', 'parent': '(default if not specified): The rotation is relative to the parent component.', 'root': ': The rotation is relative to the root component.', 'world': ': The rotation is a world rotation, relative to the worlds coordinates axes.\n}}'}, result="Returns three ''floats'' indicating the rotation of the component, ''x'', ''y'' and ''z'' respectively."), oop=FunctionOOP(class_name='vehicle', method_name='getComponentRotation', field=None), url=FunctionUrl(url='/wiki/GetVehicleComponentRotation', name='getVehicleComponentRotation', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleComponentScale', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theComponent', argument_type='string', default_value=None, optional=False), FunctionArgument(name='base', argument_type='string', default_value='"root"', optional=True)]), docs=FunctionDoc(description='This function gets the component scale of a [[vehicle]].}}', arguments={'theVehicle': 'The vehicle you wish to get component scale of.', 'theComponent': 'A Vehicle_Components|vehicle component (this is the frame name from the model file of the component you wish to modify)', 'base': 'A string representing what the returned scale is relative to. It can be one of the following values:', 'parent': 'The scale is relative to the parent component.', 'root': 'The scale  is relative to the root component.', 'world': 'The scale is a world scale.'}, result="Returns three ''floats'' indicating the scale of the component, ''x'', ''y'' and ''z'' respectively."), oop=FunctionOOP(class_name='vehicle', method_name='getComponentScale', field=None), url=FunctionUrl(url='/wiki/GetVehicleComponentScale', name='getVehicleComponentScale', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleComponentVisible', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theComponent', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function get component visibility for [[vehicle]].\n}}', arguments={'theVehicle': 'The vehicle you wish to get component visibility of.', 'theComponent': 'A Vehicle_Components|vehicle component (this is the frame name from the model file of the component you wish to modify)'}, result="Returns a ''bool'' indicating the visible state of the component."), oop=FunctionOOP(class_name='vehicle', method_name='getComponentVisible', field=None), url=FunctionUrl(url='/wiki/GetVehicleComponentVisible', name='getVehicleComponentVisible', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleComponents', return_types=['table'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets a table of the components currently on a [[vehicle]].\n}}', arguments={'theVehicle': 'The vehicle you wish to get the Vehicle_Components|components of.'}, result="Returns a ''table'' containing the name of the component as the key and visibility flag of that component as the value"), oop=FunctionOOP(class_name='vehicle', method_name='getComponents', field="components}}\n\n===Required Arguments=== \n*'''theVehicle:''' The [[vehicle]] you wish to get the [[Vehicle_Components"), url=FunctionUrl(url='/wiki/GetVehicleComponents', name='getVehicleComponents', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleController', return_types=['player'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the player in control of the specified vehicle which includes somebody who is trying to enter the drivers seat.', arguments={'theVehicle': 'the vehicle you want to get the controller of.'}, result="Returns a [[player]] object, if there isn't a driver, it will search the 'trailer chain' for the front driver, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='getController', field="controller}}\n===Required Arguments=== \n*'''theVehicle:''' the [[vehicle]] you want to get the 'controller' of.\n\n===Returns===\nReturns a [[player]] object, if there isn't a driver, it will search the 'trailer chain' for the front driver, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/GetVehicleController', name='getVehicleController', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleController', return_types=['player'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the player in control of the specified vehicle which includes somebody who is trying to enter the drivers seat.', arguments={'theVehicle': 'the vehicle you want to get the controller of.'}, result="Returns a [[player]] object, if there isn't a driver, it will search the 'trailer chain' for the front driver, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='getController', field="controller}}\n===Required Arguments=== \n*'''theVehicle:''' the [[vehicle]] you want to get the 'controller' of.\n\n===Returns===\nReturns a [[player]] object, if there isn't a driver, it will search the 'trailer chain' for the front driver, ''false'' otherwise.\n\n"), url=FunctionUrl(url='/wiki/GetVehicleController', name='getVehicleController', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleCurrentGear', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="Gets the specified vehicle's current gear.", arguments={'theVehicle': 'the vehicle to get the gear of'}, result="Returns the gear if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetVehicleCurrentGear', name='getVehicleCurrentGear', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleDoorOpenRatio', return_types=['float'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='door', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function tells you how open a door is (the 'open ratio'). Doors include boots/trunks and bonnets on vehicles that have them.", arguments={'theVehicle': 'The vehicle that you wish to get the door open ratio of.', 'door': 'A whole number, 0 (hood), 1 (trunk), 2 (front left), 3 (front right), 4 (rear left), 5 (rear right)'}, result="Returns a number between 0 and 1 that indicates how open the door is. 0 is closed, and 1 is fully open. Returns ''false'' if invalid arguments are passed."), oop=FunctionOOP(class_name='vehicle', method_name='getDoorOpenRatio', field=None), url=FunctionUrl(url='/wiki/GetVehicleDoorOpenRatio', name='getVehicleDoorOpenRatio', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleDoorOpenRatio', return_types=['float'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='door', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function tells you how open a door is (the 'open ratio'). Doors include boots/trunks and bonnets on vehicles that have them.", arguments={'theVehicle': 'The vehicle that you wish to get the door open ratio of.', 'door': 'A whole number, 0 (hood), 1 (trunk), 2 (front left), 3 (front right), 4 (rear left), 5 (rear right)'}, result="Returns a number between 0 and 1 that indicates how open the door is. 0 is closed, and 1 is fully open. Returns ''false'' if invalid arguments are passed."), oop=FunctionOOP(class_name='vehicle', method_name='getDoorOpenRatio', field=None), url=FunctionUrl(url='/wiki/GetVehicleDoorOpenRatio', name='getVehicleDoorOpenRatio', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleDoorState', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='door', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current state of the specifed door on the vehicle.', arguments={'theVehicle': 'the vehicle you want to get the door status of.', 'door': 'a whole number representing which door to get the status of. Valid values are:', '0': 'Hood', '1': 'Trunk', '2': 'Front left', '3': 'Front right', '4': 'Rear left', '5': 'Rear right'}, result="If successful, one of the following integers will be returned:\n* '''0:''' Shut, intact (also returned if the door does not exist)\n* '''1:''' Ajar, intact\n* '''2:''' Shut, damaged\n* '''3:''' Ajar, damaged\n* '''4:''' Missing"), oop=FunctionOOP(class_name='vehicle', method_name='getDoorState', field=None), url=FunctionUrl(url='/wiki/GetVehicleDoorState', name='getVehicleDoorState', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleDoorState', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='door', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current state of the specifed door on the vehicle.', arguments={'theVehicle': 'the vehicle you want to get the door status of.', 'door': 'a whole number representing which door to get the status of. Valid values are:', '0': 'Hood', '1': 'Trunk', '2': 'Front left', '3': 'Front right', '4': 'Rear left', '5': 'Rear right'}, result="If successful, one of the following integers will be returned:\n* '''0:''' Shut, intact (also returned if the door does not exist)\n* '''1:''' Ajar, intact\n* '''2:''' Shut, damaged\n* '''3:''' Ajar, damaged\n* '''4:''' Missing"), oop=FunctionOOP(class_name='vehicle', method_name='getDoorState', field=None), url=FunctionUrl(url='/wiki/GetVehicleDoorState', name='getVehicleDoorState', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleDummyPosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='dummy', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the position of the dummy for the given vehicle.}}', arguments={'theVehicle': 'The vehicle you want to get the dummy positions from', 'dummy': 'The dummy whose position you want to get'}, result='Returns three floats indicating the position \'\'x\'\', \'\'y\'\' and \'\'z\'\' of the vehicle\'s dummy. It returns \'\'false\'\' otherwise.\nThis is a command to get the position of the player\'s vehicle dummy position specified as an argument.\n<syntaxhighlight lang="lua">\nfunction getDummyPosition(cmd, dummy)\n    if (not dummy) then\n        return false\n    end\n    local veh = getPedOccupiedVehicle(localPlayer)\n    if (not veh) then\n        outputChatBox("You should be in a vehicle to use this command", 255, 25, 25)\n        return false\n    end\n    local x, y, z = getVehicleDummyPosition(veh, dummy)\n    outputChatBox("X: "..x..", Y: "..y..", Z: "..z, 0, 255, 0)\nend\naddCommandHandler("getdummy", getDummyPosition)\n</syntaxhighlight>'), oop=FunctionOOP(class_name='vehicle', method_name='getDummyPosition', field=None), url=FunctionUrl(url='/wiki/GetVehicleDummyPosition', name='getVehicleDummyPosition', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleEngineState', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theVehicle': ': the vehicle you wish to get the engine state of.'}, result="Returns '''true''' if the vehicle's engine is started, '''false''' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='getEngineState', field='engineState'), url=FunctionUrl(url='/wiki/GetVehicleEngineState', name='getVehicleEngineState', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleEngineState', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theVehicle': ': the vehicle you wish to get the engine state of.'}, result="Returns '''true''' if the vehicle's engine is started, '''false''' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='getEngineState', field='engineState'), url=FunctionUrl(url='/wiki/GetVehicleEngineState', name='getVehicleEngineState', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleGravity', return_types=['float', 'float', 'float'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='Retrieves the current gravity vector of a vehicle. This is the direction in which the vehicle falls, also the cameras of any passengers will be rotated to match it.', arguments={'theVehicle': 'the vehicle to retrieve the gravity vector of.'}, result="Returns the x, y and z components of the gravity vector if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetVehicleGravity', name='getVehicleGravity', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleHandling', return_types=['table'], arguments=[FunctionArgument(name='theVehicle', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a table of the current vehicle handling data.', arguments={'theVehicle': 'the vehicle you wish to get the handling data of.'}, result="Returns a ''table'' containing all the handling data, ''false'' otherwise. Here's a list of valid table properties and what they return:\n{{Handling Properties}}"), oop=FunctionOOP(class_name='vehicle', method_name='getHandling', field="handling}}\n===Required Arguments=== \n*'''theVehicle:''' the vehicle you wish to get the handling data of.\n\n===Returns===\nReturns a ''table'' containing all the handling data, ''false'' otherwise. Here's a list of valid table properties and what they return:\n{{Handling Properties}}\n\n"), url=FunctionUrl(url='/wiki/GetVehicleHandling', name='getVehicleHandling', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleHandling', return_types=['table'], arguments=[FunctionArgument(name='theVehicle', argument_type='element', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a table of the current vehicle handling data.', arguments={'theVehicle': 'the vehicle you wish to get the handling data of.'}, result="Returns a ''table'' containing all the handling data, ''false'' otherwise. Here's a list of valid table properties and what they return:\n{{Handling Properties}}"), oop=FunctionOOP(class_name='vehicle', method_name='getHandling', field="handling}}\n===Required Arguments=== \n*'''theVehicle:''' the vehicle you wish to get the handling data of.\n\n===Returns===\nReturns a ''table'' containing all the handling data, ''false'' otherwise. Here's a list of valid table properties and what they return:\n{{Handling Properties}}\n\n"), url=FunctionUrl(url='/wiki/GetVehicleHandling', name='getVehicleHandling', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleHeadLightColor', return_types=['int,', 'int,', 'int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will get the headlight color of a vehicle.', arguments={'theVehicle': 'The vehicle that you wish to set the headlight color of.'}, result="Returns three ''integers'' for the red, green and blue of the headlight color for the specified vehicle, ''false'' if an invalid vehicle was specified."), oop=FunctionOOP(class_name='vehicle', method_name='getHeadLightColor', field=None), url=FunctionUrl(url='/wiki/GetVehicleHeadLightColor', name='getVehicleHeadLightColor', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleHeadLightColor', return_types=['int,', 'int,', 'int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will get the headlight color of a vehicle.', arguments={'theVehicle': 'The vehicle that you wish to set the headlight color of.'}, result="Returns three ''integers'' for the red, green and blue of the headlight color for the specified vehicle, ''false'' if an invalid vehicle was specified."), oop=FunctionOOP(class_name='vehicle', method_name='getHeadLightColor', field=None), url=FunctionUrl(url='/wiki/GetVehicleHeadLightColor', name='getVehicleHeadLightColor', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleLandingGearDown', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to check whether a vehicle's landing gear is down or not. Only planes can be used with this function.", arguments={'theVehicle': 'the vehicle of which you wish to check the landing gear state.'}, result="Returns ''true'' if landing gear is down, ''false'' if the landing gear is up.<br />\nReturns ''nil'' if the vehicle has no landing gear, or is invalid."), oop=FunctionOOP(class_name='vehicle', method_name='getLangingGearDown', field='landingGearDown'), url=FunctionUrl(url='/wiki/GetVehicleLandingGearDown', name='getVehicleLandingGearDown', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleLandingGearDown', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="This function is used to check whether a vehicle's landing gear is down or not. Only planes can be used with this function.", arguments={'theVehicle': 'the vehicle of which you wish to check the landing gear state.'}, result="Returns ''true'' if landing gear is down, ''false'' if the landing gear is up.<br />\nReturns ''nil'' if the vehicle has no landing gear, or is invalid."), oop=FunctionOOP(class_name='vehicle', method_name='getLangingGearDown', field='landingGearDown'), url=FunctionUrl(url='/wiki/GetVehicleLandingGearDown', name='getVehicleLandingGearDown', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleLightState', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='light', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current state of the specified light on the vehicle.', arguments={'theVehicle': 'the vehicle that you wish to know the light state of.', 'light': 'A whole number determining the individual light:', '0': 'Front left', '1': 'Front right', '2': 'Rear right', '3': 'Rear left'}, result='Returns 0 (working) or 1 (broken)'), oop=FunctionOOP(class_name='vehicle', method_name='getLightState', field=None), url=FunctionUrl(url='/wiki/GetVehicleLightState', name='getVehicleLightState', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleLightState', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='light', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current state of the specified light on the vehicle.', arguments={'theVehicle': 'the vehicle that you wish to know the light state of.', 'light': 'A whole number determining the individual light:', '0': 'Front left', '1': 'Front right', '2': 'Rear right', '3': 'Rear left'}, result='Returns 0 (working) or 1 (broken)'), oop=FunctionOOP(class_name='vehicle', method_name='getLightState', field=None), url=FunctionUrl(url='/wiki/GetVehicleLightState', name='getVehicleLightState', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleMaxPassengers', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the maximum number of passengers that a specified vehicle can hold. Only passenger seats are counted, the driver seat is excluded.', arguments={'theVehicle': 'the vehicle that you wish to know the maximum capacity of.\nOR', 'modelID': 'the model id that you wish to know the maximum capacity of.'}, result='Returns an [[int]] indicating the maximum number of passengers that can enter a vehicle.'), oop=FunctionOOP(class_name='vehicle', method_name='getMaxPassengers', field="maxPassengers}}\n===Required Arguments===\n*'''theVehicle:''' the [[vehicle]] that you wish to know the maximum capacity of.\nOR\n*'''modelID:''' the model id that you wish to know the maximum capacity of.\n\n===Returns===\nReturns an [[int]] indicating the maximum number of passengers that can enter a vehicle.\n\n"), url=FunctionUrl(url='/wiki/GetVehicleMaxPassengers', name='getVehicleMaxPassengers', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleMaxPassengers', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the maximum number of passengers that a specified vehicle can hold. Only passenger seats are counted, the driver seat is excluded.', arguments={'theVehicle': 'the vehicle that you wish to know the maximum capacity of.\nOR', 'modelID': 'the model id that you wish to know the maximum capacity of.'}, result='Returns an [[int]] indicating the maximum number of passengers that can enter a vehicle.'), oop=FunctionOOP(class_name='vehicle', method_name='getMaxPassengers', field="maxPassengers}}\n===Required Arguments===\n*'''theVehicle:''' the [[vehicle]] that you wish to know the maximum capacity of.\nOR\n*'''modelID:''' the model id that you wish to know the maximum capacity of.\n\n===Returns===\nReturns an [[int]] indicating the maximum number of passengers that can enter a vehicle.\n\n"), url=FunctionUrl(url='/wiki/GetVehicleMaxPassengers', name='getVehicleMaxPassengers', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleModelDummyPosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='dummy', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets position of the dummies contained in a vehicle model.\n}}', arguments={'modelID': ': The model ID which you want to apply the change to', 'dummy': ': The dummy whose position you want to get'}, result="Returns three floats indicating the position ''x'', ''y'' and ''z'' of given dummy. It returns ''false'' otherwise."), oop=FunctionOOP(class_name='Vehicle', method_name='getVehicleModelDummyPosition', field=None), url=FunctionUrl(url='/wiki/GetVehicleModelDummyPosition', name='getVehicleModelDummyPosition', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleModelDummyDefaultPosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='dummy', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the default position of the dummies contained in a vehicle model.\n}}', arguments={'modelID': ': The model ID which you want to apply the change to', 'dummy': ': The dummy whose position you want to get'}, result="Returns three floats indicating the default position ''x'', ''y'' and ''z'' of the given dummy. It returns ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetVehicleModelDummyDefaultPosition', name='getVehicleModelDummyDefaultPosition', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleModelExhaustFumesPosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the position of the exhaust fumes the vehicle model emits.\n}}', arguments={'modelID': ': The vehicle model ID.'}, result="Returns the position of the exhaust fumes if everything went fine or ''false'' otherwise."), oop=FunctionOOP(class_name='Vehicle', method_name='getModelExhaustFumesPosition', field=None), url=FunctionUrl(url='/wiki/GetVehicleModelExhaustFumesPosition', name='getVehicleModelExhaustFumesPosition', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleModelFromName', return_types=['int'], arguments=[FunctionArgument(name='name', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the model ID of a vehicle as an [[int]]eger value from its name.', arguments={'name': 'A string containing the name of the vehicle.\n{{All Vehicle Types}}'}, result='Returns an [[int]]eger if the name exists, \'\'false\'\' otherwise.\nIf you use this function on vehicles with shared names, such as "police", it will return the earliest occurrence of that vehicle\'s ID.'), oop=None, url=FunctionUrl(url='/wiki/GetVehicleModelFromName', name='getVehicleModelFromName', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleModelFromName', return_types=['int'], arguments=[FunctionArgument(name='name', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the model ID of a vehicle as an [[int]]eger value from its name.', arguments={'name': 'A string containing the name of the vehicle.\n{{All Vehicle Types}}'}, result='Returns an [[int]]eger if the name exists, \'\'false\'\' otherwise.\nIf you use this function on vehicles with shared names, such as "police", it will return the earliest occurrence of that vehicle\'s ID.'), oop=None, url=FunctionUrl(url='/wiki/GetVehicleModelFromName', name='getVehicleModelFromName', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleModelWheelSize', return_types=['float|table'], arguments=[FunctionArgument(name='vehicleModel', argument_type='int', default_value=None, optional=False), FunctionArgument(name='wheelGroup', argument_type='string', default_value=None, optional=True)]), docs=FunctionDoc(description='', arguments={'vehicleModel': ': The Vehicle IDs|vehicle model ID.', 'wheelGroup': ': The group of wheels of the vehicle model to retrieve their size value. If not specified, it defaults to all_wheels. The following values are supported:', 'front_axle': ': Represents the wheels in the front axle.', 'rear_axle': ': Represents the wheels in the rear axle.', 'all_wheels': ': Convenience group that returns all the wheel sizes in a table of the following format:\n<syntaxhighlight lang="lua">{ front_axle = 0.8, rear_axle = 0.7 }</syntaxhighlight>'}, result='Returns a decimal number or a table, depending on the specified wheel group. If the specified vehicle model ID or wheel group are not valid, an error is raised instead. The meaning of the wheel size values is documented in [[setVehicleModelWheelSize]].'), oop=FunctionOOP(class_name='Vehicle', method_name='getModelWheelSize', field=None), url=FunctionUrl(url='/wiki/GetVehicleModelWheelSize', name='getVehicleModelWheelSize', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleName', return_types=['string'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a string containing the name of the vehicle', arguments={'theVehicle': 'the vehicle you want to get the name of.'}, result="Returns a string containing the requested vehicle's name, or ''false'' if the vehicle passed to the function is invalid."), oop=FunctionOOP(class_name='vehicle', method_name='getName', field="name}}\n===Required Arguments=== \n*'''theVehicle:''' the [[vehicle]] you want to get the name of. \n\n===Returns===\nReturns a string containing the requested vehicle's name, or ''false'' if the vehicle passed to the function is invalid.\n\n"), url=FunctionUrl(url='/wiki/GetVehicleName', name='getVehicleName', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleName', return_types=['string'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a string containing the name of the vehicle', arguments={'theVehicle': 'the vehicle you want to get the name of.'}, result="Returns a string containing the requested vehicle's name, or ''false'' if the vehicle passed to the function is invalid."), oop=FunctionOOP(class_name='vehicle', method_name='getName', field="name}}\n===Required Arguments=== \n*'''theVehicle:''' the [[vehicle]] you want to get the name of. \n\n===Returns===\nReturns a string containing the requested vehicle's name, or ''false'' if the vehicle passed to the function is invalid.\n\n"), url=FunctionUrl(url='/wiki/GetVehicleName', name='getVehicleName', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleNameFromModel', return_types=['string'], arguments=[FunctionArgument(name='model', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the name of a vehicle by its model ID.', arguments={'model': 'This is the vehicle model ID. See vehicle IDs to see what values will return names.'}, result='Returns the name of the vehicle if the model ID was valid, empty string otherwise<ref>https://bugs.multitheftauto.com/view.php?id=8523</ref>.'), oop=None, url=FunctionUrl(url='/wiki/GetVehicleNameFromModel', name='getVehicleNameFromModel', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleNameFromModel', return_types=['string'], arguments=[FunctionArgument(name='model', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the name of a vehicle by its model ID.', arguments={'model': 'This is the vehicle model ID. See vehicle IDs to see what values will return names.'}, result='Returns the name of the vehicle if the model ID was valid, empty string otherwise<ref>https://bugs.multitheftauto.com/view.php?id=8523</ref>.'), oop=None, url=FunctionUrl(url='/wiki/GetVehicleNameFromModel', name='getVehicleNameFromModel', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleNitroCount', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the nitro count of the [[vehicle]].\n}}', arguments={'theVehicle': 'The vehicle which you want to get a nitro count.'}, result="Returns ''an integer'' determining the amount of nitro counts of the vehicle, ''false'' if there is no nitro in the vehicle."), oop=None, url=FunctionUrl(url='/wiki/GetVehicleNitroCount', name='getVehicleNitroCount', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleNitroLevel', return_types=['float'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the nitro level of the [[vehicle]].\n}}', arguments={'theVehicle': 'The vehicle, which you want to get a nitro level.'}, result="Returns ''a float'' determining the nitro level (ranges from 0.0001 to 1.0) of the vehicle, ''false'' if there is no nitro in the vehicle."), oop=None, url=FunctionUrl(url='/wiki/GetVehicleNitroLevel', name='getVehicleNitroLevel', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleOccupant', return_types=['player'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='seat', argument_type='int', default_value='0', optional=False)]), docs=FunctionDoc(description='This function gets the player sitting/trying to enter the specified vehicle.', arguments={'theVehicle': 'the vehicle of which you wish to retrieve the driver or a passenger.\n{{OptionalArg}} ', 'seat': 'the seat where the player is sitting (0 for driver, 1+ for passengers).'}, result="Returns the [[player]] sitting in the vehicle, or ''false'' if the seat is unoccupied or doesn't exist."), oop=None, url=FunctionUrl(url='/wiki/GetVehicleOccupant', name='getVehicleOccupant', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleOccupant', return_types=['player'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='seat', argument_type='int', default_value='0', optional=False)]), docs=FunctionDoc(description='This function gets the player sitting/trying to enter the specified vehicle.', arguments={'theVehicle': 'the vehicle of which you wish to retrieve the driver or a passenger.\n{{OptionalArg}} ', 'seat': 'the seat where the player is sitting (0 for driver, 1+ for passengers).'}, result="Returns the [[player]] sitting in the vehicle, or ''false'' if the seat is unoccupied or doesn't exist."), oop=None, url=FunctionUrl(url='/wiki/GetVehicleOccupant', name='getVehicleOccupant', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleOccupants', return_types=['table'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets all peds sitting in the specified vehicle.', arguments={'theVehicle': 'the vehicle of which you wish to retrieve the occupants.'}, result='Returns a [[table]] with seat ID as an index and the occupant as an element like this: table[seat] = occupant\nReturns \'\'false\'\' if an invalid vehicle was passed or if the vehicle has no seats (like a trailer)\n<div style=\'font-weight: bold;background:blue;color:white;padding:2px; padding-left:8px;\'>COUNTING PLAYERS IN A VEHICLE</div>\n<div style=\'border: 2px solid blue;padding: 5px;\'>Don\'t use an ipairs loop with the table returned by this function. It will skip the driver, as ipairs starts at 1 and the driver seat is ID 0. And if there\'s an empty seat, ipairs will stop looping. You should use a pairs loop instead.\n<syntaxhighlight lang="lua">\nlocal counter = 0\nfor seat, player in pairs(getVehicleOccupants(pseudoVehicle)) do\n    counter = counter + 1\nend\noutputDebugString("Players in your vehicle: ".. counter)\n</syntaxhighlight>\n</div>'), oop=FunctionOOP(class_name='vehicle', method_name='getOccupants', field='occupants}}\n===Required Arguments=== \n*\'\'\'theVehicle:\'\'\' the [[vehicle]] of which you wish to retrieve the occupants.\n\n===Returns===\nReturns a [[table]] with seat ID as an index and the occupant as an element like this: table[seat] = occupant\n\nReturns \'\'false\'\' if an invalid vehicle was passed or if the vehicle has no seats (like a trailer)\n\n<div style=\'font-weight: bold;background:blue;color:white;padding:2px; padding-left:8px;\'>COUNTING PLAYERS IN A VEHICLE</div>\n<div style=\'border: 2px solid blue;padding: 5px;\'>Don\'t use an ipairs loop with the table returned by this function. It will skip the driver, as ipairs starts at 1 and the driver seat is ID 0. And if there\'s an empty seat, ipairs will stop looping. You should use a pairs loop instead.\n<syntaxhighlight lang="lua">\nlocal counter = 0\n\nfor seat, player in pairs(getVehicleOccupants(pseudoVehicle)) do\n    counter = counter + 1\nend\n\noutputDebugString("Players in your vehicle: ".. counter)\n</syntaxhighlight>\n</div>\n\n'), url=FunctionUrl(url='/wiki/GetVehicleOccupants', name='getVehicleOccupants', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleOccupants', return_types=['table'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets all peds sitting in the specified vehicle.', arguments={'theVehicle': 'the vehicle of which you wish to retrieve the occupants.'}, result='Returns a [[table]] with seat ID as an index and the occupant as an element like this: table[seat] = occupant\nReturns \'\'false\'\' if an invalid vehicle was passed or if the vehicle has no seats (like a trailer)\n<div style=\'font-weight: bold;background:blue;color:white;padding:2px; padding-left:8px;\'>COUNTING PLAYERS IN A VEHICLE</div>\n<div style=\'border: 2px solid blue;padding: 5px;\'>Don\'t use an ipairs loop with the table returned by this function. It will skip the driver, as ipairs starts at 1 and the driver seat is ID 0. And if there\'s an empty seat, ipairs will stop looping. You should use a pairs loop instead.\n<syntaxhighlight lang="lua">\nlocal counter = 0\nfor seat, player in pairs(getVehicleOccupants(pseudoVehicle)) do\n    counter = counter + 1\nend\noutputDebugString("Players in your vehicle: ".. counter)\n</syntaxhighlight>\n</div>'), oop=FunctionOOP(class_name='vehicle', method_name='getOccupants', field='occupants}}\n===Required Arguments=== \n*\'\'\'theVehicle:\'\'\' the [[vehicle]] of which you wish to retrieve the occupants.\n\n===Returns===\nReturns a [[table]] with seat ID as an index and the occupant as an element like this: table[seat] = occupant\n\nReturns \'\'false\'\' if an invalid vehicle was passed or if the vehicle has no seats (like a trailer)\n\n<div style=\'font-weight: bold;background:blue;color:white;padding:2px; padding-left:8px;\'>COUNTING PLAYERS IN A VEHICLE</div>\n<div style=\'border: 2px solid blue;padding: 5px;\'>Don\'t use an ipairs loop with the table returned by this function. It will skip the driver, as ipairs starts at 1 and the driver seat is ID 0. And if there\'s an empty seat, ipairs will stop looping. You should use a pairs loop instead.\n<syntaxhighlight lang="lua">\nlocal counter = 0\n\nfor seat, player in pairs(getVehicleOccupants(pseudoVehicle)) do\n    counter = counter + 1\nend\n\noutputDebugString("Players in your vehicle: ".. counter)\n</syntaxhighlight>\n</div>\n\n'), url=FunctionUrl(url='/wiki/GetVehicleOccupants', name='getVehicleOccupants', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleOverrideLights', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to find out the current state of the override-lights setting of a vehicle.', arguments={'theVehicle': ': the vehicle you wish to retrieve the override lights setting of.'}, result='Returns an integer value: 0 (No override), 1 (Force off) or 2 (Force on).'), oop=FunctionOOP(class_name='vehicle', method_name='getOverrideLights', field='overrideLights'), url=FunctionUrl(url='/wiki/GetVehicleOverrideLights', name='getVehicleOverrideLights', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleOverrideLights', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to find out the current state of the override-lights setting of a vehicle.', arguments={'theVehicle': ': the vehicle you wish to retrieve the override lights setting of.'}, result='Returns an integer value: 0 (No override), 1 (Force off) or 2 (Force on).'), oop=FunctionOOP(class_name='vehicle', method_name='getOverrideLights', field='overrideLights'), url=FunctionUrl(url='/wiki/GetVehicleOverrideLights', name='getVehicleOverrideLights', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehiclePaintjob', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the current paintjob on the specified vehicle. <br />', arguments={'theVehicle': ': the vehicle you wish to get the paintjob of.'}, result="Returns an integer representing the current paintjob on the vehicle. <br />\n* '''0''': The first paintjob\n* '''1''': The second paintjob\n* '''2''': The third paintjob\n* '''3''': Default paintjob (no paintjob)\n{{Note|Always returns 3 if paintjobs are not supported for the vehicle.}}"), oop=FunctionOOP(class_name='vehicle', method_name='getPaintjob', field='paintjob'), url=FunctionUrl(url='/wiki/GetVehiclePaintjob', name='getVehiclePaintjob', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehiclePaintjob', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the current paintjob on the specified vehicle. <br />', arguments={'theVehicle': ': the vehicle you wish to get the paintjob of.'}, result="Returns an integer representing the current paintjob on the vehicle. <br />\n* '''0''': The first paintjob\n* '''1''': The second paintjob\n* '''2''': The third paintjob\n* '''3''': Default paintjob (no paintjob)\n{{Note|Always returns 3 if paintjobs are not supported for the vehicle.}}"), oop=FunctionOOP(class_name='vehicle', method_name='getPaintjob', field='paintjob'), url=FunctionUrl(url='/wiki/GetVehiclePaintjob', name='getVehiclePaintjob', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehiclePanelState', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='panel', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current state of a specifed panel on the vehicle. A vehicle can have up to 7 panels.', arguments={'theVehicle': 'the vehicle that you wish to know the panel state of.', 'panel': 'an integer specifying the panel you want to know the state of. Not every vehicle has every panel. Possible values are:', '0': 'Front-left panel', '1': 'Front-right panel', '2': 'Rear-left panel', '3': 'Rear-right panel', '4': 'Windscreen', '5': 'Front bumper', '6': 'Rear bumper'}, result='Returns an [[int]] indicating the state of the specified the panel. This is a value between 0 and 3, with 0 indicating the panel is undamaged and 3 indicating it is very damaged.'), oop=FunctionOOP(class_name='vehicle', method_name='getPanelState', field=None), url=FunctionUrl(url='/wiki/GetVehiclePanelState', name='getVehiclePanelState', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehiclePanelState', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='panel', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current state of a specifed panel on the vehicle. A vehicle can have up to 7 panels.', arguments={'theVehicle': 'the vehicle that you wish to know the panel state of.', 'panel': 'an integer specifying the panel you want to know the state of. Not every vehicle has every panel. Possible values are:', '0': 'Front-left panel', '1': 'Front-right panel', '2': 'Rear-left panel', '3': 'Rear-right panel', '4': 'Windscreen', '5': 'Front bumper', '6': 'Rear bumper'}, result='Returns an [[int]] indicating the state of the specified the panel. This is a value between 0 and 3, with 0 indicating the panel is undamaged and 3 indicating it is very damaged.'), oop=FunctionOOP(class_name='vehicle', method_name='getPanelState', field=None), url=FunctionUrl(url='/wiki/GetVehiclePanelState', name='getVehiclePanelState', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehiclePlateText', return_types=['string'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to retrieve the text on the number plate of a specified vehicle.', arguments={'theVehicle': 'the vehicle that you wish to retrieve the plate text from.'}, result="Returns a ''string'' that corresponds to the plate on the text, ''false'' if a bad argument was passed or if it is not a vehicle. Every vehicle (including planes, boats, etc.) has a numberplate, even if it's not visible."), oop=FunctionOOP(class_name='vehicle', method_name='getPlateText', field='plateText'), url=FunctionUrl(url='/wiki/GetVehiclePlateText', name='getVehiclePlateText', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehiclePlateText', return_types=['string'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to retrieve the text on the number plate of a specified vehicle.', arguments={'theVehicle': 'the vehicle that you wish to retrieve the plate text from.'}, result="Returns a ''string'' that corresponds to the plate on the text, ''false'' if a bad argument was passed or if it is not a vehicle. Every vehicle (including planes, boats, etc.) has a numberplate, even if it's not visible."), oop=FunctionOOP(class_name='vehicle', method_name='getPlateText', field='plateText'), url=FunctionUrl(url='/wiki/GetVehiclePlateText', name='getVehiclePlateText', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleSirens', return_types=['table'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets the properties of a vehicle's sirens.\n}}", arguments={'theVehicle': 'The vehicle to get siren information of.'}, result='If the vehicle is invalid, it returns \'\'false\'\'. Otherwise, returns a \'\'table\'\' with sub tables containing the properties of each siren point in the following manner:\n<syntaxhighlight lang="lua">\n[float]   SirenData[sirenPoint].x\n[float]   SirenData[sirenPoint].y\n[float]   SirenData[sirenPoint].z\n[int]     SirenData[sirenPoint].Red\n[int]     SirenData[sirenPoint].Green\n[int]     SirenData[sirenPoint].Blue\n[int]     SirenData[sirenPoint].Alpha\n[int]     SirenData[sirenPoint].Min_Alpha\n</syntaxhighlight>'), oop=FunctionOOP(class_name='vehicle', method_name='getSirens', field='sirens'), url=FunctionUrl(url='/wiki/GetVehicleSirens', name='getVehicleSirens', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleSirens', return_types=['table'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets the properties of a vehicle's sirens.\n}}", arguments={'theVehicle': 'The vehicle to get siren information of.'}, result='If the vehicle is invalid, it returns \'\'false\'\'. Otherwise, returns a \'\'table\'\' with sub tables containing the properties of each siren point in the following manner:\n<syntaxhighlight lang="lua">\n[float]   SirenData[sirenPoint].x\n[float]   SirenData[sirenPoint].y\n[float]   SirenData[sirenPoint].z\n[int]     SirenData[sirenPoint].Red\n[int]     SirenData[sirenPoint].Green\n[int]     SirenData[sirenPoint].Blue\n[int]     SirenData[sirenPoint].Alpha\n[int]     SirenData[sirenPoint].Min_Alpha\n</syntaxhighlight>'), oop=FunctionOOP(class_name='vehicle', method_name='getSirens', field='sirens'), url=FunctionUrl(url='/wiki/GetVehicleSirens', name='getVehicleSirens', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleSirensOn', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns whether the sirens are turned on for the specified vehicle.', arguments={'theVehicle': 'The vehicle that will be checked.'}, result="Returns ''true'' if the sirens are turned on for the specified vehicle, ''false'' if the sirens are turned off for the specified vehicle, if the vehicle doesn't have sirens or if invalid arguments are specified."), oop=FunctionOOP(class_name='vehicle', method_name='areSirensOn', field='sirensOn'), url=FunctionUrl(url='/wiki/GetVehicleSirensOn', name='getVehicleSirensOn', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleSirensOn', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns whether the sirens are turned on for the specified vehicle.', arguments={'theVehicle': 'The vehicle that will be checked.'}, result="Returns ''true'' if the sirens are turned on for the specified vehicle, ''false'' if the sirens are turned off for the specified vehicle, if the vehicle doesn't have sirens or if invalid arguments are specified."), oop=FunctionOOP(class_name='vehicle', method_name='areSirensOn', field='sirensOn'), url=FunctionUrl(url='/wiki/GetVehicleSirensOn', name='getVehicleSirensOn', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleSirenParams', return_types=['table'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function get the parameters of a vehicles siren.\n}}', arguments={'theVehicle': 'The vehicle to get the siren parameters of'}, result='Returns a \'\'table\'\' with the siren count, siren type and a sub table for the four flags. False otherwise.\n<syntaxhighlight lang="lua">\n[int]   SirenParams.SirenCount\n[int]   SirenParams.SirenType\n[table] SirenParams.Flags\n [bool] SirenParams.Flags["360"]\n [bool] SirenParams.Flags.DoLOSCheck\n [bool] SirenParams.Flags.UseRandomiser\n [bool] SirenParams.Flags.Silent\n</syntaxhighlight>'), oop=FunctionOOP(class_name='vehicle', method_name='getSirenParams', field='sirenParams}}\n===Required Arguments=== \n*\'\'\'theVehicle:\'\'\' The vehicle to get the siren parameters of\n\n===Returns===\nReturns a \'\'table\'\' with the siren count, siren type and a sub table for the four flags. False otherwise.\n\n<syntaxhighlight lang="lua">\n[int]   SirenParams.SirenCount\n[int]   SirenParams.SirenType\n[table] SirenParams.Flags\n [bool] SirenParams.Flags["360"]\n [bool] SirenParams.Flags.DoLOSCheck\n [bool] SirenParams.Flags.UseRandomiser\n [bool] SirenParams.Flags.Silent\n</syntaxhighlight>\n\n'), url=FunctionUrl(url='/wiki/GetVehicleSirenParams', name='getVehicleSirenParams', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleSirenParams', return_types=['table'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function get the parameters of a vehicles siren.\n}}', arguments={'theVehicle': 'The vehicle to get the siren parameters of'}, result='Returns a \'\'table\'\' with the siren count, siren type and a sub table for the four flags. False otherwise.\n<syntaxhighlight lang="lua">\n[int]   SirenParams.SirenCount\n[int]   SirenParams.SirenType\n[table] SirenParams.Flags\n [bool] SirenParams.Flags["360"]\n [bool] SirenParams.Flags.DoLOSCheck\n [bool] SirenParams.Flags.UseRandomiser\n [bool] SirenParams.Flags.Silent\n</syntaxhighlight>'), oop=FunctionOOP(class_name='vehicle', method_name='getSirenParams', field='sirenParams}}\n===Required Arguments=== \n*\'\'\'theVehicle:\'\'\' The vehicle to get the siren parameters of\n\n===Returns===\nReturns a \'\'table\'\' with the siren count, siren type and a sub table for the four flags. False otherwise.\n\n<syntaxhighlight lang="lua">\n[int]   SirenParams.SirenCount\n[int]   SirenParams.SirenType\n[table] SirenParams.Flags\n [bool] SirenParams.Flags["360"]\n [bool] SirenParams.Flags.DoLOSCheck\n [bool] SirenParams.Flags.UseRandomiser\n [bool] SirenParams.Flags.Silent\n</syntaxhighlight>\n\n'), url=FunctionUrl(url='/wiki/GetVehicleSirenParams', name='getVehicleSirenParams', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleTowedByVehicle', return_types=['vehicle'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the vehicle being towed by another.', arguments={'theVehicle': ': The vehicle you wish to get the towed vehicle from.'}, result="Returns the vehicle that ''theVehicle'' is towing, ''false'' if it isn't towing a vehicle."), oop=FunctionOOP(class_name='vehicle', method_name='getTowedByVehicle', field="towedByVehicle}}\n===Required Arguments===\n*'''theVehicle''': The [[vehicle]] you wish to get the towed vehicle from.\n\n==Returns==\nReturns the vehicle that ''theVehicle'' is towing, ''false'' if it isn't towing a vehicle.\n\n"), url=FunctionUrl(url='/wiki/GetVehicleTowedByVehicle', name='getVehicleTowedByVehicle', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleTowedByVehicle', return_types=['vehicle'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the vehicle being towed by another.', arguments={'theVehicle': ': The vehicle you wish to get the towed vehicle from.'}, result="Returns the vehicle that ''theVehicle'' is towing, ''false'' if it isn't towing a vehicle."), oop=FunctionOOP(class_name='vehicle', method_name='getTowedByVehicle', field="towedByVehicle}}\n===Required Arguments===\n*'''theVehicle''': The [[vehicle]] you wish to get the towed vehicle from.\n\n==Returns==\nReturns the vehicle that ''theVehicle'' is towing, ''false'' if it isn't towing a vehicle.\n\n"), url=FunctionUrl(url='/wiki/GetVehicleTowedByVehicle', name='getVehicleTowedByVehicle', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleTowingVehicle', return_types=['vehicle'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the vehicle that is towing another.', arguments={'theVehicle': ': the vehicle being towed.'}, result="* The vehicle that ''theVehicle'' is being towed by.\n* ''false'' if it isn't being towed."), oop=FunctionOOP(class_name='vehicle', method_name='getTowingVehicle', field="towingVehicle}}\n===Required Arguments===\n*'''theVehicle''': the [[vehicle]] being towed.\n\n==Returns==\n* The vehicle that ''theVehicle'' is being towed by.\n* ''false'' if it isn't being towed.\n\n"), url=FunctionUrl(url='/wiki/GetVehicleTowingVehicle', name='getVehicleTowingVehicle', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleTowingVehicle', return_types=['vehicle'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to get the vehicle that is towing another.', arguments={'theVehicle': ': the vehicle being towed.'}, result="* The vehicle that ''theVehicle'' is being towed by.\n* ''false'' if it isn't being towed."), oop=FunctionOOP(class_name='vehicle', method_name='getTowingVehicle', field="towingVehicle}}\n===Required Arguments===\n*'''theVehicle''': the [[vehicle]] being towed.\n\n==Returns==\n* The vehicle that ''theVehicle'' is being towed by.\n* ''false'' if it isn't being towed.\n\n"), url=FunctionUrl(url='/wiki/GetVehicleTowingVehicle', name='getVehicleTowingVehicle', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleTurretPosition', return_types=['float,', 'float'], arguments=[FunctionArgument(name='turretVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets the position of a vehicle's turret, if it has one. Vehicles with turrets include firetrucks and tanks.", arguments={'turretVehicle': ': The vehicle whose turret position you want to retrieve. This should be a vehicle with a turret.'}, result="Returns two [[float]]s for the X (horizontal) and Y (vertical) axis rotation respectively. These values are in radians. The function will return ''0, 0'' if the vehicle is not a vehicle with a turret. "), oop=FunctionOOP(class_name='vehicle', method_name='getTurretPosition', field='turretPosition'), url=FunctionUrl(url='/wiki/GetVehicleTurretPosition', name='getVehicleTurretPosition', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleTurretPosition', return_types=['float,', 'float'], arguments=[FunctionArgument(name='turretVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets the position of a vehicle's turret, if it has one. Vehicles with turrets include firetrucks and tanks.", arguments={'turretVehicle': ': The vehicle whose turret position you want to retrieve. This should be a vehicle with a turret.'}, result="Returns two [[float]]s for the X (horizontal) and Y (vertical) axis rotation respectively. These values are in radians. The function will return ''0, 0'' if the vehicle is not a vehicle with a turret. "), oop=FunctionOOP(class_name='vehicle', method_name='getTurretPosition', field='turretPosition'), url=FunctionUrl(url='/wiki/GetVehicleTurretPosition', name='getVehicleTurretPosition', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleType', return_types=['string'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the type of a vehicle (such as if it is a car or a boat).\n}}', arguments={'vehicle': "The vehicle element to get the type of.\n'''OR'''", 'modelID': 'A vehicle model ID'}, result="Returns a ''string'' with vehicle type or ''false'' if an invalid modelID has been supplied, or an empty string if the vehicle is blocked internally (some trailers).\nPossible strings returned:\n{{VehicleTypes}}"), oop=FunctionOOP(class_name='vehicle', method_name='getVehicleType', field='vehicleType}}\n\'\'\'OR\'\'\'\n\n<syntaxhighlight lang="lua">\nstring getVehicleType ( int modelId )\n</syntaxhighlight>\n\n===Required Arguments=== \n*\'\'\'vehicle:\'\'\' The vehicle element to get the type of.\n\n\'\'\'OR\'\'\'\n\n*\'\'\'modelID:\'\'\' A vehicle model ID\n\n===Returns===\nReturns a \'\'string\'\' with vehicle type or \'\'false\'\' if an invalid modelID has been supplied, or an empty string if the vehicle is blocked internally (some trailers).\n\nPossible strings returned:\n{{VehicleTypes}}\n\n'), url=FunctionUrl(url='/wiki/GetVehicleType', name='getVehicleType', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleType', return_types=['string'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function retrieves the type of a vehicle (such as if it is a car or a boat).\n}}', arguments={'vehicle': "The vehicle element to get the type of.\n'''OR'''", 'modelID': 'A vehicle model ID'}, result="Returns a ''string'' with vehicle type or ''false'' if an invalid modelID has been supplied, or an empty string if the vehicle is blocked internally (some trailers).\nPossible strings returned:\n{{VehicleTypes}}"), oop=FunctionOOP(class_name='vehicle', method_name='getVehicleType', field='vehicleType}}\n\'\'\'OR\'\'\'\n\n<syntaxhighlight lang="lua">\nstring getVehicleType ( int modelId )\n</syntaxhighlight>\n\n===Required Arguments=== \n*\'\'\'vehicle:\'\'\' The vehicle element to get the type of.\n\n\'\'\'OR\'\'\'\n\n*\'\'\'modelID:\'\'\' A vehicle model ID\n\n===Returns===\nReturns a \'\'string\'\' with vehicle type or \'\'false\'\' if an invalid modelID has been supplied, or an empty string if the vehicle is blocked internally (some trailers).\n\nPossible strings returned:\n{{VehicleTypes}}\n\n'), url=FunctionUrl(url='/wiki/GetVehicleType', name='getVehicleType', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleUpgradeOnSlot', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='slot', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theVehicle': ': The vehicle whose upgrade you want to retrieve.', 'slot': ': The slot id of the upgrade. (Upgrade list ordered by slot number)'}, result="Returns an ''integer'' with the upgrade on the slot if correct arguments were passed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetVehicleUpgradeOnSlot', name='getVehicleUpgradeOnSlot', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleUpgradeOnSlot', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='slot', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theVehicle': ': The vehicle whose upgrade you want to retrieve.', 'slot': ': The slot id of the upgrade. (Upgrade list ordered by slot number)'}, result="Returns an ''integer'' with the upgrade on the slot if correct arguments were passed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetVehicleUpgradeOnSlot', name='getVehicleUpgradeOnSlot', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleUpgradeSlotName', return_types=['string'], arguments=[FunctionArgument(name='slot', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the name of an upgrade slot name (e.g. roof, spoiler).', arguments={'slot/upgrade': 'the slot ID or corresponding upgrade ID of which you want the name.\n{{Vehicle Upgrades}}'}, result="Returns a ''string'' with the slot name if a valid slot or upgrade ID was given, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetVehicleUpgradeSlotName', name='getVehicleUpgradeSlotName', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleUpgradeSlotName', return_types=['string'], arguments=[FunctionArgument(name='slot', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the name of an upgrade slot name (e.g. roof, spoiler).', arguments={'slot/upgrade': 'the slot ID or corresponding upgrade ID of which you want the name.\n{{Vehicle Upgrades}}'}, result="Returns a ''string'' with the slot name if a valid slot or upgrade ID was given, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetVehicleUpgradeSlotName', name='getVehicleUpgradeSlotName', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleUpgrades', return_types=['table'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a table of all the upgrades on a specifed vehicle.', arguments={'theVehicle': 'The vehicle you wish to retrieve the upgrades of.'}, result="Returns a ''table'' of all the upgrades on each slot of a vehicle, which may be empty, or ''false'' if a valid vehicle is not passed."), oop=FunctionOOP(class_name='vehicle', method_name='getUpgrades', field="upgrades}}\n===Required Arguments=== \n*'''theVehicle:''' The [[vehicle]] you wish to retrieve the upgrades of.\n\n===Returns===\nReturns a ''table'' of all the upgrades on each slot of a vehicle, which may be empty, or ''false'' if a valid vehicle is not passed.\n\n"), url=FunctionUrl(url='/wiki/GetVehicleUpgrades', name='getVehicleUpgrades', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleUpgrades', return_types=['table'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a table of all the upgrades on a specifed vehicle.', arguments={'theVehicle': 'The vehicle you wish to retrieve the upgrades of.'}, result="Returns a ''table'' of all the upgrades on each slot of a vehicle, which may be empty, or ''false'' if a valid vehicle is not passed."), oop=FunctionOOP(class_name='vehicle', method_name='getUpgrades', field="upgrades}}\n===Required Arguments=== \n*'''theVehicle:''' The [[vehicle]] you wish to retrieve the upgrades of.\n\n===Returns===\nReturns a ''table'' of all the upgrades on each slot of a vehicle, which may be empty, or ''false'' if a valid vehicle is not passed.\n\n"), url=FunctionUrl(url='/wiki/GetVehicleUpgrades', name='getVehicleUpgrades', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleVariant', return_types=['int,', 'int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the variant of a specified vehicle. In GTA SA some vehicles are different for example the labelling on trucks or the contents of a pick-up truck and the varying types of a motor bike. For the default GTA SA variant list see: [[Vehicle variants]]', arguments={'theVehicle': 'A handle to the vehicle that you want to get the variant of.'}, result="On success:\n* '''int''': An integer for the first vehicle variant see [[Vehicle variants]]\n* '''int''': An integer for the second vehicle variant see [[Vehicle variants]]\nOn failure:\n* '''bool''': False because the specified vehicle didn't exist"), oop=FunctionOOP(class_name='vehicle', method_name='getVariant', field=None), url=FunctionUrl(url='/wiki/GetVehicleVariant', name='getVehicleVariant', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleVariant', return_types=['int,', 'int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the variant of a specified vehicle. In GTA SA some vehicles are different for example the labelling on trucks or the contents of a pick-up truck and the varying types of a motor bike. For the default GTA SA variant list see: [[Vehicle variants]]', arguments={'theVehicle': 'A handle to the vehicle that you want to get the variant of.'}, result="On success:\n* '''int''': An integer for the first vehicle variant see [[Vehicle variants]]\n* '''int''': An integer for the second vehicle variant see [[Vehicle variants]]\nOn failure:\n* '''bool''': False because the specified vehicle didn't exist"), oop=FunctionOOP(class_name='vehicle', method_name='getVariant', field=None), url=FunctionUrl(url='/wiki/GetVehicleVariant', name='getVehicleVariant', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleWheelFrictionState', return_types=['int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='wheel', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theVehicle': 'The vehicle that you wish to get the wheel friction state.', 'wheel': 'The wheel you want to check. (0: front left, 1: rear left, 2: front right, 3: rear right)'}, result="Returns a [[int]] indicating the wheel friction state. This value can be:\n* '''0:''' Normal friction\n* '''1:''' Slip with acceleration (only for driving wheels)\n* '''2:''' Slip without acceleration\n* '''3:''' Locked wheel (on brake on handbrake)."), oop=None, url=FunctionUrl(url='/wiki/GetVehicleWheelFrictionState', name='getVehicleWheelFrictionState', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehicleWheelScale', return_types=['float'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theVehicle': ': The vehicle to get its wheel scale of.'}, result='Returns the wheel scale of the specified vehicle as a decimal number, or an error if the vehicle is invalid. For more information about the returned number, see [[setVehicleWheelScale]].'), oop=FunctionOOP(class_name='vehicle', method_name='getWheelScale', field='wheelScale'), url=FunctionUrl(url='/wiki/GetVehicleWheelScale', name='getVehicleWheelScale', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getVehicleWheelStates', return_types=['int,', 'int,', 'int,', 'int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current states of all the wheels on the vehicle.\nNo vehicles have more than 4 wheels, if they appear to they will be duplicating other wheels.', arguments={'theVehicle': 'A handle to the vehicle that you wish to know the wheel states of.'}, result="Returns 4 [[int]]s indicating the states of the wheels (front left, rear left, front right, rear right). These values can be:\n* '''0:''' Inflated\n* '''1:''' Flat\n* '''2:''' Fallen off\n* '''3:''' Collisionless "), oop=FunctionOOP(class_name='vehicle', method_name='getWheelStates', field=None), url=FunctionUrl(url='/wiki/GetVehicleWheelStates', name='getVehicleWheelStates', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getVehicleWheelStates', return_types=['int,', 'int,', 'int,', 'int'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns the current states of all the wheels on the vehicle.\nNo vehicles have more than 4 wheels, if they appear to they will be duplicating other wheels.', arguments={'theVehicle': 'A handle to the vehicle that you wish to know the wheel states of.'}, result="Returns 4 [[int]]s indicating the states of the wheels (front left, rear left, front right, rear right). These values can be:\n* '''0:''' Inflated\n* '''1:''' Flat\n* '''2:''' Fallen off\n* '''3:''' Collisionless "), oop=FunctionOOP(class_name='vehicle', method_name='getWheelStates', field=None), url=FunctionUrl(url='/wiki/GetVehicleWheelStates', name='getVehicleWheelStates', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isTrainChainEngine', return_types=['bool'], arguments=[FunctionArgument(name='theTrain', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="This function checks if a [[Element/Vehicle|train]] is a chain engine (moves the rest of the chain's carriages) or not.\n}}", arguments={'theTrain': 'a Element/Vehicle|train to check if its a chain engine or not.'}, result="* ''true'' if a [[Element/Vehicle|train]] was passed to the function and if it's a chain engine.\n* ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='isTrainChainEngine', field="chainEngine}}}}\n===Arguments=== \n*'''theTrain:''' a [[Element/Vehicle"), url=FunctionUrl(url='/wiki/IsTrainChainEngine', name='isTrainChainEngine', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isTrainDerailable', return_types=['bool'], arguments=[FunctionArgument(name='vehicleToCheck', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will check if a train or tram is derailable.', arguments={'vehicleToCheck': 'The vehicle you wish to check.'}, result="Returns ''true'' if the train is derailable, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='isDerailable', field='derailable'), url=FunctionUrl(url='/wiki/IsTrainDerailable', name='isTrainDerailable', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isTrainDerailable', return_types=['bool'], arguments=[FunctionArgument(name='vehicleToCheck', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will check if a train or tram is derailable.', arguments={'vehicleToCheck': 'The vehicle you wish to check.'}, result="Returns ''true'' if the train is derailable, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='isDerailable', field='derailable'), url=FunctionUrl(url='/wiki/IsTrainDerailable', name='isTrainDerailable', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isTrainDerailed', return_types=['bool'], arguments=[FunctionArgument(name='vehicleToCheck', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will check if a train or tram is derailed.', arguments={'vehicleToCheck': 'the vehicle that you wish to check is derailed.'}, result="Returns ''true'' if the train is derailed, ''false'' if the train is still on the rails"), oop=FunctionOOP(class_name='vehicle', method_name='isDerailed', field='derailed'), url=FunctionUrl(url='/wiki/IsTrainDerailed', name='isTrainDerailed', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isTrainDerailed', return_types=['bool'], arguments=[FunctionArgument(name='vehicleToCheck', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will check if a train or tram is derailed.', arguments={'vehicleToCheck': 'the vehicle that you wish to check is derailed.'}, result="Returns ''true'' if the train is derailed, ''false'' if the train is still on the rails"), oop=FunctionOOP(class_name='vehicle', method_name='isDerailed', field='derailed'), url=FunctionUrl(url='/wiki/IsTrainDerailed', name='isTrainDerailed', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isVehicleBlown', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to determine whether a vehicle is blown or still intact.', arguments={'theVehicle': 'The vehicle that you want to obtain the blown status of.'}, result="Returns ''true'' if the vehicle specified has blown up, ''false'' if it is still intact or the vehicle specified is invalid."), oop=FunctionOOP(class_name='vehicle', method_name='isBlown', field='blown'), url=FunctionUrl(url='/wiki/IsVehicleBlown', name='isVehicleBlown', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isVehicleBlown', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to determine whether a vehicle is blown or still intact.', arguments={'theVehicle': 'The vehicle that you want to obtain the blown status of.'}, result="Returns ''true'' if the vehicle specified has blown up, ''false'' if it is still intact or the vehicle specified is invalid."), oop=FunctionOOP(class_name='vehicle', method_name='isBlown', field='blown'), url=FunctionUrl(url='/wiki/IsVehicleBlown', name='isVehicleBlown', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isVehicleDamageProof', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if a vehicle is damage proof (set with [[setVehicleDamageProof]]).', arguments={'theVehicle': 'the vehicle whose invincibility status we want to check.'}, result="Returns ''true'' if the vehicle is damage proof, ''false'' if it isn't or if invalid arguments were passed."), oop=FunctionOOP(class_name='vehicle', method_name='isDamageProof', field='damageProof'), url=FunctionUrl(url='/wiki/IsVehicleDamageProof', name='isVehicleDamageProof', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isVehicleDamageProof', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if a vehicle is damage proof (set with [[setVehicleDamageProof]]).', arguments={'theVehicle': 'the vehicle whose invincibility status we want to check.'}, result="Returns ''true'' if the vehicle is damage proof, ''false'' if it isn't or if invalid arguments were passed."), oop=FunctionOOP(class_name='vehicle', method_name='isDamageProof', field='damageProof'), url=FunctionUrl(url='/wiki/IsVehicleDamageProof', name='isVehicleDamageProof', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isVehicleFuelTankExplodable', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="This will tell you if a vehicle's petrol tank is explodable.", arguments={'theVehicle': 'The vehicle that you want to obtain the fuel tank status of.'}, result="Returns ''true'' if the specified vehicle is valid and its fuel tank is explodable, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsVehicleFuelTankExplodable', name='isVehicleFuelTankExplodable', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isVehicleFuelTankExplodable', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="This will tell you if a vehicle's petrol tank is explodable.", arguments={'theVehicle': 'The vehicle that you want to obtain the fuel tank status of.'}, result="Returns ''true'' if the specified vehicle is valid and its fuel tank is explodable, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsVehicleFuelTankExplodable', name='isVehicleFuelTankExplodable', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isVehicleLocked', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This will tell you if a vehicle is locked.', arguments={'theVehicle': 'The vehicle that you want to obtain the locked status of.'}, result="Returns ''true'' if the vehicle specified is locked, ''false'' if is unlocked or the vehicle specified is invalid."), oop=FunctionOOP(class_name='vehicle', method_name='isLocked', field='locked'), url=FunctionUrl(url='/wiki/IsVehicleLocked', name='isVehicleLocked', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isVehicleLocked', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This will tell you if a vehicle is locked.', arguments={'theVehicle': 'The vehicle that you want to obtain the locked status of.'}, result="Returns ''true'' if the vehicle specified is locked, ''false'' if is unlocked or the vehicle specified is invalid."), oop=FunctionOOP(class_name='vehicle', method_name='isLocked', field='locked'), url=FunctionUrl(url='/wiki/IsVehicleLocked', name='isVehicleLocked', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isVehicleNitroActivated', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if nitro is activated on the [[vehicle]].\n}}', arguments={'theVehicle': 'The vehicle, which you want to check for an activation.'}, result="Returns ''true'' if the nitro is currently activated on the vehicle, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsVehicleNitroActivated', name='isVehicleNitroActivated', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isVehicleNitroRecharging', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks if nitro is recharging on the [[vehicle]].\n}}', arguments={'theVehicle': 'The vehicle, which you want to check for recharging.'}, result="Returns ''true'' if the nitro is currently recharging on the vehicle, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsVehicleNitroRecharging', name='isVehicleNitroRecharging', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isVehicleOnGround', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='Checks to see if a vehicle has contact with the ground.', arguments={'theVehicle': 'The vehicle you wish to check.'}, result="Returns ''true'' if vehicle is on the ground, ''false'' if it is not."), oop=FunctionOOP(class_name='vehicle', method_name='isOnGround', field="onGround}}\n===Required Arguments=== \n*'''theVehicle:''' The vehicle you wish to check.\n\n===Returns===\nReturns ''true'' if vehicle is on the ground, ''false'' if it is not.\n\n"), url=FunctionUrl(url='/wiki/IsVehicleOnGround', name='isVehicleOnGround', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isVehicleOnGround', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='Checks to see if a vehicle has contact with the ground.', arguments={'theVehicle': 'The vehicle you wish to check.'}, result="Returns ''true'' if vehicle is on the ground, ''false'' if it is not."), oop=FunctionOOP(class_name='vehicle', method_name='isOnGround', field="onGround}}\n===Required Arguments=== \n*'''theVehicle:''' The vehicle you wish to check.\n\n===Returns===\nReturns ''true'' if vehicle is on the ground, ''false'' if it is not.\n\n"), url=FunctionUrl(url='/wiki/IsVehicleOnGround', name='isVehicleOnGround', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isVehicleTaxiLightOn', return_types=['bool'], arguments=[FunctionArgument(name='taxi', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will get the taxi light state of a taxi (vehicle IDs 420 and 438)', arguments={'taxi': 'The vehicle element of the taxi that you wish to get the light state of.'}, result="Returns ''true'' if the light is on, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='isTaxiLightOn', field='taxiLightOn'), url=FunctionUrl(url='/wiki/IsVehicleTaxiLightOn', name='isVehicleTaxiLightOn', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isVehicleTaxiLightOn', return_types=['bool'], arguments=[FunctionArgument(name='taxi', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will get the taxi light state of a taxi (vehicle IDs 420 and 438)', arguments={'taxi': 'The vehicle element of the taxi that you wish to get the light state of.'}, result="Returns ''true'' if the light is on, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='isTaxiLightOn', field='taxiLightOn'), url=FunctionUrl(url='/wiki/IsVehicleTaxiLightOn', name='isVehicleTaxiLightOn', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isVehicleWheelOnGround', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='int', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function returns a [[boolean]] whether the [[vehicle]]'s wheel is on ground (true) or in air (false).\n}}", arguments={'theVehicle': 'The vehicle, which you want to check.', 'wheel': 'The wheel name or number, see list below:\n** <code>"front_left"</code> or 0\n** <code>"rear_left"</code> or 1\n** <code>"front_right"</code> or 2\n** <code>"rear_right"</code> or 3'}, result="Returns ''true'' if the vehicle wheel is on ground/collided, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsVehicleWheelOnGround', name='isVehicleWheelOnGround', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isVehicleWindowOpen', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='window', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={}, result=''), oop=None, url=FunctionUrl(url='/wiki/IsVehicleWindowOpen', name='isVehicleWindowOpen', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removeVehicleUpgrade', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='upgrade', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theVehicle': ': The element representing the vehicle you wish to remove the upgrade from', 'upgrade': ': The ID of the upgrade you wish to remove.'}, result="Returns ''true'' if the upgrade was successfully removed from the vehicle, otherwise ''false''."), oop=None, url=FunctionUrl(url='/wiki/RemoveVehicleUpgrade', name='removeVehicleUpgrade', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='removeVehicleUpgrade', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='upgrade', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theVehicle': ': The element representing the vehicle you wish to remove the upgrade from', 'upgrade': ': The ID of the upgrade you wish to remove.'}, result="Returns ''true'' if the upgrade was successfully removed from the vehicle, otherwise ''false''."), oop=None, url=FunctionUrl(url='/wiki/RemoveVehicleUpgrade', name='removeVehicleUpgrade', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='resetVehicleComponentPosition', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theComponent', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function reset to default component position for [[vehicle]].\n}}', arguments={'theVehicle': 'The vehicle you wish to reset component position.', 'theComponent': 'A vehicle component (this is the frame name from the model file of the component you wish to modify)'}, result="Returns ''true'' if the position of the component was reset, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetVehicleComponentPosition', name='resetVehicleComponentPosition', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='resetVehicleComponentRotation', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theComponent', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function reset to default component rotation for [[vehicle]].\n}}', arguments={'theVehicle': 'The vehicle you wish to reset component rotation.', 'theComponent': 'A vehicle component (this is the frame name from the model file of the component you wish to modify)'}, result="Returns ''true'' if the rotation of the component was reset, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetVehicleComponentRotation', name='resetVehicleComponentRotation', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='resetVehicleComponentScale', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theComponent', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function reset to default component scale for [[vehicle]].\n}}', arguments={'theVehicle': 'The vehicle you wish to reset component scale.', 'theComponent': 'A vehicle component (this is the frame name from the model file of the component you wish to modify)'}, result="Returns ''true'' if the scale of the component was reset, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetVehicleComponentScale', name='resetVehicleComponentScale', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='resetVehicleDummyPositions', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False)]), docs=FunctionDoc(description="This function resets the vehicle dependent dummy positions to the vehicle's current model dummy positions.}}", arguments={'theVehicle': 'The vehicle to reset'}, result="Returns ''true'' for success, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='resetDummyPositions', field=None), url=FunctionUrl(url='/wiki/ResetVehicleDummyPositions', name='resetVehicleDummyPositions', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setHeliBladeCollisionsEnabled', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='collisions', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the state of the helicopter blades collisions on the specified vehicle.', arguments={'theVehicle': 'The helicopter that will have the blades collisions set.', 'collisions': 'The state of the helicopter blades collisions.'}, result="Returns ''true'' if the collisions are set for the specified vehicle, ''false'' if the collisions can't be set for the specified vehicle, if the vehicle is not a helicopter or if invalid arguments are specified."), oop=FunctionOOP(class_name='vehicle', method_name='setHeliBladeCollisionsEnabled', field='heliBladeCollisionsEnabled'), url=FunctionUrl(url='/wiki/SetHeliBladeCollisionsEnabled', name='setHeliBladeCollisionsEnabled', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setHelicopterRotorSpeed', return_types=['bool'], arguments=[FunctionArgument(name='heli', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='speed', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the rotor speed of a helicopter.', arguments={'heli': 'the helicopter to adjust the rotor of.', 'speed': 'the new rotor speed. Usual values are 0 if the helicopter stands still, or 0.2 if the rotor is fully spun up. Higher values than normal will not affect the helicopters handling. Negative values are allowed and will make the rotor spin in the opposite direction (pushing the helicopter down).'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setHelicopterRotorSpeed', field='helicopterRotorSpeed'), url=FunctionUrl(url='/wiki/SetHelicopterRotorSpeed', name='setHelicopterRotorSpeed', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setTrainDerailable', return_types=['bool'], arguments=[FunctionArgument(name='derailableVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='derailable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will set a train or tram as derailable. This is, if it can derail when it goes above the maximum speed.', arguments={'derailableVehicle': 'The vehicle that you wish to set derailable.', 'derailable': 'whether the train or tram is derailable. True as derailable, False as non-derailable.'}, result="Returns ''true'' if the state was successfully set, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setDerailable', field='derailable'), url=FunctionUrl(url='/wiki/SetTrainDerailable', name='setTrainDerailable', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setTrainDerailable', return_types=['bool'], arguments=[FunctionArgument(name='derailableVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='derailable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will set a train or tram as derailable. This is, if it can derail when it goes above the maximum speed.', arguments={'derailableVehicle': 'The vehicle that you wish to set derailable.', 'derailable': 'whether the train or tram is derailable. True as derailable, False as non-derailable.'}, result="Returns ''true'' if the state was successfully set, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setDerailable', field='derailable'), url=FunctionUrl(url='/wiki/SetTrainDerailable', name='setTrainDerailable', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setTrainDerailed', return_types=['bool'], arguments=[FunctionArgument(name='vehicleToDerail', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='derailed', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will set a train or tram as derailed.', arguments={'vehicleToDerail': 'The vehicle that you wish to derail.', 'derailed': 'whether the train is derailed.'}, result="Returns ''true'' if the state was successfully set"), oop=FunctionOOP(class_name='vehicle', method_name='setDerailed', field='derailed'), url=FunctionUrl(url='/wiki/SetTrainDerailed', name='setTrainDerailed', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setTrainDerailed', return_types=['bool'], arguments=[FunctionArgument(name='vehicleToDerail', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='derailed', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will set a train or tram as derailed.', arguments={'vehicleToDerail': 'The vehicle that you wish to derail.', 'derailed': 'whether the train is derailed.'}, result="Returns ''true'' if the state was successfully set"), oop=FunctionOOP(class_name='vehicle', method_name='setDerailed', field='derailed'), url=FunctionUrl(url='/wiki/SetTrainDerailed', name='setTrainDerailed', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setTrainDirection', return_types=['bool'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='clockwise', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the direction in which a train or tram drives over the rails (clockwise or counterclockwise).', arguments={'train': 'the train whose direction to change.', 'clockwise': 'if true, will make the train go clockwise. If false, makes it go counterclockwise.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setDirection', field='direction'), url=FunctionUrl(url='/wiki/SetTrainDirection', name='setTrainDirection', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setTrainDirection', return_types=['bool'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='clockwise', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the direction in which a train or tram drives over the rails (clockwise or counterclockwise).', arguments={'train': 'the train whose direction to change.', 'clockwise': 'if true, will make the train go clockwise. If false, makes it go counterclockwise.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setDirection', field='direction'), url=FunctionUrl(url='/wiki/SetTrainDirection', name='setTrainDirection', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setTrainPosition', return_types=['bool'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='position', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the position the train is currently on the track\n}}', arguments={'train': 'the train of which to set the track', 'position': 'the position along the track (0 - 18107 a complete way round)'}, result="Returns ''true'' if the train position was set, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setTrainPosition', field='trainPosition'), url=FunctionUrl(url='/wiki/SetTrainPosition', name='setTrainPosition', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setTrainPosition', return_types=['bool'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='position', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the position the train is currently on the track\n}}', arguments={'train': 'the train of which to set the track', 'position': 'the position along the track (0 - 18107 a complete way round)'}, result="Returns ''true'' if the train position was set, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setTrainPosition', field='trainPosition'), url=FunctionUrl(url='/wiki/SetTrainPosition', name='setTrainPosition', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setTrainSpeed', return_types=['bool'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='speed', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the on-track speed of a train.', arguments={'train': 'the train whose speed to change.', 'speed': 'the new on-track speed of the train. A positive value will make it go clockwise, a negative value counter clockwise.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setSpeed', field='trainSpeed'), url=FunctionUrl(url='/wiki/SetTrainSpeed', name='setTrainSpeed', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setTrainSpeed', return_types=['bool'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='speed', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the on-track speed of a train.', arguments={'train': 'the train whose speed to change.', 'speed': 'the new on-track speed of the train. A positive value will make it go clockwise, a negative value counter clockwise.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setSpeed', field='trainSpeed'), url=FunctionUrl(url='/wiki/SetTrainSpeed', name='setTrainSpeed', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setTrainTrack', return_types=['bool'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='track', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the track of a train\n}}', arguments={'train': 'the train of which to set the track', 'track': 'the track where you want to set the train. It can be 0, 1, 2 or 3.'}, result="Returns ''true'' if the track was set to the train, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setTrack', field='track'), url=FunctionUrl(url='/wiki/SetTrainTrack', name='setTrainTrack', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setTrainTrack', return_types=['bool'], arguments=[FunctionArgument(name='train', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='track', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the track of a train\n}}', arguments={'train': 'the train of which to set the track', 'track': 'the track where you want to set the train. It can be 0, 1, 2 or 3.'}, result="Returns ''true'' if the track was set to the train, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setTrack', field='track'), url=FunctionUrl(url='/wiki/SetTrainTrack', name='setTrainTrack', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleAdjustableProperty', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='element', default_value=None, optional=False), FunctionArgument(name='value', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used for adjusting the movable parts of a model, for example hydra jets or dump truck tray.\nThis function only works on vehicles with adjustable properties.', arguments={'theVehicle': ': The vehicle you wish to change the adjustable property of.', 'value': ': A value from 0 between ?. (Set the adjustable value between 0 and N. 0 is the default value. It is possible to force the setting beyond default maximum, for example setting above 5000 on the dump truck (normal max 2500) will cause the tray to be fully vertical.)'}, result="Returns true if the adjustable property was set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetVehicleAdjustableProperty', name='setVehicleAdjustableProperty', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleColor', return_types=['bool'], arguments=[FunctionArgument(name='veh', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='r1', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g1', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b1', argument_type='int', default_value=None, optional=False), FunctionArgument(name='r2', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g2', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b2', argument_type='int', default_value=None, optional=False), FunctionArgument(name='r3', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g3', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b3', argument_type='int', default_value=None, optional=False), FunctionArgument(name='r4', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g4', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b4', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will set the color of a vehicle using either a RGB format, or the [[Vehicle Colors|standard San Andreas color IDs.]] Vehicles can have up to 4 colors, most of the vehicles have 2 colors only. ', arguments={'theVehicle': 'The vehicle that you wish to set the color of.\n* RGB format:', 'r1, g1, b1': 'Three integers indicating the red, green and blue components of the first (main) color for the vehicle\n* Palette format:', 'p1, p2, p3, p4': 'Exactly four integers indicating the Vehicle Colors|vehicle color IDs from the palette. <br> If a vehicle has fewer than four colours, you must still provide four colours, otherwise the RGB format will be used.', 'r2, g2, b2': 'Three integers indicating the red, green and blue components of the second color for the vehicle', 'r3, g3, b3': 'Three integers indicating the red, green and blue components of the third color for the vehicle', 'r4, g4, b4': 'Three integers indicating the red, green and blue components of the fourth color for the vehicle\n}}'}, result="Returns ''true'' if vehicle's color was set, ''false'' if an invalid vehicle or invalid colors were specified."), oop=FunctionOOP(class_name='vehicle', method_name="setColor}}\n\n===Required Arguments=== \n*'''theVehicle:''' The [[vehicle]] that you wish to set the color of.\n* RGB format:\n** '''r1, g1, b1:''' Three integers indicating the red, green and blue components of the first (main) color for the vehicle\n* Palette format:\n** '''p1, p2, p3, p4:''' Exactly four integers indicating the [[Vehicle Colors", field="vehicle color IDs]] from the palette. <br> If a vehicle has fewer than four colours, you must still provide four colours, otherwise the RGB format will be used.\n===Optional Arguments (RGB format only)===\n*'''r2, g2, b2:''' Three integers indicating the red, green and blue components of the second color for the vehicle\n*'''r3, g3, b3:''' Three integers indicating the red, green and blue components of the third color for the vehicle\n*'''r4, g4, b4:''' Three integers indicating the red, green and blue components of the fourth color for the vehicle\n}}\n===Returns===\nReturns ''true'' if vehicle's color was set, ''false'' if an invalid vehicle or invalid colors were specified.\n\n"), url=FunctionUrl(url='/wiki/SetVehicleColor', name='setVehicleColor', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleColor', return_types=['bool'], arguments=[FunctionArgument(name='veh', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='r1', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g1', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b1', argument_type='int', default_value=None, optional=False), FunctionArgument(name='r2', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g2', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b2', argument_type='int', default_value=None, optional=False), FunctionArgument(name='r3', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g3', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b3', argument_type='int', default_value=None, optional=False), FunctionArgument(name='r4', argument_type='int', default_value=None, optional=False), FunctionArgument(name='g4', argument_type='int', default_value=None, optional=False), FunctionArgument(name='b4', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will set the color of a vehicle using either a RGB format, or the [[Vehicle Colors|standard San Andreas color IDs.]] Vehicles can have up to 4 colors, most of the vehicles have 2 colors only. ', arguments={'theVehicle': 'The vehicle that you wish to set the color of.\n* RGB format:', 'r1, g1, b1': 'Three integers indicating the red, green and blue components of the first (main) color for the vehicle\n* Palette format:', 'p1, p2, p3, p4': 'Exactly four integers indicating the Vehicle Colors|vehicle color IDs from the palette. <br> If a vehicle has fewer than four colours, you must still provide four colours, otherwise the RGB format will be used.', 'r2, g2, b2': 'Three integers indicating the red, green and blue components of the second color for the vehicle', 'r3, g3, b3': 'Three integers indicating the red, green and blue components of the third color for the vehicle', 'r4, g4, b4': 'Three integers indicating the red, green and blue components of the fourth color for the vehicle\n}}'}, result="Returns ''true'' if vehicle's color was set, ''false'' if an invalid vehicle or invalid colors were specified."), oop=FunctionOOP(class_name='vehicle', method_name="setColor}}\n\n===Required Arguments=== \n*'''theVehicle:''' The [[vehicle]] that you wish to set the color of.\n* RGB format:\n** '''r1, g1, b1:''' Three integers indicating the red, green and blue components of the first (main) color for the vehicle\n* Palette format:\n** '''p1, p2, p3, p4:''' Exactly four integers indicating the [[Vehicle Colors", field="vehicle color IDs]] from the palette. <br> If a vehicle has fewer than four colours, you must still provide four colours, otherwise the RGB format will be used.\n===Optional Arguments (RGB format only)===\n*'''r2, g2, b2:''' Three integers indicating the red, green and blue components of the second color for the vehicle\n*'''r3, g3, b3:''' Three integers indicating the red, green and blue components of the third color for the vehicle\n*'''r4, g4, b4:''' Three integers indicating the red, green and blue components of the fourth color for the vehicle\n}}\n===Returns===\nReturns ''true'' if vehicle's color was set, ''false'' if an invalid vehicle or invalid colors were specified.\n\n"), url=FunctionUrl(url='/wiki/SetVehicleColor', name='setVehicleColor', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleComponentPosition', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theComponent', argument_type='string', default_value=None, optional=False), FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='base', argument_type='string', default_value='"root"', optional=True)]), docs=FunctionDoc(description='This function sets the component position of a [[vehicle]].\n}}', arguments={'theVehicle': 'The vehicle you wish to set component position.', 'theComponent': 'A Vehicle_Components|vehicle component (this is the frame name from the model file of the component you wish to modify)', 'posX': 'The new x position of this component.', 'posY': 'The new y position of this component.', 'posZ': 'The new z position of this component.\n{{New feature/item|3.0141|1.4.0|7013|', 'base': ': A string representing what the supplied position (posX, posY, posZ) is relative to. It can be one of the following values:', 'parent': ': The position is relative to the parent component.', 'root': '(default if not specified): The position is relative to the root component.', 'world': ': The position is a world position, relative to the worlds center of coordinates.\n}}'}, result="Returns ''true'' if component position was set successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setComponentPosition', field=None), url=FunctionUrl(url='/wiki/SetVehicleComponentPosition', name='setVehicleComponentPosition', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleComponentRotation', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theComponent', argument_type='string', default_value=None, optional=False), FunctionArgument(name='rotX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rotY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='rotZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='base', argument_type='string', default_value='"parent"', optional=True)]), docs=FunctionDoc(description='This function sets the component rotation of a [[vehicle]].', arguments={'theVehicle': 'The vehicle you wish to set component rotation of.', 'theComponent': 'A Vehicle_Components|vehicle component (this is the frame name from the model file of the component you wish to modify)', 'rotX': 'The components rotation around the x axis in degrees.', 'rotY': 'The components rotation around the y axis in degrees.', 'rotZ': 'The components rotation around the z axis in degrees.\n{{New feature/item|3.0141|1.4.0|7013|', 'base': 'A string representing what the supplied rotation (rotX, rotY, rotZ) is relative to. It can be one of the following values:', 'parent': '(default if not specified): The rotation is relative to the parent component.', 'root': ': The rotation is relative to the root component.', 'world': ': The rotation is a world rotation, relative to the worlds coordinates axes.\n}}'}, result="Returns ''true'' if the component rotation was set successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setComponentRotation', field=None), url=FunctionUrl(url='/wiki/SetVehicleComponentRotation', name='setVehicleComponentRotation', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleComponentScale', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theComponent', argument_type='string', default_value=None, optional=False), FunctionArgument(name='scaleX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='scaleY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='scaleZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='base', argument_type='string', default_value='"root"', optional=True)]), docs=FunctionDoc(description='This function sets the component scale of a [[vehicle]].\n}}', arguments={'theVehicle': 'The vehicle you wish to set component scale.', 'theComponent': 'A Vehicle_Components|vehicle component (this is the frame name from the model file of the component you wish to modify)', 'scaleX': 'The new x scale of this component.', 'scaleY': 'The new y scale of this component.', 'scaleZ': 'The new z scale of this component.', 'base': ': A string representing what the supplied scale (scaleX, scaleY, scaleZ) is relative to. It can be one of the following values:', 'parent': ': The scale is relative to the parent component.', 'root': '(default if not specified): The scale is relative to the root component.', 'world': ': The scale is a world scale, relative to the worlds center of coordinates.'}, result="Returns ''true'' if component scale was set successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setComponentScale', field=None), url=FunctionUrl(url='/wiki/SetVehicleComponentScale', name='setVehicleComponentScale', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleComponentVisible', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='theComponent', argument_type='string', default_value=None, optional=False), FunctionArgument(name='visible', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets component visibility for [[vehicle]].\n}}', arguments={'theVehicle': 'The vehicle you wish to set component visibility of.', 'theComponent': 'A Vehicle_Components|vehicle component (this is the components frame name (also called dummy) from the vehicle models DFF file of which you want to manipulate components)', 'visible': 'a bool which determines if the component should be visible'}, result="Returns a ''bool'' indicating if the visiblity was changed successfully."), oop=FunctionOOP(class_name='vehicle', method_name='setComponentVisible', field=None), url=FunctionUrl(url='/wiki/SetVehicleComponentVisible', name='setVehicleComponentVisible', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleDamageProof', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='damageProof', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This functions makes a vehicle damage proof, so it won't take damage from bullets, hits, explosions or fire. A damage proof's vehicle health can still be changed via script.", arguments={'theVehicle': 'The vehicle you wish to make damage proof.', 'damageProof': 'true is damage proof, false is damageable.'}, result="Returns ''true'' if the vehicle was set damage proof succesfully, ''false'' if the arguments are invalid or it failed."), oop=FunctionOOP(class_name='vehicle', method_name='setDamageProof', field='damageProof'), url=FunctionUrl(url='/wiki/SetVehicleDamageProof', name='setVehicleDamageProof', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleDamageProof', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='damageProof', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This functions makes a vehicle damage proof, so it won't take damage from bullets, hits, explosions or fire. A damage proof's vehicle health can still be changed via script.", arguments={'theVehicle': 'The vehicle you wish to make damage proof.', 'damageProof': 'true is damage proof, false is damageable.'}, result="Returns ''true'' if the vehicle was set damage proof succesfully, ''false'' if the arguments are invalid or it failed."), oop=FunctionOOP(class_name='vehicle', method_name='setDamageProof', field='damageProof'), url=FunctionUrl(url='/wiki/SetVehicleDamageProof', name='setVehicleDamageProof', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleDummyPosition', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='dummy', argument_type='string', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the position of the dummy for the given vehicle.}}', arguments={'theVehicle': 'The vehicle you want to set the dummy position for', 'dummy': 'The dummy whose position you want to set', 'x': ', y, z The new dummy position'}, result="Returns ''true'' for success, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setDummyPosition', field=None), url=FunctionUrl(url='/wiki/SetVehicleDummyPosition', name='setVehicleDummyPosition', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleDirtLevel', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='dirtLevel', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the dirt level on a vehicle.', arguments={'theVehicle': 'The vehicle that you want to set the dirt level from', 'dirtLevel': 'The dirt level'}, result="Returns ''true'' if the dirt level was set on the vehicle, ''false'' if the dirt level was not set or if invalid arguments are specified."), oop=None, url=FunctionUrl(url='/wiki/SetVehicleDirtLevel', name='setVehicleDirtLevel', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleDirtLevel', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='dirtLevel', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the dirt level on a vehicle.', arguments={'theVehicle': 'The vehicle that you want to set the dirt level from', 'dirtLevel': 'The dirt level'}, result="Returns ''true'' if the dirt level was set on the vehicle, ''false'' if the dirt level was not set or if invalid arguments are specified."), oop=None, url=FunctionUrl(url='/wiki/SetVehicleDirtLevel', name='setVehicleDirtLevel', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleDoorOpenRatio', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='door', argument_type='int', default_value=None, optional=False), FunctionArgument(name='ratio', argument_type='float', default_value=None, optional=False), FunctionArgument(name='time', argument_type='int', default_value='0', optional=True)]), docs=FunctionDoc(description="This function sets how much a vehicle's door is open. Doors include the boot/trunk and the bonnet of the vehicle.", arguments={'theVehicle': 'The vehicle that you wish to change the door open ratio of.', 'door': 'A whole number, 0 (hood), 1 (trunk), 2 (front left), 3 (front right), 4 (rear left), 5 (rear right)', 'ratio': 'The ratio value, ranging from 0 (fully closed) to 1 (fully open).\n{{OptionalArg}} ', 'time': 'The number of milliseconds the door should take to reach the value you have specified. A value of 0 will change the door open ratio instantly.'}, result="Returns ''true'' if the door open ratio was successfully set, ''false'' if invalid arguments are passed."), oop=FunctionOOP(class_name='vehicle', method_name='setDoorOpenRatio', field=None), url=FunctionUrl(url='/wiki/SetVehicleDoorOpenRatio', name='setVehicleDoorOpenRatio', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleDoorOpenRatio', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='door', argument_type='int', default_value=None, optional=False), FunctionArgument(name='ratio', argument_type='float', default_value=None, optional=False), FunctionArgument(name='time', argument_type='int', default_value='0', optional=True)]), docs=FunctionDoc(description="This function sets how much a vehicle's door is open. Doors include the boot/trunk and the bonnet of the vehicle.", arguments={'theVehicle': 'The vehicle that you wish to change the door open ratio of.', 'door': 'A whole number, 0 (hood), 1 (trunk), 2 (front left), 3 (front right), 4 (rear left), 5 (rear right)', 'ratio': 'The ratio value, ranging from 0 (fully closed) to 1 (fully open).\n{{OptionalArg}} ', 'time': 'The number of milliseconds the door should take to reach the value you have specified. A value of 0 will change the door open ratio instantly.'}, result="Returns ''true'' if the door open ratio was successfully set, ''false'' if invalid arguments are passed."), oop=FunctionOOP(class_name='vehicle', method_name='setDoorOpenRatio', field=None), url=FunctionUrl(url='/wiki/SetVehicleDoorOpenRatio', name='setVehicleDoorOpenRatio', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleDoorState', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='door', argument_type='int', default_value=None, optional=False), FunctionArgument(name='state', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the state of the specified door on a vehicle.', arguments={'theVehicle': 'The vehicle that you wish to change the door state of.', 'door': 'An integer representing which door to set the state of. Valid values are:', '0': 'Shut, intact (aka Closed, undamaged)', '1': 'Ajar, intact (aka Slightly open, undamaged)', '2': 'Shut, damaged (aka Closed, damaged)', '3': 'Ajar, damaged (aka Slightly open, damaged)', '4': 'Missing\n{{OptionalArg}}\n{{New feature/item|9.0158|1.5.8|20319|', '5': 'Rear right', 'state': 'An integer representing the state to set the door to. Valid values are:', 'spawnFlyingComponent': 'A boolean, if set to true, spawns flying doors etc. if you remove a component with <nowiki>state == 4</nowiki>.\n}}'}, result="Returns ''true'' if the door state was successfully set, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setDoorState', field=None), url=FunctionUrl(url='/wiki/SetVehicleDoorState', name='setVehicleDoorState', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleDoorState', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='door', argument_type='int', default_value=None, optional=False), FunctionArgument(name='state', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the state of the specified door on a vehicle.', arguments={'theVehicle': 'The vehicle that you wish to change the door state of.', 'door': 'An integer representing which door to set the state of. Valid values are:', '0': 'Shut, intact (aka Closed, undamaged)', '1': 'Ajar, intact (aka Slightly open, undamaged)', '2': 'Shut, damaged (aka Closed, damaged)', '3': 'Ajar, damaged (aka Slightly open, damaged)', '4': 'Missing\n{{OptionalArg}}\n{{New feature/item|9.0158|1.5.8|20319|', '5': 'Rear right', 'state': 'An integer representing the state to set the door to. Valid values are:', 'spawnFlyingComponent': 'A boolean, if set to true, spawns flying doors etc. if you remove a component with <nowiki>state == 4</nowiki>.\n}}'}, result="Returns ''true'' if the door state was successfully set, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setDoorState', field=None), url=FunctionUrl(url='/wiki/SetVehicleDoorState', name='setVehicleDoorState', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleDoorsUndamageable', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='state', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function makes a vehicle's doors undamageable, so they won't fall off when they're hit. Note that the vehicle '''has''' to be locked using [[setVehicleLocked]] for this setting to have any effect.", arguments={'theVehicle': 'The vehicle of which you wish to set the car door damageability.', 'state': 'A boolean denoting whether the vehicles doors are undamageable (true) or damageable (false).'}, result="Returns ''true'' if the damageability state was successfully changed, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='vehicle', method_name='setDoorsUndamageable', field="doorsUndamageable}}\n===Required Arguments===\n*'''theVehicle:''' The [[vehicle]] of which you wish to set the car door damageability.\n*'''state:''' A boolean denoting whether the vehicle's doors are undamageable (''true'') or damageable (''false'').\n\n===Returns===\nReturns ''true'' if the damageability state was successfully changed, ''false'' if invalid arguments were passed.\n\n"), url=FunctionUrl(url='/wiki/SetVehicleDoorsUndamageable', name='setVehicleDoorsUndamageable', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleDoorsUndamageable', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='state', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function makes a vehicle's doors undamageable, so they won't fall off when they're hit. Note that the vehicle '''has''' to be locked using [[setVehicleLocked]] for this setting to have any effect.", arguments={'theVehicle': 'The vehicle of which you wish to set the car door damageability.', 'state': 'A boolean denoting whether the vehicles doors are undamageable (true) or damageable (false).'}, result="Returns ''true'' if the damageability state was successfully changed, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='vehicle', method_name='setDoorsUndamageable', field="doorsUndamageable}}\n===Required Arguments===\n*'''theVehicle:''' The [[vehicle]] of which you wish to set the car door damageability.\n*'''state:''' A boolean denoting whether the vehicle's doors are undamageable (''true'') or damageable (''false'').\n\n===Returns===\nReturns ''true'' if the damageability state was successfully changed, ''false'' if invalid arguments were passed.\n\n"), url=FunctionUrl(url='/wiki/SetVehicleDoorsUndamageable', name='setVehicleDoorsUndamageable', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleEngineState', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='engineState', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function turns a vehicle's engine on or off. Note that the engine will always be turned on when someone enters the driver seat, unless you override that behaviour with scripts.", arguments={'theVehicle': ': The vehicle you wish to change the engine state of.', 'engineState': ': A boolean value representing whether the engine will be turned on (true) or off (false).'}, result="Returns ''true'' if the vehicle's engine state was successfully changed, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setEngineState', field='engineState'), url=FunctionUrl(url='/wiki/SetVehicleEngineState', name='setVehicleEngineState', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleEngineState', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='engineState', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function turns a vehicle's engine on or off. Note that the engine will always be turned on when someone enters the driver seat, unless you override that behaviour with scripts.", arguments={'theVehicle': ': The vehicle you wish to change the engine state of.', 'engineState': ': A boolean value representing whether the engine will be turned on (true) or off (false).'}, result="Returns ''true'' if the vehicle's engine state was successfully changed, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setEngineState', field='engineState'), url=FunctionUrl(url='/wiki/SetVehicleEngineState', name='setVehicleEngineState', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleFuelTankExplodable', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='explodable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function changes the 'explodable state' of a vehicle's fuel tank, which toggles the ability to blow the vehicle up by shooting the tank. This function will have no effect on vehicles with tanks that cannot be shot in single player.", arguments={'theVehicle': ': The vehicle you wish to change the fuel tank explodable state of.', 'explodable': ': A boolean value representing whether or not the fuel tank will be explodable.'}, result="Returns ''true'' if the vehicle's fuel tank explodable state was successfully changed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetVehicleFuelTankExplodable', name='setVehicleFuelTankExplodable', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleFuelTankExplodable', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='explodable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function changes the 'explodable state' of a vehicle's fuel tank, which toggles the ability to blow the vehicle up by shooting the tank. This function will have no effect on vehicles with tanks that cannot be shot in single player.", arguments={'theVehicle': ': The vehicle you wish to change the fuel tank explodable state of.', 'explodable': ': A boolean value representing whether or not the fuel tank will be explodable.'}, result="Returns ''true'' if the vehicle's fuel tank explodable state was successfully changed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetVehicleFuelTankExplodable', name='setVehicleFuelTankExplodable', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleGravity', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the gravity vector of a vehicle. The vehicle will fall in this direction, and the camera of any occupants will also be rotated to match it. Can be used for e.g. driving on walls or upside down on ceilings.', arguments={'theVehicle': 'the vehicle of which to change the gravity.', 'x, y, z': 'the components of the new gravity vector. If this vector has length 1, the strength of the gravity will be same as the global gravity for other entities. If it is 2, it will be twice as strong, etc.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetVehicleGravity', name='setVehicleGravity', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleHandling', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='element', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='var', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to change the handling data of a vehicle.', arguments={'theVehicle': 'The vehicle you wish to set the handling of.', 'property': 'The property you wish to set the handling of the vehicle to.\n{{Note|For functionality reasons suspension modification is disabled on monster trucks, trains, boats and trailers.}}\n{{Handling Properties}}', 'value': 'The value of the property you wish to set the handling of the vehicle to.'}, result="Returns ''true'' if the handling was set successfully, ''false'' otherwise. See below a list of valid properties and their required values:"), oop=None, url=FunctionUrl(url='/wiki/SetVehicleHandling', name='setVehicleHandling', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleHandling', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='element', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False), FunctionArgument(name='value', argument_type='var', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to change the handling data of a vehicle.', arguments={'theVehicle': 'The vehicle you wish to set the handling of.', 'property': 'The property you wish to set the handling of the vehicle to.\n{{Note|For functionality reasons suspension modification is disabled on monster trucks, trains, boats and trailers.}}\n{{Handling Properties}}', 'value': 'The value of the property you wish to set the handling of the vehicle to.'}, result="Returns ''true'' if the handling was set successfully, ''false'' otherwise. See below a list of valid properties and their required values:"), oop=None, url=FunctionUrl(url='/wiki/SetVehicleHandling', name='setVehicleHandling', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleHeadLightColor', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='red', argument_type='int', default_value=None, optional=False), FunctionArgument(name='green', argument_type='int', default_value=None, optional=False), FunctionArgument(name='blue', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will set the headlight color of a vehicle. valid Red Green and Blue arguments range from 0-255', arguments={'theVehicle': 'The vehicle that you wish to set the headlight color of.', 'red': 'An integer indicating the amount of red for the vehicles headlights', 'green': 'An integer indicating the amount of green for the vehicles headlights', 'blue': 'An integer indicating the amount of blue for the vehicles headlights'}, result="Returns ''true'' if vehicle's headlight color was set, ''false'' if an invalid vehicle or invalid color ranges were specified for red,green or blue."), oop=FunctionOOP(class_name='vehicle', method_name='setHeadLightColor', field=None), url=FunctionUrl(url='/wiki/SetVehicleHeadLightColor', name='setVehicleHeadLightColor', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleHeadLightColor', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='red', argument_type='int', default_value=None, optional=False), FunctionArgument(name='green', argument_type='int', default_value=None, optional=False), FunctionArgument(name='blue', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will set the headlight color of a vehicle. valid Red Green and Blue arguments range from 0-255', arguments={'theVehicle': 'The vehicle that you wish to set the headlight color of.', 'red': 'An integer indicating the amount of red for the vehicles headlights', 'green': 'An integer indicating the amount of green for the vehicles headlights', 'blue': 'An integer indicating the amount of blue for the vehicles headlights'}, result="Returns ''true'' if vehicle's headlight color was set, ''false'' if an invalid vehicle or invalid color ranges were specified for red,green or blue."), oop=FunctionOOP(class_name='vehicle', method_name='setHeadLightColor', field=None), url=FunctionUrl(url='/wiki/SetVehicleHeadLightColor', name='setVehicleHeadLightColor', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleLandingGearDown', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='gearState', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the landing gear state of certain vehicles.', arguments={'theVehicle': 'The vehicle of which you wish to set the landing gear state.', 'gearState': 'A bool representing the state of the landing gear.  true represents a collapsed landing gear, while false represents a disabled landing gear.'}, result="Returns ''true'' if the landing gear was set successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetVehicleLandingGearDown', name='setVehicleLandingGearDown', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleLandingGearDown', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='gearState', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the landing gear state of certain vehicles.', arguments={'theVehicle': 'The vehicle of which you wish to set the landing gear state.', 'gearState': 'A bool representing the state of the landing gear.  true represents a collapsed landing gear, while false represents a disabled landing gear.'}, result="Returns ''true'' if the landing gear was set successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetVehicleLandingGearDown', name='setVehicleLandingGearDown', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleLightState', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='light', argument_type='int', default_value=None, optional=False), FunctionArgument(name='state', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the state of the light on the vehicle.', arguments={'theVehicle': 'A handle to the vehicle that you wish to change the light state of.', 'light': 'A whole number determining the individual light:', '0': 'Front left', '1': 'Front right', '2': 'Rear right', '3': 'Rear left', 'state': 'A whole number determining the new state of the light. 0 represents normal lights, and 1 represents broken lights.'}, result="Returns ''true'' if the light state was set successfully, ''false'' if invalid arguments were passed to the function."), oop=FunctionOOP(class_name='vehicle', method_name='setLightState', field=None), url=FunctionUrl(url='/wiki/SetVehicleLightState', name='setVehicleLightState', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleLightState', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='light', argument_type='int', default_value=None, optional=False), FunctionArgument(name='state', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the state of the light on the vehicle.', arguments={'theVehicle': 'A handle to the vehicle that you wish to change the light state of.', 'light': 'A whole number determining the individual light:', '0': 'Front left', '1': 'Front right', '2': 'Rear right', '3': 'Rear left', 'state': 'A whole number determining the new state of the light. 0 represents normal lights, and 1 represents broken lights.'}, result="Returns ''true'' if the light state was set successfully, ''false'' if invalid arguments were passed to the function."), oop=FunctionOOP(class_name='vehicle', method_name='setLightState', field=None), url=FunctionUrl(url='/wiki/SetVehicleLightState', name='setVehicleLightState', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleLocked', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='locked', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function can be used to set the vehicle's doors to be locked or unlocked.  Locking a vehicle restricts access to the vehicle.", arguments={'theVehicle': 'The vehicle which you wish to change the lock status of', 'locked': 'Boolean for the status you wish to set. Set true to lock, false to unlock'}, result="Returns ''true'' if the operation was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setLocked', field='locked'), url=FunctionUrl(url='/wiki/SetVehicleLocked', name='setVehicleLocked', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleLocked', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='locked', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function can be used to set the vehicle's doors to be locked or unlocked.  Locking a vehicle restricts access to the vehicle.", arguments={'theVehicle': 'The vehicle which you wish to change the lock status of', 'locked': 'Boolean for the status you wish to set. Set true to lock, false to unlock'}, result="Returns ''true'' if the operation was successful, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setLocked', field='locked'), url=FunctionUrl(url='/wiki/SetVehicleLocked', name='setVehicleLocked', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleModelDummyPosition', return_types=['bool'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='dummy', argument_type='string', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the position of the dummies contained in a vehicle model. Use [[setVehicleComponentPosition]] to adjust the vehicle component positions.\n}}', arguments={'modelID': ': The model ID which you want to apply the change to', 'dummy': ': The dummy whose position you want to change', 'posX': ', posY, posZ: The desired position'}, result="Returns ''true'' if everything went fine, ''false'' otherwise."), oop=FunctionOOP(class_name='Vehicle', method_name='setVehicleModelDummyPosition', field=None), url=FunctionUrl(url='/wiki/SetVehicleModelDummyPosition', name='setVehicleModelDummyPosition', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleModelExhaustFumesPosition', return_types=['bool'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the position of the exhaust fumes the vehicle model emits. Use [[setVehicleComponentPosition]] to adjust the exhaust position.\n}}', arguments={'modelID': ': The model ID which you want to apply the change to', 'posX': ', posY, posZ: The desired position'}, result="Returns ''true'' if everything went fine, ''false'' otherwise."), oop=FunctionOOP(class_name='Vehicle', method_name='setModelExhaustFumesPosition', field=None), url=FunctionUrl(url='/wiki/SetVehicleModelExhaustFumesPosition', name='setVehicleModelExhaustFumesPosition', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleModelWheelSize', return_types=['bool'], arguments=[FunctionArgument(name='vehicleModel', argument_type='int', default_value=None, optional=False), FunctionArgument(name='wheelGroup', argument_type='string', default_value=None, optional=False), FunctionArgument(name='wheelSize', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'vehicleModel': ': The Vehicle IDs|vehicle model ID.', 'wheelGroup': ': The group of wheels of the vehicle model that will have its size set by this function. The following values are supported:', 'front_axle': ': Represents the wheels in the front axle. The default value for this group is read by GTA from the WheelScale_Front field of the vehicles.ide data file.', 'rear_axle': ': Represents the wheels in the rear axle. The default value for this group is read by GTA from the WheelScale_Rear field of the vehicles.ide data file.', 'all_wheels': ': Convenience group that contains the other wheel groups: front_axle and rear_axle.', 'wheelSize': ': The wheel size value to set. Default GTA values for automobiles usually are around 0.7. It must be greater than 0.'}, result="Returns ''true'' if the size for the specified wheel group and vehicle model has been set successfully, or an error if some parameter is invalid."), oop=FunctionOOP(class_name='Vehicle', method_name='setModelWheelSize', field=None), url=FunctionUrl(url='/wiki/SetVehicleModelWheelSize', name='setVehicleModelWheelSize', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleNitroActivated', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='state', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function activates or deactivates the nitro on the specified [[vehicle]], like if a player pressed the button for activating nitro.\n}}', arguments={'theVehicle': 'The vehicle to activate or deactivate the nitro on.', 'state': 'true if you want to activate the nitro, false if you want to disable it.'}, result="Returns ''true'' if the nitro activation state was modified successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetVehicleNitroActivated', name='setVehicleNitroActivated', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleNitroCount', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='count', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets how many times a player can activate the nitro on a specified [[vehicle]].\n}}', arguments={'theVehicle': ': the vehicle which you want to modify how many times a player can use its nitro.', 'count': ': how many times should the player be able to use the nitro of this vehicle (from 0-100 times; 0 means that it cant be used and 101 means that it can be used infinite times).'}, result="Returns ''true'' if the nitro count was set successfully to the vehicle, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetVehicleNitroCount', name='setVehicleNitroCount', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleNitroLevel', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='level', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the nitro level of the [[vehicle]].\n}}', arguments={'theVehicle': 'The vehicle, which you want to set.', 'level': 'Nitro level you want to set (ranges from 0.0001 to 1.0).'}, result="Returns ''true'' if the nitro level was set successfully to the vehicle, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetVehicleNitroLevel', name='setVehicleNitroLevel', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleOverrideLights', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='value', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the light overriding setting on a vehicle.', arguments={'theVehicle': ': The vehicle you wish to change the override lights setting of.', 'value': ': A whole number representing the state of the lights:', '0': ': No override, lights are set to default.', '1': ': Lights are forced off.', '2': ': Lights are forced on.'}, result="Returns ''true'' if the vehicle's lights setting was changed. Otherwise ''false''."), oop=FunctionOOP(class_name='vehicle', method_name='setOverrideLights', field='overrideLights'), url=FunctionUrl(url='/wiki/SetVehicleOverrideLights', name='setVehicleOverrideLights', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleOverrideLights', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='value', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the light overriding setting on a vehicle.', arguments={'theVehicle': ': The vehicle you wish to change the override lights setting of.', 'value': ': A whole number representing the state of the lights:', '0': ': No override, lights are set to default.', '1': ': Lights are forced off.', '2': ': Lights are forced on.'}, result="Returns ''true'' if the vehicle's lights setting was changed. Otherwise ''false''."), oop=FunctionOOP(class_name='vehicle', method_name='setOverrideLights', field='overrideLights'), url=FunctionUrl(url='/wiki/SetVehicleOverrideLights', name='setVehicleOverrideLights', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehiclePaintjob', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='value', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the paintjob on the specified vehicle. <br/>\nSee [[Paintjob|paintjob]] for list of supported vehicles.', arguments={'theVehicle': ': The vehicle you wish to change the paintjob of.', 'value': ': A whole number representing the new paintjob id. Ranges from 0 up to 3.'}, result="Returns ''true'' if the vehicle's paintjob was changed. Otherwise ''false''."), oop=None, url=FunctionUrl(url='/wiki/SetVehiclePaintjob', name='setVehiclePaintjob', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehiclePaintjob', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='value', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the paintjob on the specified vehicle. <br/>\nSee [[Paintjob|paintjob]] for list of supported vehicles.', arguments={'theVehicle': ': The vehicle you wish to change the paintjob of.', 'value': ': A whole number representing the new paintjob id. Ranges from 0 up to 3.'}, result="Returns ''true'' if the vehicle's paintjob was changed. Otherwise ''false''."), oop=None, url=FunctionUrl(url='/wiki/SetVehiclePaintjob', name='setVehiclePaintjob', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehiclePanelState', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='panelID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='state', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows you to change the state of one of the six panels vehicle's can have. When executed on the server-side resources, the damage will be synched for all players, whereas the change is only client-side if the function is used in a client resource. ", arguments={'theVehicle': 'The vehicle you would like to modify the panel of.', 'panelID': 'An ID specifying the part of the vehicle. Possible values are:', 'Cars': '', '0': 'Engine Smoke (left engine for a Nevada or a Beagle)', '1': 'Engine Smoke (right engine for a Nevada or a Beagle)', '2': 'Rudder', '3': 'Elevators', '4': 'Ailerons', '5': 'Unknown', '6': "Unknown\n''NOTE:'' Settings are not applicable for all vehicles of these types, for instance panel 0 effects a Dodo, but does nothing to a hydra.", 'Planes': '', 'state': 'How damaged the part is on the scale of 0 to 3, with 0 being undamaged and 3 being very damaged. How this is manifested depends on the panel and the vehicle.'}, result="Returns ''true'' if the panel state has been updated, ''false'' otherwise"), oop=FunctionOOP(class_name='vehicle', method_name='setPanelState', field=None), url=FunctionUrl(url='/wiki/SetVehiclePanelState', name='setVehiclePanelState', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehiclePanelState', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='panelID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='state', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function allows you to change the state of one of the six panels vehicle's can have. When executed on the server-side resources, the damage will be synched for all players, whereas the change is only client-side if the function is used in a client resource. ", arguments={'theVehicle': 'The vehicle you would like to modify the panel of.', 'panelID': 'An ID specifying the part of the vehicle. Possible values are:', 'Cars': '', '0': 'Engine Smoke (left engine for a Nevada or a Beagle)', '1': 'Engine Smoke (right engine for a Nevada or a Beagle)', '2': 'Rudder', '3': 'Elevators', '4': 'Ailerons', '5': 'Unknown', '6': "Unknown\n''NOTE:'' Settings are not applicable for all vehicles of these types, for instance panel 0 effects a Dodo, but does nothing to a hydra.", 'Planes': '', 'state': 'How damaged the part is on the scale of 0 to 3, with 0 being undamaged and 3 being very damaged. How this is manifested depends on the panel and the vehicle.'}, result="Returns ''true'' if the panel state has been updated, ''false'' otherwise"), oop=FunctionOOP(class_name='vehicle', method_name='setPanelState', field=None), url=FunctionUrl(url='/wiki/SetVehiclePanelState', name='setVehiclePanelState', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehiclePlateText', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='element', default_value=None, optional=False), FunctionArgument(name='numberplate', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function can be used to set the numberplate text of a car.\n}}\nIt now also changes the numberplate text of any vehicle that has visual numberplates.\n}}', arguments={'theVehicle': 'the vehicle whose numberplate you want to change.', 'numberplate': 'a string that will go on the number plate of the car (max 8 characters).'}, result="Returns ''true'' if the numberplate was changed successfully, or ''false'' if invalid arguments were passed"), oop=FunctionOOP(class_name='vehicle', method_name='setPlateText', field='plateText'), url=FunctionUrl(url='/wiki/SetVehiclePlateText', name='setVehiclePlateText', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehiclePlateText', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='element', default_value=None, optional=False), FunctionArgument(name='numberplate', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function can be used to set the numberplate text of a car.\n}}\nIt now also changes the numberplate text of any vehicle that has visual numberplates.\n}}', arguments={'theVehicle': 'the vehicle whose numberplate you want to change.', 'numberplate': 'a string that will go on the number plate of the car (max 8 characters).'}, result="Returns ''true'' if the numberplate was changed successfully, or ''false'' if invalid arguments were passed"), oop=FunctionOOP(class_name='vehicle', method_name='setPlateText', field='plateText'), url=FunctionUrl(url='/wiki/SetVehiclePlateText', name='setVehiclePlateText', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleSirens', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='sirenPoint', argument_type='int', default_value=None, optional=False), FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='red', argument_type='float', default_value=None, optional=False), FunctionArgument(name='green', argument_type='float', default_value=None, optional=False), FunctionArgument(name='blue', argument_type='float', default_value=None, optional=False), FunctionArgument(name='alpha', argument_type='float', default_value='255', optional=False), FunctionArgument(name='minAlpha', argument_type='float', default_value='0.0', optional=False)]), docs=FunctionDoc(description='This function changes the properties of a vehicles siren point.\n}}', arguments={'theVehicle': 'The vehicle to modify', 'sirenPoint': 'The siren point to modify', 'posX': 'The x position of this siren point from the center of the vehicle', 'posY': 'The y position of this siren point from the center of the vehicle', 'posZ': 'The z position of this siren point from the center of the vehicle', 'red': 'The amount of red from 0 to 255', 'green': 'The amount of green from 0 to 255', 'blue': 'The amount of blue from 0 to 255', 'alpha': 'The alpha of the siren from 0 to 255', 'minAlpha': 'The minimum alpha of the light during day time'}, result="Returns ''true'' if the siren point was successfully changed on the vehicle, ''false'' otherwise. "), oop=FunctionOOP(class_name='vehicle', method_name='setSirens', field=None), url=FunctionUrl(url='/wiki/SetVehicleSirens', name='setVehicleSirens', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleSirens', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='sirenPoint', argument_type='int', default_value=None, optional=False), FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='red', argument_type='float', default_value=None, optional=False), FunctionArgument(name='green', argument_type='float', default_value=None, optional=False), FunctionArgument(name='blue', argument_type='float', default_value=None, optional=False), FunctionArgument(name='alpha', argument_type='float', default_value='255', optional=False), FunctionArgument(name='minAlpha', argument_type='float', default_value='0.0', optional=False)]), docs=FunctionDoc(description='This function changes the properties of a vehicles siren point.\n}}', arguments={'theVehicle': 'The vehicle to modify', 'sirenPoint': 'The siren point to modify', 'posX': 'The x position of this siren point from the center of the vehicle', 'posY': 'The y position of this siren point from the center of the vehicle', 'posZ': 'The z position of this siren point from the center of the vehicle', 'red': 'The amount of red from 0 to 255', 'green': 'The amount of green from 0 to 255', 'blue': 'The amount of blue from 0 to 255', 'alpha': 'The alpha of the siren from 0 to 255', 'minAlpha': 'The minimum alpha of the light during day time'}, result="Returns ''true'' if the siren point was successfully changed on the vehicle, ''false'' otherwise. "), oop=FunctionOOP(class_name='vehicle', method_name='setSirens', field=None), url=FunctionUrl(url='/wiki/SetVehicleSirens', name='setVehicleSirens', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleSirensOn', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='sirensOn', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the state of the sirens on the specified vehicle.', arguments={'theVehicle': 'The vehicle that will have the sirens set', 'sirensOn': 'The state to set the sirens to'}, result="Returns ''true'' if the sirens are set for the specified vehicle, ''false'' if the sirens can't be set for the specified vehicle, if the vehicle doesn't have sirens or if invalid arguments are specified."), oop=FunctionOOP(class_name='vehicle', method_name='setSirensOn', field='sirensOn'), url=FunctionUrl(url='/wiki/SetVehicleSirensOn', name='setVehicleSirensOn', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleSirensOn', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='sirensOn', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the state of the sirens on the specified vehicle.', arguments={'theVehicle': 'The vehicle that will have the sirens set', 'sirensOn': 'The state to set the sirens to'}, result="Returns ''true'' if the sirens are set for the specified vehicle, ''false'' if the sirens can't be set for the specified vehicle, if the vehicle doesn't have sirens or if invalid arguments are specified."), oop=FunctionOOP(class_name='vehicle', method_name='setSirensOn', field='sirensOn'), url=FunctionUrl(url='/wiki/SetVehicleSirensOn', name='setVehicleSirensOn', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleTaxiLightOn', return_types=['bool'], arguments=[FunctionArgument(name='taxi', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='LightState', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function will set the taxi light on in a taxi (vehicle ID's 420 and 438)", arguments={'taxi': 'The vehicle element of the taxi that you wish to turn the light on.', 'LightState': 'whether the light is on. True for on, False for off.'}, result="Returns ''true'' if the state was successfully set, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setTaxiLightOn', field='taxiLightOn'), url=FunctionUrl(url='/wiki/SetVehicleTaxiLightOn', name='setVehicleTaxiLightOn', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleTaxiLightOn', return_types=['bool'], arguments=[FunctionArgument(name='taxi', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='LightState', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function will set the taxi light on in a taxi (vehicle ID's 420 and 438)", arguments={'taxi': 'The vehicle element of the taxi that you wish to turn the light on.', 'LightState': 'whether the light is on. True for on, False for off.'}, result="Returns ''true'' if the state was successfully set, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setTaxiLightOn', field='taxiLightOn'), url=FunctionUrl(url='/wiki/SetVehicleTaxiLightOn', name='setVehicleTaxiLightOn', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleTurretPosition', return_types=['bool'], arguments=[FunctionArgument(name='turretVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='positionX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='positionY', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the position of a vehicle's turret, if it has one. This can be used to influence the turret's rotation, so it doesn't follow the camera. Vehicles with turrets include firetrucks and tanks.", arguments={'turretVehicle': ': The vehicle whose turret position you want to retrieve. This should be a vehicle with a turret.', 'positionX': ': The horizontal position of the turret. In radians', 'positionY': ': The vertical position of the turret. In radians'}, result="Returns a ''true'' if a valid vehicle element and valid positions were passed, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setTurretPosition', field='turretPosition'), url=FunctionUrl(url='/wiki/SetVehicleTurretPosition', name='setVehicleTurretPosition', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleTurretPosition', return_types=['bool'], arguments=[FunctionArgument(name='turretVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='positionX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='positionY', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the position of a vehicle's turret, if it has one. This can be used to influence the turret's rotation, so it doesn't follow the camera. Vehicles with turrets include firetrucks and tanks.", arguments={'turretVehicle': ': The vehicle whose turret position you want to retrieve. This should be a vehicle with a turret.', 'positionX': ': The horizontal position of the turret. In radians', 'positionY': ': The vertical position of the turret. In radians'}, result="Returns a ''true'' if a valid vehicle element and valid positions were passed, ''false'' otherwise."), oop=FunctionOOP(class_name='vehicle', method_name='setTurretPosition', field='turretPosition'), url=FunctionUrl(url='/wiki/SetVehicleTurretPosition', name='setVehicleTurretPosition', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleVariant', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='variant1', argument_type='int', default_value=None, optional=True), FunctionArgument(name='variant2', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description="This function sets the variant of a specified vehicle. In GTA SA some vehicles are different for example the labelling on trucks or the contents of a pick-up truck and the varying types of a motor bike. For the default GTA SA variant list see: [[Vehicle variants]]\n {{Tip|Both variant arguments need to be supplied, otherwise random ones will be picked.}} \n {{Tip|If you only want one variant, set ''''variant2'''' to ''255''. If you want no variants, then set both ''''variant1'''' and ''''variant2'''' to ''255''}} \n {{Note|The fairings on the NRG-500 and BF-400 are both variants, so unless you explicitly ask for 3 or 4, your bike will have no fairings which some people may find offensive.\n}} ", arguments={'theVehicle': 'A handle to the vehicle that you want to get the variant of.\nBoth arguments need to be supplied, otherwise random variants will be picked.', 'variant1': ': An integer for the first variant see Vehicle variants', 'variant2': ': An integer for the second variant see Vehicle variants'}, result="On success:\n* '''bool''': Returns true as the vehicle variants were successfully set.\nOn failure:\n* '''bool''': False because the specified vehicle didn't exist or specified variants were invalid."), oop=FunctionOOP(class_name='vehicle', method_name='setVariant', field=None), url=FunctionUrl(url='/wiki/SetVehicleVariant', name='setVehicleVariant', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleVariant', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='variant1', argument_type='int', default_value=None, optional=True), FunctionArgument(name='variant2', argument_type='int', default_value=None, optional=True)]), docs=FunctionDoc(description="This function sets the variant of a specified vehicle. In GTA SA some vehicles are different for example the labelling on trucks or the contents of a pick-up truck and the varying types of a motor bike. For the default GTA SA variant list see: [[Vehicle variants]]\n {{Tip|Both variant arguments need to be supplied, otherwise random ones will be picked.}} \n {{Tip|If you only want one variant, set ''''variant2'''' to ''255''. If you want no variants, then set both ''''variant1'''' and ''''variant2'''' to ''255''}} \n {{Note|The fairings on the NRG-500 and BF-400 are both variants, so unless you explicitly ask for 3 or 4, your bike will have no fairings which some people may find offensive.\n}} ", arguments={'theVehicle': 'A handle to the vehicle that you want to get the variant of.\nBoth arguments need to be supplied, otherwise random variants will be picked.', 'variant1': ': An integer for the first variant see Vehicle variants', 'variant2': ': An integer for the second variant see Vehicle variants'}, result="On success:\n* '''bool''': Returns true as the vehicle variants were successfully set.\nOn failure:\n* '''bool''': False because the specified vehicle didn't exist or specified variants were invalid."), oop=FunctionOOP(class_name='vehicle', method_name='setVariant', field=None), url=FunctionUrl(url='/wiki/SetVehicleVariant', name='setVehicleVariant', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleWheelScale', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='wheelScale', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'theVehicle': ': The vehicle whose wheel scale you wish to modify.', 'wheelScale': ': The wheel scale value to set.'}, result="Returns ''true'' if the wheel scale has been set successfully, or an error if some parameter is invalid."), oop=FunctionOOP(class_name='vehicle', method_name='setWheelScale', field='wheelScale'), url=FunctionUrl(url='/wiki/SetVehicleWheelScale', name='setVehicleWheelScale', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setVehicleWheelStates', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='frontLeft', argument_type='int', default_value=None, optional=False), FunctionArgument(name='rearLeft', argument_type='int', default_value='-1', optional=False), FunctionArgument(name='frontRight', argument_type='int', default_value='-1', optional=False), FunctionArgument(name='rearRight', argument_type='int', default_value='-1', optional=False)]), docs=FunctionDoc(description='This function sets the state of wheels on the vehicle.\nInternally, no vehicles have more than 4 wheels. If they appear to, they will be duplicating other wheels.', arguments={'theVehicle': 'A handle to the vehicle that you wish to change the wheel states of.', 'frontLeft': 'A whole number representing the wheel state (-1 for no change)', 'rearLeft': 'A whole number representing the wheel state (-1 for no change)', 'frontRight': 'A whole number representing the wheel state (-1 for no change)', 'rearRight': 'A whole number representing the wheel state (-1 for no change)'}, result="Returns a boolean value ''true'' or ''false'' that tells you if it was successful or not."), oop=FunctionOOP(class_name='vehicle', method_name='setWheelStates', field=None), url=FunctionUrl(url='/wiki/SetVehicleWheelStates', name='setVehicleWheelStates', category='Vehicle functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setVehicleWheelStates', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='frontLeft', argument_type='int', default_value=None, optional=False), FunctionArgument(name='rearLeft', argument_type='int', default_value='-1', optional=False), FunctionArgument(name='frontRight', argument_type='int', default_value='-1', optional=False), FunctionArgument(name='rearRight', argument_type='int', default_value='-1', optional=False)]), docs=FunctionDoc(description='This function sets the state of wheels on the vehicle.\nInternally, no vehicles have more than 4 wheels. If they appear to, they will be duplicating other wheels.', arguments={'theVehicle': 'A handle to the vehicle that you wish to change the wheel states of.', 'frontLeft': 'A whole number representing the wheel state (-1 for no change)', 'rearLeft': 'A whole number representing the wheel state (-1 for no change)', 'frontRight': 'A whole number representing the wheel state (-1 for no change)', 'rearRight': 'A whole number representing the wheel state (-1 for no change)'}, result="Returns a boolean value ''true'' or ''false'' that tells you if it was successful or not."), oop=FunctionOOP(class_name='vehicle', method_name='setWheelStates', field=None), url=FunctionUrl(url='/wiki/SetVehicleWheelStates', name='setVehicleWheelStates', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehicleWindowOpen', return_types=['bool'], arguments=[FunctionArgument(name='theVehicle', argument_type='vehicle', default_value=None, optional=False), FunctionArgument(name='window', argument_type='int', default_value=None, optional=False), FunctionArgument(name='open', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={}, result=''), oop=None, url=FunctionUrl(url='/wiki/SetVehicleWindowOpen', name='setVehicleWindowOpen', category='Vehicle functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='createWater', return_types=['water'], arguments=[FunctionArgument(name='x1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x3', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y3', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z3', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x4', argument_type='float', default_value=None, optional=True), FunctionArgument(name='y4', argument_type='float', default_value=None, optional=True), FunctionArgument(name='z4', argument_type='float', default_value=None, optional=True), FunctionArgument(name='bShallow', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='Creates an area of [[water]].\nThe largest possible size of a water area is 5996&#0215;5996. Also be aware that the function will change all x and y coordinates you specify into even integer numbers if necessary: this is because of a limitation of San Andreas.\nYou are able to give the water a shallow water effect, which practically changes the water invisible to the eye. However, all elements still work the same way as without the shallow effect - allowing swimming, diving, vehicles to sink, etc.', arguments={'x1, y1, z1': 'position of bottom left (south-west) corner.', 'x2, y2, z2': 'position of bottom right (south-east) corner.', 'x3, y3, z3': "position of top left (north-west) corner.\n''Note: Only 3 coords creates a triangle''", 'x4, y4, z4': 'position of top right (north-east) corner.', 'bShallow': 'gives the water a shallow water effect.'}, result="Returns a water element if successful, ''false'' otherwise. The water element can be repositioned with [[setElementPosition]] and destroyed with [[destroyElement]]."), oop=None, url=FunctionUrl(url='/wiki/CreateWater', name='createWater', category='Water functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='createWater', return_types=['water'], arguments=[FunctionArgument(name='x1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z1', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z2', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x3', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y3', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z3', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x4', argument_type='float', default_value=None, optional=True), FunctionArgument(name='y4', argument_type='float', default_value=None, optional=True), FunctionArgument(name='z4', argument_type='float', default_value=None, optional=True), FunctionArgument(name='bShallow', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='Creates an area of [[water]].\nThe largest possible size of a water area is 5996&#0215;5996. Also be aware that the function will change all x and y coordinates you specify into even integer numbers if necessary: this is because of a limitation of San Andreas.\nYou are able to give the water a shallow water effect, which practically changes the water invisible to the eye. However, all elements still work the same way as without the shallow effect - allowing swimming, diving, vehicles to sink, etc.', arguments={'x1, y1, z1': 'position of bottom left (south-west) corner.', 'x2, y2, z2': 'position of bottom right (south-east) corner.', 'x3, y3, z3': "position of top left (north-west) corner.\n''Note: Only 3 coords creates a triangle''", 'x4, y4, z4': 'position of top right (north-east) corner.', 'bShallow': 'gives the water a shallow water effect.'}, result="Returns a water element if successful, ''false'' otherwise. The water element can be repositioned with [[setElementPosition]] and destroyed with [[destroyElement]]."), oop=None, url=FunctionUrl(url='/wiki/CreateWater', name='createWater', category='Water functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getWaterColor', return_types=['int,', 'int,', 'int,', 'int'], arguments=[]), docs=FunctionDoc(description="This function returns the water color of the GTA world.\n'''Note:''' The server can only return the water color, if it has actually been set by script.", arguments={}, result='Returns 4 [[int|ints]], indicating the color of the water. (RGBA)'), oop=FunctionOOP(class_name='water', method_name='getColor', field=None), url=FunctionUrl(url='/wiki/GetWaterColor', name='getWaterColor', category='Water functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getWaterColor', return_types=['int,', 'int,', 'int,', 'int'], arguments=[]), docs=FunctionDoc(description="This function returns the water color of the GTA world.\n'''Note:''' The server can only return the water color, if it has actually been set by script.", arguments={}, result='Returns 4 [[int|ints]], indicating the color of the water. (RGBA)'), oop=FunctionOOP(class_name='water', method_name='getColor', field=None), url=FunctionUrl(url='/wiki/GetWaterColor', name='getWaterColor', category='Water functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getWaterLevel', return_types=['float'], arguments=[FunctionArgument(name='posX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='posZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='bCheckWaves', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="This function allows you to retrieve the water level from a certain location. The water level is 0 in most places though it can vary (e.g. it's higher near the dam).", arguments={'x': 'The X axis position', 'y': 'The Y axis position', 'z': "The Z axis position\n''or:''", 'theWater': 'the water element', 'bCheckWaves': 'Include the water levels of waves in the ocean, lakes and ...'}, result="Returns an ''integer'' of the water level if the [[localPlayer]]/position is near the water (-3 to 20 on the Z coordinate) else ''false'' if there's no water near the [[localPlayer]]/position."), oop=None, url=FunctionUrl(url='/wiki/GetWaterLevel', name='getWaterLevel', category='Water functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getWaterVertexPosition', return_types=['int', 'int', 'float'], arguments=[FunctionArgument(name='theWater', argument_type='water', default_value=None, optional=False), FunctionArgument(name='vertexIndex', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the world position of a vertex (i.e. corner) of a [[water]] area. Each water area is either a triangle or quad (rectangle) so each has 3 or 4 corners.', arguments={'theWater': 'the water element to get the vertex of', 'vertexIndex': 'the index of the vertex whose position to get. Values range from 1 to 4 for a water quad, or 1 to 3 for a triangle.'}, result="Returns the x, y and z coordinates of the specified vertex if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='water', method_name='getVertexPosition', field=None), url=FunctionUrl(url='/wiki/GetWaterVertexPosition', name='getWaterVertexPosition', category='Water functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getWaterVertexPosition', return_types=['int', 'int', 'float'], arguments=[FunctionArgument(name='theWater', argument_type='water', default_value=None, optional=False), FunctionArgument(name='vertexIndex', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the world position of a vertex (i.e. corner) of a [[water]] area. Each water area is either a triangle or quad (rectangle) so each has 3 or 4 corners.', arguments={'theWater': 'the water element to get the vertex of', 'vertexIndex': 'the index of the vertex whose position to get. Values range from 1 to 4 for a water quad, or 1 to 3 for a triangle.'}, result="Returns the x, y and z coordinates of the specified vertex if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='water', method_name='getVertexPosition', field=None), url=FunctionUrl(url='/wiki/GetWaterVertexPosition', name='getWaterVertexPosition', category='Water functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getWaveHeight', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function returns the current wave height.', arguments={}, result="Returns the height as a [[float]], ''false'' otherwise."), oop=FunctionOOP(class_name='Water', method_name='getWaveHeight', field=None), url=FunctionUrl(url='/wiki/GetWaveHeight', name='getWaveHeight', category='Water functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getWaveHeight', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function returns the current wave height.', arguments={}, result="Returns the height as a [[float]], ''false'' otherwise."), oop=FunctionOOP(class_name='Water', method_name='getWaveHeight', field=None), url=FunctionUrl(url='/wiki/GetWaveHeight', name='getWaveHeight', category='Water functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isWaterDrawnLast', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function determines whether [[water]] is drawn last in the rendering order.\n}}', arguments={}, result="Returns ''true'' if water is drawn last in the rendering order, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/IsWaterDrawnLast', name='isWaterDrawnLast', category='Water functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetWaterColor', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function reset the water color of the GTA world to default.', arguments={}, result="Returns ''true'' if water color was reset correctly, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetWaterColor', name='resetWaterColor', category='Water functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='resetWaterColor', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function reset the water color of the GTA world to default.', arguments={}, result="Returns ''true'' if water color was reset correctly, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetWaterColor', name='resetWaterColor', category='Water functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetWaterLevel', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function resets the water of the GTA world back to its default level. [[water|Water elements]] are not affected.', arguments={}, result="Returns ''true'' if water level was reset correctly, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetWaterLevel', name='resetWaterLevel', category='Water functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='resetWaterLevel', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function resets the water of the GTA world back to its default level. [[water|Water elements]] are not affected.', arguments={}, result="Returns ''true'' if water level was reset correctly, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetWaterLevel', name='resetWaterLevel', category='Water functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setWaterColor', return_types=['bool'], arguments=[FunctionArgument(name='red', argument_type='int', default_value=None, optional=False), FunctionArgument(name='green', argument_type='int', default_value=None, optional=False), FunctionArgument(name='blue', argument_type='int', default_value=None, optional=False), FunctionArgument(name='alpha', argument_type='int', default_value='200', optional=False)]), docs=FunctionDoc(description='This function changes the water color of the GTA world.', arguments={'red': 'The red value of the water, from 0 to 255.', 'green': 'The green value of the water, from 0 to 255.', 'blue': 'The blue value of the water, from 0 to 255.\n{{OptionalArg}} ', 'alpha': 'The alpha (visibility) value of the water, from 0 to 255. Defaults to 200 if not declared.'}, result="Returns ''true'' if water color was set correctly, ''false'' if invalid values were passed."), oop=FunctionOOP(class_name='water', method_name='setColor', field=None), url=FunctionUrl(url='/wiki/SetWaterColor', name='setWaterColor', category='Water functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setWaterColor', return_types=['bool'], arguments=[FunctionArgument(name='red', argument_type='int', default_value=None, optional=False), FunctionArgument(name='green', argument_type='int', default_value=None, optional=False), FunctionArgument(name='blue', argument_type='int', default_value=None, optional=False), FunctionArgument(name='alpha', argument_type='int', default_value='200', optional=False)]), docs=FunctionDoc(description='This function changes the water color of the GTA world.', arguments={'red': 'The red value of the water, from 0 to 255.', 'green': 'The green value of the water, from 0 to 255.', 'blue': 'The blue value of the water, from 0 to 255.\n{{OptionalArg}} ', 'alpha': 'The alpha (visibility) value of the water, from 0 to 255. Defaults to 200 if not declared.'}, result="Returns ''true'' if water color was set correctly, ''false'' if invalid values were passed."), oop=FunctionOOP(class_name='water', method_name='setColor', field=None), url=FunctionUrl(url='/wiki/SetWaterColor', name='setWaterColor', category='Water functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setWaterDrawnLast', return_types=['bool'], arguments=[FunctionArgument(name='bEnabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the [[water]] rendering order.\n}}', arguments={'bEnabled': ': A boolean value determining whether water should be drawn last.'}, result="Returns ''true'' if the rendering order was changed successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetWaterDrawnLast', name='setWaterDrawnLast', category='Water functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setWaterVertexPosition', return_types=['bool'], arguments=[FunctionArgument(name='theWater', argument_type='water', default_value=None, optional=False), FunctionArgument(name='vertexIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='x', argument_type='int', default_value=None, optional=False), FunctionArgument(name='y', argument_type='int', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the world position of a corner point of a water area.', arguments={'theWater': 'the water element of which to change a vertex.', 'vertexIndex': 'the index of the vertex to move. Values range from 1 to 4 for water quads, and 1 to 3 for triangles.', 'x': 'the X coordinate to set for the vertex.', 'y': 'the Y coordinate to set for the vertex.', 'z': 'the Z coordinate to set for the vertex.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='water', method_name='setVertexPosition', field=None), url=FunctionUrl(url='/wiki/SetWaterVertexPosition', name='setWaterVertexPosition', category='Water functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setWaterVertexPosition', return_types=['bool'], arguments=[FunctionArgument(name='theWater', argument_type='water', default_value=None, optional=False), FunctionArgument(name='vertexIndex', argument_type='int', default_value=None, optional=False), FunctionArgument(name='x', argument_type='int', default_value=None, optional=False), FunctionArgument(name='y', argument_type='int', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the world position of a corner point of a water area.', arguments={'theWater': 'the water element of which to change a vertex.', 'vertexIndex': 'the index of the vertex to move. Values range from 1 to 4 for water quads, and 1 to 3 for triangles.', 'x': 'the X coordinate to set for the vertex.', 'y': 'the Y coordinate to set for the vertex.', 'z': 'the Z coordinate to set for the vertex.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='water', method_name='setVertexPosition', field=None), url=FunctionUrl(url='/wiki/SetWaterVertexPosition', name='setWaterVertexPosition', category='Water functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setWaveHeight', return_types=['bool'], arguments=[FunctionArgument(name='height', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the wave height to the desired value, the default is 0.', arguments={'height': 'A float between 0 and 100.'}, result="Returns a boolean value ''true'' or ''false'' that tells you if it was successful or not."), oop=FunctionOOP(class_name='Water', method_name='setWaveHeight', field=None), url=FunctionUrl(url='/wiki/SetWaveHeight', name='setWaveHeight', category='Water functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setWaveHeight', return_types=['bool'], arguments=[FunctionArgument(name='height', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the wave height to the desired value, the default is 0.', arguments={'height': 'A float between 0 and 100.'}, result="Returns a boolean value ''true'' or ''false'' that tells you if it was successful or not."), oop=FunctionOOP(class_name='Water', method_name='setWaveHeight', field=None), url=FunctionUrl(url='/wiki/SetWaveHeight', name='setWaveHeight', category='Water functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getOriginalWeaponProperty', return_types=['int'], arguments=[FunctionArgument(name='weaponID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='weaponSkill', argument_type='string', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the original weapon property of the specified weapons specified weapon type.', arguments={'weaponID or weaponName': 'The ID or name of the weapon you want to get info of. Names can be:\n{{Some Weapon Types}}', 'weaponSkill': 'Either: pro, std or poor', 'property': 'The property you want to get the value of:\n{{Weapon Properties Writable}}\nThe following properties are get only:\n{{Weapon Properties ReadOnly}}'}, result="On success:\n'''int:''' The weapon property\nOn failure:\n'''bool:''' False if the passed arguments were invalid"), oop=None, url=FunctionUrl(url='/wiki/GetOriginalWeaponProperty', name='getOriginalWeaponProperty', category='Weapon functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getOriginalWeaponProperty', return_types=['int'], arguments=[FunctionArgument(name='weaponID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='weaponSkill', argument_type='string', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the original weapon property of the specified weapons specified weapon type.', arguments={'weaponID or weaponName': 'The ID or name of the weapon you want to get info of. Names can be:\n{{Some Weapon Types}}', 'weaponSkill': 'Either: pro, std or poor', 'property': 'The property you want to get the value of:\n{{Weapon Properties Writable}}\nThe following properties are get only:\n{{Weapon Properties ReadOnly}}'}, result="On success:\n'''int:''' The weapon property\nOn failure:\n'''bool:''' False if the passed arguments were invalid"), oop=None, url=FunctionUrl(url='/wiki/GetOriginalWeaponProperty', name='getOriginalWeaponProperty', category='Weapon functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getSlotFromWeapon', return_types=['int'], arguments=[FunctionArgument(name='weaponid', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to identify the weapon slot that a weapon belongs to.', arguments={'weaponid': 'Weapon to find the weapon slot of.'}, result="Returns an integer representing the given weapon ID's associated weapon slot, ''false'' if the ID was invalid."), oop=None, url=FunctionUrl(url='/wiki/GetSlotFromWeapon', name='getSlotFromWeapon', category='Weapon functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getSlotFromWeapon', return_types=['int'], arguments=[FunctionArgument(name='weaponid', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to identify the weapon slot that a weapon belongs to.', arguments={'weaponid': 'Weapon to find the weapon slot of.'}, result="Returns an integer representing the given weapon ID's associated weapon slot, ''false'' if the ID was invalid."), oop=None, url=FunctionUrl(url='/wiki/GetSlotFromWeapon', name='getSlotFromWeapon', category='Weapon functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getWeaponIDFromName', return_types=['int'], arguments=[FunctionArgument(name='name', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will obtain the ID of a particular weapon from its name.', arguments={'name': 'A string containing the name of the weapon. Names can be: (Case is ignored)\n{{All Weapon Types}}'}, result="Returns an [[int]] if the name matches that of a weapon, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetWeaponIDFromName', name='getWeaponIDFromName', category='Weapon functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getWeaponIDFromName', return_types=['int'], arguments=[FunctionArgument(name='name', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will obtain the ID of a particular weapon from its name.', arguments={'name': 'A string containing the name of the weapon. Names can be: (Case is ignored)\n{{All Weapon Types}}'}, result="Returns an [[int]] if the name matches that of a weapon, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetWeaponIDFromName', name='getWeaponIDFromName', category='Weapon functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getWeaponNameFromID', return_types=['string'], arguments=[FunctionArgument(name='id', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to retrieve the name of a weapon from an ID.', arguments={'id': 'The ID you wish to retrieve the name of'}, result="Returns a string of the name of the weapon or death type, ''false'' otherwise. Names will be like these: (Ignoring case)\n{{All Weapon Types}}"), oop=None, url=FunctionUrl(url='/wiki/GetWeaponNameFromID', name='getWeaponNameFromID', category='Weapon functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getWeaponNameFromID', return_types=['string'], arguments=[FunctionArgument(name='id', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to retrieve the name of a weapon from an ID.', arguments={'id': 'The ID you wish to retrieve the name of'}, result="Returns a string of the name of the weapon or death type, ''false'' otherwise. Names will be like these: (Ignoring case)\n{{All Weapon Types}}"), oop=None, url=FunctionUrl(url='/wiki/GetWeaponNameFromID', name='getWeaponNameFromID', category='Weapon functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getWeaponProperty', return_types=['int'], arguments=[FunctionArgument(name='weaponID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='weaponSkill', argument_type='string', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets a weapon property of the specified [[Element/Weapon|custom weapon]] (clientside only) or specified [[Weapons|player-held weapon]] (both client and server).', arguments={'weaponID or weaponName': 'The ID or name of the weapon you want to get info of. Names can be:\n{{Some Weapon Types}}', 'weaponSkill': 'Either: pro, std or poor', 'property': 'The property you want to get the value of:\n{{Weapon Properties Writable}}\nThe following properties are get only:\n{{Weapon Properties ReadOnly}}'}, result="On success:\n'''int:''' The weapon property\nOn failure:\n'''bool:''' False if the passed arguments were invalid"), oop=None, url=FunctionUrl(url='/wiki/GetWeaponProperty', name='getWeaponProperty', category='Weapon functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getWeaponProperty', return_types=['int'], arguments=[FunctionArgument(name='weaponID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='weaponSkill', argument_type='string', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets a weapon property of the specified [[Element/Weapon|custom weapon]] (clientside only) or specified [[Weapons|player-held weapon]] (both client and server).', arguments={'weaponID or weaponName': 'The ID or name of the weapon you want to get info of. Names can be:\n{{Some Weapon Types}}', 'weaponSkill': 'Either: pro, std or poor', 'property': 'The property you want to get the value of:\n{{Weapon Properties Writable}}\nThe following properties are get only:\n{{Weapon Properties ReadOnly}}'}, result="On success:\n'''int:''' The weapon property\nOn failure:\n'''bool:''' False if the passed arguments were invalid"), oop=None, url=FunctionUrl(url='/wiki/GetWeaponProperty', name='getWeaponProperty', category='Weapon functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='createWeapon', return_types=['weapon'], arguments=[FunctionArgument(name='theType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="Creates a [[Element/Weapon|custom weapon]] that can fire bullets. '''Do not confuse this with player held weapons'''.", arguments={'theType': 'The weapon type which can be:\n{{Custom Weapon Types}}', 'x': 'The x position to create the weapon.', 'y': 'The y position to create the weapon.', 'z': 'The z position to create the weapon.'}, result='Returns a [[Element/Weapon|custom weapon]] element, which represents a weapon floating at that position.'), oop=None, url=FunctionUrl(url='/wiki/CreateWeapon', name='createWeapon', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='fireWeapon', return_types=['bool'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False)]), docs=FunctionDoc(description='Fires one shot from a [[Element/Weapon|custom weapon]].', arguments={'theWeapon': 'The weapon to be fired.'}, result="Returns ''true'' if the shot weapon is valid and therefore the shot was fired, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/FireWeapon', name='fireWeapon', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getWeaponAmmo', return_types=['int'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the total ammo a [[Element/Weapon|custom weapon]] has.', arguments={'theWeapon': ': The weapon to get the ammo of.'}, result="Returns an [[int|integer]] containing how many ammo left has the weapon. Returns ''false'' if an error occured."), oop=FunctionOOP(class_name='weapon', method_name='getAmmo', field='ammo'), url=FunctionUrl(url='/wiki/GetWeaponAmmo', name='getWeaponAmmo', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getWeaponClipAmmo', return_types=['int'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets the amount of ammo left in a [[Element/Weapon|custom weapon]]'s magazine/clip.", arguments={'theWeapon': 'the weapon to get the clip ammo of.'}, result="Returns the amount of ammo in the [[Element/Weapon|custom weapon]]'s clip, ''false'' if an error occured."), oop=FunctionOOP(class_name='weapon', method_name='getClipAmmo', field='clipAmmo'), url=FunctionUrl(url='/wiki/GetWeaponClipAmmo', name='getWeaponClipAmmo', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getWeaponFiringRate', return_types=['int'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False)]), docs=FunctionDoc(description='This gets the firing rate to be used when a [[Element/Weapon|custom weapon]] opens fire.', arguments={'theWeapon': 'The weapon to modify the firing rate of.'}, result="Returns an ''integer'' with the firing rate of the custom weapon, ''false'' otherwise."), oop=FunctionOOP(class_name='weapon', method_name='getFiringRate', field='firingRate'), url=FunctionUrl(url='/wiki/GetWeaponFiringRate', name='getWeaponFiringRate', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getWeaponFlags', return_types=['bool'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False), FunctionArgument(name='theFlag', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the flags of a [[Element/Weapon|custom weapon]].', arguments={'theWeapon': 'the weapon to get the flag of.', 'theFlag': 'the weapon flag to get:', 'disable_model': ': makes the weapon and muzzle effect invisible or not.', 'flags': ': returns the flags used to get where the gun shoots at. These flags are (by order):', 'checkBuildings': ': allows the shoot to be blocked by GTAs internally placed buildings, i.e. the world map.', 'checkCarTires': ': allows the shoot to be blocked by vehicle tires.', 'checkDummies': ': allows the shoot to be blocked by GTAs internal dummies. These are not used in the current MTA version so this argument can be set to false.', 'checkObjects': ': allows the shoot to be blocked by object|objects.', 'checkPeds': ': allows the shoot to be blocked by ped|peds and player|players.', 'checkVehicles': ': allows the shoot to be blocked by vehicle|vehicles.', 'checkSeeThroughStuff': ': allows the shoot to be blocked by translucent game objects, e.g. glass.', 'checkShootThroughStuff': ': allows the shoot to be blocked by things that can be shot through.', 'instant_reload': ': if enabled, the weapon reloads instantly rather than waiting the reload time until shooting again.', 'shoot_if_out_of_range': ': if enabled, the weapon still fires its target beyond the weapon range distance.', 'shoot_if_blocked': ': if enabled, the weapon still fires its target even if its blocked by something.'}, result="Returns the ''true'' or ''false'' on success (''flags'' flag returns 8 values) if the flag is enabled or not. Returns ''false'' if the weapon element isn't valid or an error occured."), oop=FunctionOOP(class_name='weapon', method_name='getFlags', field=None), url=FunctionUrl(url='/wiki/GetWeaponFlags', name='getWeaponFlags', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getWeaponOwner', return_types=['bool'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets the owner of a [[Element/Weapon|custom weapon]]. Weapon ownership system was, however, disabled, so this function always returns ''false''. Please refer to [[setWeaponOwner]] for details.", arguments={'theWeapon': 'The weapon to get the owner of.'}, result="This function was intended to return the [[player]] which owns the [[Element/Weapon|custom weapon]], and ''false'' if an error occured. However, at the moment it always returns ''false''."), oop=FunctionOOP(class_name='weapon', method_name='getOwner', field='owner'), url=FunctionUrl(url='/wiki/GetWeaponOwner', name='getWeaponOwner', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getWeaponProperty', return_types=['int'], arguments=[FunctionArgument(name='weaponID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='weaponSkill', argument_type='string', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets a weapon property of the specified [[Element/Weapon|custom weapon]] (clientside only) or specified [[Weapons|player-held weapon]] (both client and server).', arguments={'weaponID or weaponName': 'The ID or name of the weapon you want to get info of. Names can be:\n{{Some Weapon Types}}', 'weaponSkill': 'Either: pro, std or poor', 'property': 'The property you want to get the value of:\n{{Weapon Properties Writable}}\nThe following properties are get only:\n{{Weapon Properties ReadOnly}}'}, result="On success:\n'''int:''' The weapon property\nOn failure:\n'''bool:''' False if the passed arguments were invalid"), oop=None, url=FunctionUrl(url='/wiki/GetWeaponProperty', name='getWeaponProperty', category='Weapon creation functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getWeaponProperty', return_types=['int'], arguments=[FunctionArgument(name='weaponID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='weaponSkill', argument_type='string', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets a weapon property of the specified [[Element/Weapon|custom weapon]] (clientside only) or specified [[Weapons|player-held weapon]] (both client and server).', arguments={'weaponID or weaponName': 'The ID or name of the weapon you want to get info of. Names can be:\n{{Some Weapon Types}}', 'weaponSkill': 'Either: pro, std or poor', 'property': 'The property you want to get the value of:\n{{Weapon Properties Writable}}\nThe following properties are get only:\n{{Weapon Properties ReadOnly}}'}, result="On success:\n'''int:''' The weapon property\nOn failure:\n'''bool:''' False if the passed arguments were invalid"), oop=None, url=FunctionUrl(url='/wiki/GetWeaponProperty', name='getWeaponProperty', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getWeaponState', return_types=['string'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False)]), docs=FunctionDoc(description='This function gets the state of a [[Element/Weapon|custom weapon]].', arguments={'theWeapon': 'the Element/Weapon|weapon to get the state of.'}, result="* A [[string]] if the [[Element/Weapon|weapon]] is valid, indicating the weapon state, which can be:\n** '''reloading''': the weapon is reloading.\n** '''firing''': the weapon is constantly shooting (unless any shooting blocking flags are set) according to its assigned firing rate.\n** '''ready''': the weapon is idle.\n* ''false'' if an error occured or the [[Element/Weapon|weapon]] is invalid."), oop=FunctionOOP(class_name='weapon', method_name='getState', field='state'), url=FunctionUrl(url='/wiki/GetWeaponState', name='getWeaponState', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getWeaponTarget', return_types=['nil/element/float'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False)]), docs=FunctionDoc(description='This functions gets the target of a [[Element/Weapon|custom weapon]].', arguments={'theWeapon': 'The weapon to get the target of.'}, result="* Returns the ''target'' of the [[Element/Weapon|custom weapon]], which can be:\n**''[[nil]]'' if the weapon is in rotation based targeting.\n**3 [[float|floats]] if the weapon is firing at a fixed point.\n**an [[element]] if the weapon is firing an entity.\n* Returns ''false'' if the weapon element is not valid."), oop=FunctionOOP(class_name='weapon', method_name='getTarget', field='target'), url=FunctionUrl(url='/wiki/GetWeaponTarget', name='getWeaponTarget', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='resetWeaponFiringRate', return_types=['bool'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False)]), docs=FunctionDoc(description='This function resets the firing rate of a [[Element/Weapon|custom weapon]] to the default one.', arguments={'theWeapon': 'the weapon to reset the firing rate of.'}, result="Returns ''true'' on success, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetWeaponFiringRate', name='resetWeaponFiringRate', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setWeaponClipAmmo', return_types=['bool'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False), FunctionArgument(name='clipAmmo', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the ammo left in a [[Element/Weapon|custom weapon]]'s magazine/clip.", arguments={'theWeapon': 'The Element/Weapon|weapon to set the clip ammo of.', 'clipAmmo': 'The amount of ammo in the clip.'}, result="This function returns ''true'' if the arguments are valid and the weapon clip ammo could be changed; ''false'' otherwise."), oop=FunctionOOP(class_name='weapon', method_name='setClipAmmo', field='clipAmmo'), url=FunctionUrl(url='/wiki/SetWeaponClipAmmo', name='setWeaponClipAmmo', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setWeaponFiringRate', return_types=['bool'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False), FunctionArgument(name='firingRate', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the firing rate to be used when a [[Element/Weapon|custom weapon]] is in ''firing'' state.", arguments={'theWeapon': 'The weapon to modify the firing rate of.', 'firingRate': 'The weapon firing rate. It seems to be a kind of frecuency value, so the lower the quicker the Element/Weapon|custom weapon will shoot.'}, result="Returns ''true'' on success, ''false'' otherwise."), oop=FunctionOOP(class_name='weapon', method_name='setFiringRate', field='firingRate'), url=FunctionUrl(url='/wiki/SetWeaponFiringRate', name='setWeaponFiringRate', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setWeaponFlags', return_types=['bool'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False), FunctionArgument(name='theFlag', argument_type='string', default_value=None, optional=False), FunctionArgument(name='enable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets a [[Element/Weapon|custom weapon]] flags, used to change how it behaves or finds a possible target to shoot.', arguments={'theWeapon': 'the Element/Weapon|weapon element to set the flag of.', 'theFlag': 'the weapon flag to change (all of them can be true or false):', 'disable_model': ': makes the weapon and muzzle effect invisible or not.', 'flags': ': configures the flags used to get where the gun shoots at. They are based on processLineOfSights. You have to specify all the eight flags for the function to succeed. These flags are (by order):', 'checkBuildings': ': allows the shoot to be blocked by GTAs internally placed buildings, i.e. the world map.', 'checkCarTires': ': allows the shoot to be blocked by vehicle tires.', 'checkDummies': ': allows the shoot to be blocked by GTAs internal dummies. These are not used in the current MTA version so this argument can be set to false.', 'checkObjects': ': allows the shoot to be blocked by object|objects.', 'checkPeds': ': allows the shoot to be blocked by ped|peds and player|players.', 'checkVehicles': ': allows the shoot to be blocked by vehicle|vehicles.', 'checkSeeThroughStuff': ': allows the shoot to be blocked by translucent game objects, e.g. glass.', 'checkShootThroughStuff': ': allows the shoot to be blocked by things that can be shot through.', 'instant_reload': ': if enabled, the weapon will reload instantly rather than waiting the reload time until shooting again.', 'shoot_if_out_of_range': ': if enabled, the weapon will still fire its target beyond the weapon range distance.', 'shoot_if_blocked': ': if enabled, the weapon will still fire its target even if its blocked by something.', 'enable': ': whether to enable or disable the specified flag.'}, result="Returns ''true'' if all arguments are valid and the flags where changed; ''false'' otherwise."), oop=FunctionOOP(class_name='weapon', method_name='setFlags', field=None), url=FunctionUrl(url='/wiki/SetWeaponFlags', name='setWeaponFlags', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setWeaponProperty', return_types=['bool'], arguments=[FunctionArgument(name='weaponID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='weaponSkill', argument_type='string', default_value=None, optional=False), FunctionArgument(name='property', argument_type='string', default_value=None, optional=False), FunctionArgument(name='float', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='<section name="Server" class="server" show="true">\nThis function sets the weapon property of the specified weapons specified weapon type. See lower down the page for documentation related to weapon creation.', arguments={'weaponID': 'The ID or name of the Weapons|weapon you want to set a property of. Names can be:\n{{Some Weapon Types}}', 'weaponSkill': 'Either: pro, std or poor. The player must have this skill level set to have the effect.', 'property': 'The property you want to set the value of:\n{{Weapon Properties Writable}}', 'theValue': 'The value to set the property to.'}, result="On success:\n'''bool:''' Returns true if the weapon property was successfully set\nOn failure:\n'''bool:''' Returns false if the weapon property was unable to be set"), oop=None, url=FunctionUrl(url='/wiki/SetWeaponProperty', name='setWeaponProperty', category='Weapon creation functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setWeaponProperty', return_types=['bool'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False), FunctionArgument(name='strProperty', argument_type='string', default_value=None, optional=False), FunctionArgument(name='theValue', argument_type='value', default_value=None, optional=False)]), docs=FunctionDoc(description='<section name="Server" class="server" show="true">\nThis function sets the weapon property of the specified weapons specified weapon type. See lower down the page for documentation related to weapon creation.', arguments={'theWeapon': 'the weapon to change the property of.', 'strProperty': 'the property to edit:\n{{Custom Weapon Properties Writable}}', 'theValue': 'The value to set the property to.'}, result="Returns ''true'' if the property was set."), oop=FunctionOOP(class_name='weapon', method_name='setProperty', field=None), url=FunctionUrl(url='/wiki/SetWeaponProperty', name='setWeaponProperty', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setWeaponState', return_types=['bool'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False), FunctionArgument(name='theState', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets a [[Element/Weapon|custom weapon]]'s state.", arguments={'theWeapon': ': the weapon you wish to set the state of.', 'theState': ': the state you wish to set:', 'reloading': ': makes the weapon reload.', 'firing': ': makes the weapon constantly fire its target (unless any shooting blocking flags are set) according to its assigned firing rate.', 'ready': ': makes the weapon stop reloading or firing.'}, result="Returns ''true'' on success, ''false'' otherwise."), oop=FunctionOOP(class_name='weapon', method_name='setState', field='state'), url=FunctionUrl(url='/wiki/SetWeaponState', name='setWeaponState', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setWeaponTarget', return_types=['bool'], arguments=[FunctionArgument(name='theWeapon', argument_type='weapon', default_value=None, optional=False), FunctionArgument(name='theTarget', argument_type='element', default_value=None, optional=False), FunctionArgument(name='theComponent', argument_type='int', default_value='255', optional=True)]), docs=FunctionDoc(description='This function sets the target of a [[Element/Weapon|custom weapon]]. There are 3 different targeting modes, which are explained below.', arguments={'theWeapon': 'The weapon to set the target of.', 'theTarget': 'The element to shoot at. It can be a player, ped, vehicle or object.', 'theComponent': 'The component of the target to shoot at. This argument is only relevant when used in the following element types:', '[[Vehicle|Vehicles]]': ':', '0': ': front left tire.', '1': 'BONE_PELVIS1 position.', '2': 'BONE_PELVIS position.', '3': 'BONE_SPINE1 position.', '255': ': center of the ped (position returned by getElementPosition).', '[[Ped|Peds]]': '(players not included; see getPedBonePosition to know where is located each bone):', '4': 'BONE_UPPERTORSO position.', '5': 'BONE_NECK position.', '6': 'BONE_HEAD2 position.', '7': 'BONE_HEAD1 position.', '8': 'BONE_HEAD position.', '21': 'BONE_RIGHTUPPERTORSO position.', '22': 'BONE_RIGHTSHOULDER position.', '23': 'BONE_RIGHTELBOW position.', '24': 'BONE_RIGHTWRIST position.', '25': 'BONE_RIGHTHAND position.', '26': 'BONE_RIGHTTHUMB position.', '31': 'BONE_LEFTUPPERTORSO position.', '32': 'BONE_LEFTSHOULDER position.', '33': 'BONE_LEFTELBOW position.', '34': 'BONE_LEFTWRIST position.', '35': 'BONE_LEFTHAND position.', '36': 'BONE_LEFTTHUMB position.', '41': 'BONE_LEFTHIP position.', '42': 'BONE_LEFTKNEE position.', '43': 'BONE_LEFTANKLE position.', '44': 'BONE_LEFTFOOT position.', '51': 'BONE_RIGHTHIP position.', '52': 'BONE_RIGHTKNEE position.', '53': 'BONE_RIGHTANKLE position.', '54': 'BONE_RIGHTFOOT position.'}, result="Returns ''true'' on success, ''false'' otherwise."), oop=FunctionOOP(class_name='weapon', method_name='setTarget', field='target'), url=FunctionUrl(url='/wiki/SetWeaponTarget', name='setWeaponTarget', category='Weapon creation functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='areTrafficLightsLocked', return_types=['bool'], arguments=[]), docs=FunctionDoc(description="Gets whether the traffic lights are currently locked or not. If the lights are locked, it means they won't change unless you do [[setTrafficLightState]].", arguments={}, result="Returns ''true'' the traffic lights are currently locked, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/AreTrafficLightsLocked', name='areTrafficLightsLocked', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='areTrafficLightsLocked', return_types=['bool'], arguments=[]), docs=FunctionDoc(description="Gets whether the traffic lights are currently locked or not. If the lights are locked, it means they won't change unless you do [[setTrafficLightState]].", arguments={}, result="Returns ''true'' the traffic lights are currently locked, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/AreTrafficLightsLocked', name='areTrafficLightsLocked', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='createSWATRope', return_types=['bool'], arguments=[FunctionArgument(name='fx', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fy', argument_type='float', default_value=None, optional=False), FunctionArgument(name='fZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='duration', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Creates a SWAT rope like that of the rope in single player used by SWAT Teams abseiling from the Police Maverick.', arguments={'fx, fy, fz': 'the world coordinates where the effect originates.', 'duration': 'the amount in miliseconds the rope will be there before falling to the ground.'}, result=''), oop=None, url=FunctionUrl(url='/wiki/CreateSWATRope', name='createSWATRope', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAircraftMaxHeight', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function gets the maximum height at which aircraft can fly without their engines turning off.', arguments={}, result='Returns a float containing the max aircraft height.'), oop=None, url=FunctionUrl(url='/wiki/GetAircraftMaxHeight', name='getAircraftMaxHeight', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getAircraftMaxHeight', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function gets the maximum height at which aircraft can fly without their engines turning off.', arguments={}, result='Returns a float containing the max aircraft height.'), oop=None, url=FunctionUrl(url='/wiki/GetAircraftMaxHeight', name='getAircraftMaxHeight', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getAircraftMaxVelocity', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function returns the maximum velocity at which aircrafts could fly. Using this function server-side will return the server-side value, not necessarily the same that is set client-side.\n}}', arguments={}, result='Returns a float being the max velocity that is currently set, depending on which side it is used.'), oop=None, url=FunctionUrl(url='/wiki/GetAircraftMaxVelocity', name='getAircraftMaxVelocity', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getAircraftMaxVelocity', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function returns the maximum velocity at which aircrafts could fly. Using this function server-side will return the server-side value, not necessarily the same that is set client-side.\n}}', arguments={}, result='Returns a float being the max velocity that is currently set, depending on which side it is used.'), oop=None, url=FunctionUrl(url='/wiki/GetAircraftMaxVelocity', name='getAircraftMaxVelocity', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getBirdsEnabled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function will tell you if the birds are enabled or disabled. ', arguments={}, result="Returns ''true'' if the birds are enabled or ''false'' if the birds are disabled. "), oop=None, url=FunctionUrl(url='/wiki/GetBirdsEnabled', name='getBirdsEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getCloudsEnabled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function will tell you if clouds are enabled or disabled.', arguments={}, result="Returns ''true'' if the clouds are enabled or ''false'' if clouds are disabled."), oop=None, url=FunctionUrl(url='/wiki/GetCloudsEnabled', name='getCloudsEnabled', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getCloudsEnabled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function will tell you if clouds are enabled or disabled.', arguments={}, result="Returns ''true'' if the clouds are enabled or ''false'' if clouds are disabled."), oop=None, url=FunctionUrl(url='/wiki/GetCloudsEnabled', name='getCloudsEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getFarClipDistance', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function will tell you what is the current render distance.', arguments={}, result="Returns a ''float'' with the current render distance, ''false'' if the operation could not be completed."), oop=None, url=FunctionUrl(url='/wiki/GetFarClipDistance', name='getFarClipDistance', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getFarClipDistance', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function will tell you what is the current render distance.', arguments={}, result="Returns a ''float'' with the current render distance, ''false'' if the operation could not be completed."), oop=None, url=FunctionUrl(url='/wiki/GetFarClipDistance', name='getFarClipDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getFogDistance', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function will tell you what is the current fog render distance.', arguments={}, result="Returns a ''float'' with the current fog render distance, ''false'' if the operation could not be completed."), oop=None, url=FunctionUrl(url='/wiki/GetFogDistance', name='getFogDistance', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getFogDistance', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function will tell you what is the current fog render distance.', arguments={}, result="Returns a ''float'' with the current fog render distance, ''false'' if the operation could not be completed."), oop=None, url=FunctionUrl(url='/wiki/GetFogDistance', name='getFogDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getGameSpeed', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function gets the current game speed value.', arguments={}, result="Returns a ''float'' representing the speed of the game."), oop=None, url=FunctionUrl(url='/wiki/GetGameSpeed', name='getGameSpeed', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getGameSpeed', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function gets the current game speed value.', arguments={}, result="Returns a ''float'' representing the speed of the game."), oop=None, url=FunctionUrl(url='/wiki/GetGameSpeed', name='getGameSpeed', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getGarageBoundingBox', return_types=['float,', 'float,', 'float,', 'float'], arguments=[FunctionArgument(name='garageID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function outputs the bounding box of a garage. ', arguments={'garageID': 'The Garage|garage ID that represents the garage door that is being checked.'}, result="Returns four ''float''s indicating the bounding box of the garage.\n''Western X position, Eastern X position, Southern Y position, Northern Y position,, false when invalid garageID was provided.''"), oop=None, url=FunctionUrl(url='/wiki/GetGarageBoundingBox', name='getGarageBoundingBox', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getGaragePosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='garageID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function outputs X, Y and Z position of given garage.', arguments={'garageID': 'The Garage|garage ID that represents the garage door that is being checked.'}, result="Returns three ''float''s indicating the position of the garage, ''x'', ''y'' and ''z'' respectively, false when garageID was invalid."), oop=None, url=FunctionUrl(url='/wiki/GetGaragePosition', name='getGaragePosition', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getGarageSize', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='garageID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function outputs the size of garage.', arguments={'garageID': 'The Garage|garage ID that represents the garage door that is being checked.'}, result="Returns three ''float''s indicating the size of the garage, false if an invalid garageID has been provided"), oop=None, url=FunctionUrl(url='/wiki/GetGarageSize', name='getGarageSize', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getGravity', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function returns the current gravity level for the context in which it is called (server or client).', arguments={}, result='Returns a float with the current server or client (depending on where you call the function) gravity level.'), oop=None, url=FunctionUrl(url='/wiki/GetGravity', name='getGravity', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getGravity', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function returns the current gravity level for the context in which it is called (server or client).', arguments={}, result='Returns a float with the current server or client (depending on where you call the function) gravity level.'), oop=None, url=FunctionUrl(url='/wiki/GetGravity', name='getGravity', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getGroundPosition', return_types=['float'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets the Z level of the highest ground below a point. \nIt is required that the point is near enough to the local player so that it's within the area where collision data is loaded. If this is not the case, an incorrect position will be returned.", arguments={'x': 'A floating point number representing the X world coordinate of the point.', 'y': 'A floating point number representing the Y world coordinate of the point.', 'z': 'A floating point number representing the Z world coordinate of the point.'}, result="Returns a float with the highest ground-level Z coord if parameters are valid, ''0'' if the point you tried to test is outside the loaded world map, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetGroundPosition', name='getGroundPosition', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getHeatHaze', return_types=['int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'bool'], arguments=[]), docs=FunctionDoc(description="This function will return the current heat haze effect settings.\n'''Note:''' The server can only return the heat haze settings if it has actually been set by script.", arguments={}, result='Returns 9 values, which are the same used as arguments in [[SetHeatHaze]]:\n{{HeatHazeValues}}'), oop=None, url=FunctionUrl(url='/wiki/GetHeatHaze', name='getHeatHaze', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getHeatHaze', return_types=['int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'int,', 'bool'], arguments=[]), docs=FunctionDoc(description="This function will return the current heat haze effect settings.\n'''Note:''' The server can only return the heat haze settings if it has actually been set by script.", arguments={}, result='Returns 9 values, which are the same used as arguments in [[SetHeatHaze]]:\n{{HeatHazeValues}}'), oop=None, url=FunctionUrl(url='/wiki/GetHeatHaze', name='getHeatHaze', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getInteriorFurnitureEnabled', return_types=['bool'], arguments=[FunctionArgument(name='roomID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will tell you if interior furniture are enabled or disabled in a specified room ID.\n}}', arguments={}, result="Returns ''true'' if interior furniture is enabled or ''false'' if interior furniture is disabled."), oop=None, url=FunctionUrl(url='/wiki/GetInteriorFurnitureEnabled', name='getInteriorFurnitureEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getInteriorSoundsEnabled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function checks to see if the music played by default in clubs is disabled or not.', arguments={}, result='Returns true if music is playing, returns false if music is not playing.'), oop=None, url=FunctionUrl(url='/wiki/GetInteriorSoundsEnabled', name='getInteriorSoundsEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getJetpackMaxHeight', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function gets the maximum height at which your jetpack can fly without failing to go higher.', arguments={}, result='Returns a float containing the max jetpack height.'), oop=None, url=FunctionUrl(url='/wiki/GetJetpackMaxHeight', name='getJetpackMaxHeight', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getJetpackMaxHeight', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function gets the maximum height at which your jetpack can fly without failing to go higher.', arguments={}, result='Returns a float containing the max jetpack height.'), oop=None, url=FunctionUrl(url='/wiki/GetJetpackMaxHeight', name='getJetpackMaxHeight', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getMinuteDuration', return_types=['int'], arguments=[]), docs=FunctionDoc(description='Tells you how long an ingame minute takes in real-world milliseconds. The default GTA value is 1000.', arguments={}, result='Returns the number of real-world milliseconds that go in an ingame minute.'), oop=None, url=FunctionUrl(url='/wiki/GetMinuteDuration', name='getMinuteDuration', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getMinuteDuration', return_types=['int'], arguments=[]), docs=FunctionDoc(description='Tells you how long an ingame minute takes in real-world milliseconds. The default GTA value is 1000.', arguments={}, result='Returns the number of real-world milliseconds that go in an ingame minute.'), oop=None, url=FunctionUrl(url='/wiki/GetMinuteDuration', name='getMinuteDuration', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getMoonSize', return_types=['int'], arguments=[]), docs=FunctionDoc(description='This function returns the moon size.\n}}', arguments={}, result='Returns a integer being the moon size that is currently set, depending on which side it is used.'), oop=None, url=FunctionUrl(url='/wiki/GetMoonSize', name='getMoonSize', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getMoonSize', return_types=['int'], arguments=[]), docs=FunctionDoc(description='This function returns the moon size.\n}}', arguments={}, result='Returns a integer being the moon size that is currently set, depending on which side it is used.'), oop=None, url=FunctionUrl(url='/wiki/GetMoonSize', name='getMoonSize', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getNearClipDistance', return_types=['float'], arguments=[]), docs=FunctionDoc(description='', arguments={}, result="This function returns a ''[[float]]'' containing the actual near clip distance."), oop=None, url=FunctionUrl(url='/wiki/GetNearClipDistance', name='getNearClipDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='resetNearClipDistance', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function resets near clip distance set by [[setNearClipDistance]].\n}}', arguments={}, result="*'''boolean:''' always returns '''true'''"), oop=None, url=FunctionUrl(url='/wiki/ResetNearClipDistance', name='resetNearClipDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getOcclusionsEnabled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function is used to get "occlusions enabled" state.', arguments={}, result="Returns ''true'' if occlusions are enabled, or ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetOcclusionsEnabled', name='getOcclusionsEnabled', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getOcclusionsEnabled', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function is used to get "occlusions enabled" state.', arguments={}, result="Returns ''true'' if occlusions are enabled, or ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetOcclusionsEnabled', name='getOcclusionsEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getPedsLODDistance', return_types=['float'], arguments=[]), docs=FunctionDoc(description='', arguments={}, result="This function returns a ''[[float]]'' containing the peds LOD distance."), oop=None, url=FunctionUrl(url='/wiki/GetPedsLODDistance', name='getPedsLODDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setPedsLODDistance', return_types=['bool'], arguments=[FunctionArgument(name='distance', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='[[File:Peds Lod Distance = 60.png|200px|thumb|right|60 units]]\n[[File:Peds Lod Distance = 100.png|200px|thumb|right|100 units]]\n[[File:Peds Lod Distance = 500.png|200px|thumb|right|500 units]]', arguments={'distance': 'the new peds LOD distance. It must be between 0 and 500. (Default for high_detail_peds on is 500, when off, it is 60).'}, result="This function returns ''true'' if the argument is valid. Returns ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetPedsLODDistance', name='setPedsLODDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='resetPedsLODDistance', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='', arguments={}, result="Returns ''true'' if the peds LOD distance was reset, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetPedsLODDistance', name='resetPedsLODDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getPlayerBlurLevel', return_types=['int'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to check the current blur level of a specified [[player]].', arguments={'thePlayer': 'The player whose blur level you want to check.'}, result="Returns the player's blur level if successful, ''false'' if an invalid player was given."), oop=FunctionOOP(class_name='player', method_name='getBlurLevel', field=None), url=FunctionUrl(url='/wiki/GetPlayerBlurLevel', name='getPlayerBlurLevel', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getBlurLevel', return_types=['int'], arguments=[]), docs=FunctionDoc(description='This function allows you to check the current blur level of a specified [[player]].', arguments={}, result='Returns the local blur level.'), oop=FunctionOOP(class_name='Player', method_name='getBlurLevel', field='blurLevel'), url=FunctionUrl(url='/wiki/GetPlayerBlurLevel', name='getPlayerBlurLevel', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getRainLevel', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function is used to get the current rain level.', arguments={}, result='Returns the rain level as a number.'), oop=None, url=FunctionUrl(url='/wiki/GetRainLevel', name='getRainLevel', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getRainLevel', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function is used to get the current rain level.', arguments={}, result='Returns the rain level as a number.'), oop=None, url=FunctionUrl(url='/wiki/GetRainLevel', name='getRainLevel', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getRoofPosition', return_types=['float'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function gets the Z level of the lowest roof above a point.\nIt is required that the point is near enough to the local player so that it's within the area where collision data is loaded.}}", arguments={'x': ': A floating point number representing the X world coordinate of the point.', 'y': ': A floating point number representing the Y world coordinate of the point.', 'z': ': A floating point number representing the Z world coordinate of the point.'}, result="Returns a [[float]] with the lowest roof-level Z coord if parameters are valid, ''false'' if the point you tried to test is outside the loaded world map."), oop=None, url=FunctionUrl(url='/wiki/GetRoofPosition', name='getRoofPosition', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getScreenFromWorldPosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='edgeTolerance', argument_type='float', default_value='0.0', optional=True), FunctionArgument(name='relative', argument_type='bool', default_value='true', optional=True)]), docs=FunctionDoc(description='This function gets the screen position of a point in the world. This is useful for attaching 2D gui elements to parts of the world (e.g. players) or detecting if a point is on the screen (though it does not check if it is actually visible, you should use [[processLineOfSight]] for that).', arguments={'x': 'A float value indicating the x position in the world.', 'y': 'A float value indicating the y position in the world.', 'z': 'A float value indicating the z position in the world.\n{{OptionalArg}}\n{{New feature/item|3|1.0||', 'edgeTolerance': 'A float value indicating the distance the position can be off screen before the function returns false. Note: its clamped down on both axies to the size of screen at the given axis*10', 'relative': 'A boolean value that indicates if edgeTolerance is in pixels false, or relative to the screen size true.\n}}'}, result="Returns two ''x'', ''y'' [[float]]s indicating the screen position and [[float]] distance between screen and given position if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetScreenFromWorldPosition', name='getScreenFromWorldPosition', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getSunColor', return_types=['int,', 'int,', 'int,', 'int,', 'int,', 'int'], arguments=[]), docs=FunctionDoc(description='This function is used to get the color of the sun.', arguments={}, result='Returns the color of the sun as six numbers, false if its default.'), oop=None, url=FunctionUrl(url='/wiki/GetSunColor', name='getSunColor', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getSunColor', return_types=['int,', 'int,', 'int,', 'int,', 'int,', 'int'], arguments=[]), docs=FunctionDoc(description='This function is used to get the color of the sun.', arguments={}, result='Returns the color of the sun as six numbers, false if its default.'), oop=None, url=FunctionUrl(url='/wiki/GetSunColor', name='getSunColor', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getSunSize', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function is used to get the size of the sun.', arguments={}, result='Returns the size of the sun as a number, false if the size of the sun is at its default.'), oop=None, url=FunctionUrl(url='/wiki/GetSunSize', name='getSunSize', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getSunSize', return_types=['float'], arguments=[]), docs=FunctionDoc(description='This function is used to get the size of the sun.', arguments={}, result='Returns the size of the sun as a number, false if the size of the sun is at its default.'), oop=None, url=FunctionUrl(url='/wiki/GetSunSize', name='getSunSize', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getTime', return_types=['int', 'int'], arguments=[]), docs=FunctionDoc(description='This function is used to get the current time in the game. If you want to get the real server time, use [[getRealTime]].', arguments={}, result="Returns two ''ints'' that represent hours and minutes."), oop=None, url=FunctionUrl(url='/wiki/GetTime', name='getTime', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getTime', return_types=['int', 'int'], arguments=[]), docs=FunctionDoc(description='This function is used to get the current time in the game. If you want to get the real server time, use [[getRealTime]].', arguments={}, result="Returns two ''ints'' that represent hours and minutes."), oop=None, url=FunctionUrl(url='/wiki/GetTime', name='getTime', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getTrafficLightState', return_types=['int'], arguments=[]), docs=FunctionDoc(description="Gets the current traffic light state. This state controls the traffic light colors. For instance, state '''1''' will cause the north and south traffic lights to be amber, and the ones left and east will turn red.", arguments={}, result='Returns the current [[Traffic_light_states|state]] of the traffic lights.'), oop=None, url=FunctionUrl(url='/wiki/GetTrafficLightState', name='getTrafficLightState', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getTrafficLightState', return_types=['int'], arguments=[]), docs=FunctionDoc(description="Gets the current traffic light state. This state controls the traffic light colors. For instance, state '''1''' will cause the north and south traffic lights to be amber, and the ones left and east will turn red.", arguments={}, result='Returns the current [[Traffic_light_states|state]] of the traffic lights.'), oop=None, url=FunctionUrl(url='/wiki/GetTrafficLightState', name='getTrafficLightState', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getVehiclesLODDistance', return_types=['float,', 'float'], arguments=[]), docs=FunctionDoc(description='Returns the distance of vehicles LOD.\n}}', arguments={}, result=''), oop=None, url=FunctionUrl(url='/wiki/GetVehiclesLODDistance', name='getVehiclesLODDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getWeather', return_types=['int,', 'int'], arguments=[]), docs=FunctionDoc(description='This function returns the current [[Weather]] ID.', arguments={}, result="Returns two integers indicating the weather type that is currently active. The first integer says what weather is currently considered to be active. The second integer is the weather id that is being blended into if any, otherwise it is ''nil''."), oop=None, url=FunctionUrl(url='/wiki/GetWeather', name='getWeather', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getWeather', return_types=['int,', 'int'], arguments=[]), docs=FunctionDoc(description='This function returns the current [[Weather]] ID.', arguments={}, result="Returns two integers indicating the weather type that is currently active. The first integer says what weather is currently considered to be active. The second integer is the weather id that is being blended into if any, otherwise it is ''nil''."), oop=None, url=FunctionUrl(url='/wiki/GetWeather', name='getWeather', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getWindVelocity', return_types=['int,', 'int,', 'int'], arguments=[]), docs=FunctionDoc(description='This function gets the wind velocity in San Andreas.', arguments={}, result="*'''velocityX''': The velocity on the x-coordinate or false if the wind velocity is default.\n*'''velocityY''': The velocity on the y-coordinate or nil if the wind velocity is default.\n*'''velocityZ''': The velocity on the z-coordinate or nil if the wind velocity is default."), oop=None, url=FunctionUrl(url='/wiki/GetWindVelocity', name='getWindVelocity', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getWindVelocity', return_types=['int,', 'int,', 'int'], arguments=[]), docs=FunctionDoc(description='This function gets the wind velocity in San Andreas.', arguments={}, result="*'''velocityX''': The velocity on the x-coordinate or false if the wind velocity is default.\n*'''velocityY''': The velocity on the y-coordinate or nil if the wind velocity is default.\n*'''velocityZ''': The velocity on the z-coordinate or nil if the wind velocity is default."), oop=None, url=FunctionUrl(url='/wiki/GetWindVelocity', name='getWindVelocity', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='getWorldFromScreenPosition', return_types=['float,', 'float,', 'float'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='depth', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to retrieve the world position corresponding to a 2D position on the screen, at a certain depth.\nIf you want to detect what element is at a particular point on the screen, use [[processLineOfSight]] between the camera position and the position returned from this function when passed a high depth value (100 or so, depending how far away you want to detect elements at).\nAs expected, setting 0 as the distance will cause the point retrived to be within the camera itself. That means that drawing any 3D thing in that point would result in it not being visible. Depending on the camera near clip distance, however, the minimum distance to be able to view it can vary.', arguments={'x': 'A float value indicating the x position on the screen, in pixels.', 'y': 'A float value indicating the y position on the screen, in pixels.', 'depth': 'A float value indicating the distance from the camera of the point whose coordinates we are retrieving, in units.'}, result="Returns three ''x'', ''y'', ''z'' [[float]]s indicating the world position if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/GetWorldFromScreenPosition', name='getWorldFromScreenPosition', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='getZoneName', return_types=['string'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='citiesonly', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='This function allows you to retrieve the zone name of a certain location.\n ', arguments={'x': 'The X axis position', 'y': 'The Y axis position', 'z': 'The Z axis position\n{{OptionalArg}}', 'citiesonly': ': An optional argument to choose if you want to return one of the following city names:\n** Tierra Robada\n** Bone County\n** Las Venturas\n** San Fierro\n** Red County\n** Whetstone\n** Flint County\n** Los Santos'}, result='Returns the string of the zone name'), oop=None, url=FunctionUrl(url='/wiki/GetZoneName', name='getZoneName', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='getZoneName', return_types=['string'], arguments=[FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='citiesonly', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='This function allows you to retrieve the zone name of a certain location.\n ', arguments={'x': 'The X axis position', 'y': 'The Y axis position', 'z': 'The Z axis position\n{{OptionalArg}}', 'citiesonly': ': An optional argument to choose if you want to return one of the following city names:\n** Tierra Robada\n** Bone County\n** Las Venturas\n** San Fierro\n** Red County\n** Whetstone\n** Flint County\n** Los Santos'}, result='Returns the string of the zone name'), oop=None, url=FunctionUrl(url='/wiki/GetZoneName', name='getZoneName', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isAmbientSoundEnabled', return_types=['bool'], arguments=[FunctionArgument(name='theType', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to check if some background sound effects are enabled.', arguments={'theType': 'The type of ambient sound to test. Can be either gunfire or general.'}, result="Returns ''true'' if the ambient sound is enabled, ''false'' if it is disabled or invalid values were passed."), oop=None, url=FunctionUrl(url='/wiki/IsAmbientSoundEnabled', name='isAmbientSoundEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='isGarageOpen', return_types=['bool'], arguments=[FunctionArgument(name='garageID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks whether or not a specific garage door is open.', arguments={'garageID': 'The Garage|garage ID that represents the garage door that is being checked.'}, result="Returns ''true'' if the garage is open, ''false'' if it is closed or an invalid garage ID was given."), oop=None, url=FunctionUrl(url='/wiki/IsGarageOpen', name='isGarageOpen', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='isGarageOpen', return_types=['bool'], arguments=[FunctionArgument(name='garageID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks whether or not a specific garage door is open.', arguments={'garageID': 'The Garage|garage ID that represents the garage door that is being checked.'}, result="Returns ''true'' if the garage is open, ''false'' if it is closed or an invalid garage ID was given."), oop=None, url=FunctionUrl(url='/wiki/IsGarageOpen', name='isGarageOpen', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isLineOfSightClear', return_types=['bool'], arguments=[FunctionArgument(name='startX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='checkBuildings', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='checkVehicles', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='checkPeds', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='checkObjects', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='checkDummies', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='seeThroughStuff', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='ignoreSomeObjectsForCamera', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='ignoredElement', argument_type='element', default_value='nil', optional=False)]), docs=FunctionDoc(description='This function checks if there are obstacles between two points of the game world, optionally ignoring certain kinds of elements. Use [[processLineOfSight]] if you want more information about what the ray hits.', arguments={'startX': 'The first points world X coordinate.', 'startY': 'The first points world Y coordinate.', 'startZ': 'The first points world Z coordinate.', 'endX': 'The second points world X coordinate.', 'endY': 'The second points world Y coordinate.', 'endZ': 'The second points world Z coordinate.\n{{OptionalArg}} ', 'checkBuildings': 'Allow the line of sight to be blocked by GTAs internally placed buildings, i.e. the world map.', 'checkVehicles': 'Allow the line of sight to be blocked by Vehicle|vehicles.', 'checkPeds': 'Allow the line of sight to be blocked by peds, i.e. Player|players.', 'checkObjects': 'Allow the line of sight to be blocked by Object|objects.', 'checkDummies': 'Allow the line of sight to be blocked by GTAs internal dummies.  These are not used in the current MTA version so this argument can be set to false.', 'seeThroughStuff': 'Allow the line of sight to pass through collision materials that have this flag enabled (By default material IDs 52, 55 and 66 which are some fences). This flag originally allows some objects to be walked on but you can shoot throug them.', 'ignoreSomeObjectsForCamera': 'Allow the line of sight to pass through objects that have (K) property enabled in object.dat data file. (i.e. Most dynamic objects like boxes or barrels)', 'ignoredElement': 'Allow the line of sight to pass through a certain specified element.'}, result="Returns ''true'' if the line between the specified points is clear, ''false'' if there's an obstacle or if invalid parameters are passed."), oop=None, url=FunctionUrl(url='/wiki/IsLineOfSightClear', name='isLineOfSightClear', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isWorldSoundEnabled', return_types=['bool'], arguments=[FunctionArgument(name='group', argument_type='int', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value='-1', optional=False)]), docs=FunctionDoc(description='This function allows you to check if certain world sound effects have not been disabled by [[setWorldSoundEnabled]]\n}}', arguments={'group ': 'An integer representing the World sound groups|world sound group', 'index ': 'An integer representing an individual sound within the group'}, result="Returns ''true'' if the world sounds are enabled, ''false'' if they are disabled or invalid values were passed."), oop=None, url=FunctionUrl(url='/wiki/IsWorldSoundEnabled', name='isWorldSoundEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='isWorldSpecialPropertyEnabled', return_types=['bool'], arguments=[FunctionArgument(name='propname', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Checks if a special world property (cheat) is enabled or not.', arguments={'propname': 'the name of the property to retrieve. Possible values are listed on SetWorldSpecialPropertyEnabled.'}, result="Returns ''true'' if the property is enabled, ''false'' if it is disabled or the specified property name is invalid."), oop=None, url=FunctionUrl(url='/wiki/IsWorldSpecialPropertyEnabled', name='isWorldSpecialPropertyEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='processLineOfSight', return_types=['bool', '--', 'hit\nfloat', 'float', 'float', '--', 'hitX,', 'hitY,', 'hitZ\nelement', '--', 'hitElement\nfloat', 'float', 'float', '--', 'normalX,', 'normalY,', 'normalZ\nint', '--', 'material\nfloat', '--', 'lighting\nint', '--', 'piece\nint', '--', 'worldModelID\nfloat', 'float', 'float', '--', 'worldModelPositionX,Y,Z\nfloat', 'float', 'float', '--', 'worldModelRotationX,Y,Z\nint', '--', 'worldLODModelID'], arguments=[FunctionArgument(name='startX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='checkBuildings', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='checkVehicles', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='checkPlayers', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='checkObjects', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='checkDummies', argument_type='bool', default_value='true', optional=False), FunctionArgument(name='seeThroughStuff', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='ignoreSomeObjectsForCamera', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='shootThroughStuff', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='ignoredElement', argument_type='element', default_value='nil', optional=False), FunctionArgument(name='includeWorldModelInformation', argument_type='bool', default_value='false', optional=False), FunctionArgument(name='bIncludeCarTyres', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="This function casts a ray between two points in the world, and tells you information about the point that was hit, if any. The two positions '''must''' be within the local player's draw distance as the collision data is not loaded outside this area, and the call will just fail as if the ray didn't hit.\nThis function is relatively expensive to call, so over use of this in scripts may have a detrimental effect on performance.\nThis function is useful for checking for collisions and for editor-style scripts. If you wish to find what element is positioned at a particular point on the screen, use this function combined with [[getWorldFromScreenPosition]]. If you wish to just know if something is hit, and don't care about what or where was hit, use [[isLineOfSightClear]].", arguments={'startX': 'The start x position', 'startY': 'The start y position', 'startZ': 'The start z position', 'endX': 'The end x position', 'endY': 'The end y position', 'endZ': 'The end z position\n{{OptionalArg}} ', 'checkBuildings': 'Allow the line of sight to be blocked by GTAs internally placed buildings, i.e. the world map.', 'checkVehicles': 'Allow the line of sight to be blocked by Vehicle|vehicles.', 'checkPlayers': 'Allow the line of sight to be blocked by Player|players.', 'checkObjects': 'Allow the line of sight to be blocked by Object|objects.', 'checkDummies': 'Allow the line of sight to be blocked by GTAs internal dummies.  These are not used in the current MTA version so this argument can be set to false.', 'seeThroughStuff': 'Allow the line of sight pass through collision materials that have this flag enabled (By default material IDs 52, 55 and 66 which are some fences that you can shoot throug but still walk on them).', 'ignoreSomeObjectsForCamera': 'Allow the line of sight to pass through objects that have (K) property enabled in object.dat data file. (i.e. Most dynamic objects like boxes or barrels)', 'shootThroughStuff': 'Allow the line of sight to pass through collision materials that have this flag enabled (By default material IDs 28, 29, 31, 32, 33, 74, 75, 76, 77, 78, 79, 96, 97, 98, 99, 100 which are exclusively sand / beach or underwater objects).', 'ignoredElement': 'Allow the line of sight to pass through a certain specified element. This is usually set to the object you are tracing from so it does not interfere with the results.', 'includeWorldModelInformation ': 'Include the results of hitting a world model.', 'bIncludeCarTyres ': 'Includes car tyre hits.'}, result="*'''hit:''' ''true'' if there is a collision, ''false'' otherwise\nThe other values are only filled if there is a collision, they contain ''nil'' otherwise\n*'''hitX, hitY, hitZ:''' collision position\n*'''hitElement:''' the MTA element hit if any, ''nil'' otherwise\n*'''normalX, normalY, normalZ:''' the normal of the surface hit\n*'''material:''' an integer representing the [[Material IDs|GTASA material ID]] of the surface hit when applicable (world, objects)\n*'''lighting:''' a float between 0 (fully dark) and 1 (bright) representing the amount of light that the hit building surface will transfer to peds or vehicles that are in contact with it. The value can be affected by the game time of day, usually with a lower (darker) value being returned during the night.\n*'''piece:''' an integer representing the part of the element hit if hitElement is a vehicle or a ped/player, ''0'' otherwise. \n**For a ped/player, piece represents the body part hit:\n{{BodyParts}}\n**For vehicles, piece represents the vehicle part hit:\n{{VehicleParts}}\n*'''worldModelID:''' If includeWorldModelInformation was set to ''true'' and a world model was hit, this will contain the model ID.\n*'''worldModelPositionX,Y,Z:''' If worldModelID is set, this will contain the world model position.\n*'''worldModelRotationX,Y,Z:''' If worldModelID is set, this will contain the world model rotation.\n*'''worldLODModelID:''' If worldModelID is set, this will contain the LOD model ID if applicable."), oop=None, url=FunctionUrl(url='/wiki/ProcessLineOfSight', name='processLineOfSight', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='removeWorldModel', return_types=['bool'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='radius', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='interior', argument_type='int', default_value='-1', optional=True)]), docs=FunctionDoc(description='<!--\n-->\nThis function is used to remove a world object.\n<!--\n-->', arguments={'modelID': 'A whole integer specifying the GTASA object model ID.', 'radius': 'A floating point number representing the radius that will be eliminated.', 'x': 'A floating point number representing the X coordinate on the map.', 'y': 'A floating point number representing the Y coordinate on the map.', 'z': 'A floating point number representing the Z coordinate on the map.\n{{New items|3.0132|1.3.2|', 'interior': 'The interior ID to apply the removal to. Some objects in interior 13 show in all interiors so if you want to remove everything in interior 0 also remove everything in interior 13. A value of -1 here will affect all interiors.}}'}, result="Returns ''true'' if the [[object]] was removed, ''false'' if invalid arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/RemoveWorldModel', name='removeWorldModel', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='removeWorldModel', return_types=['bool'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='radius', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='interior', argument_type='int', default_value='-1', optional=True)]), docs=FunctionDoc(description='<!--\n-->\nThis function is used to remove a world object.\n<!--\n-->', arguments={'modelID': 'A whole integer specifying the GTASA object model ID.', 'radius': 'A floating point number representing the radius that will be eliminated.', 'x': 'A floating point number representing the X coordinate on the map.', 'y': 'A floating point number representing the Y coordinate on the map.', 'z': 'A floating point number representing the Z coordinate on the map.\n{{New items|3.0132|1.3.2|', 'interior': 'The interior ID to apply the removal to. Some objects in interior 13 show in all interiors so if you want to remove everything in interior 0 also remove everything in interior 13. A value of -1 here will affect all interiors.}}'}, result="Returns ''true'' if the [[object]] was removed, ''false'' if invalid arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/RemoveWorldModel', name='removeWorldModel', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='resetAmbientSounds', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function is used to reset the background sounds to the default setting.', arguments={}, result='Returns true if the ambient sounds were reset, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/ResetAmbientSounds', name='resetAmbientSounds', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='resetBlurLevel', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='Resets the motion blur level on the clients screen to default value (36).', arguments={}, result="Returns ''true'' if the blur level was reset successfully. Returns ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetBlurLevel', name='resetBlurLevel', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetFarClipDistance', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function resets the far clip distance to its default state.', arguments={}, result="Returns ''true'' if operation was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetFarClipDistance', name='resetFarClipDistance', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='resetFarClipDistance', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function resets the far clip distance to its default state.', arguments={}, result="Returns ''true'' if operation was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetFarClipDistance', name='resetFarClipDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetFogDistance', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function resets the fog render distance to its default state.', arguments={}, result="Returns ''true'' if operation was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetFogDistance', name='resetFogDistance', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='resetFogDistance', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function resets the fog render distance to its default state.', arguments={}, result="Returns ''true'' if operation was successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetFogDistance', name='resetFogDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetHeatHaze', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function restores the default heat haze.', arguments={}, result="Returns ''true'' if the heat haze was reset correctly, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetHeatHaze', name='resetHeatHaze', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='resetHeatHaze', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function restores the default heat haze.', arguments={}, result="Returns ''true'' if the heat haze was reset correctly, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetHeatHaze', name='resetHeatHaze', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetMoonSize', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function is used to reset the size of the moon to its normal size.\n}}', arguments={}, result='Returns true if the size of the moon was reset, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/ResetMoonSize', name='resetMoonSize', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='resetMoonSize', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function is used to reset the size of the moon to its normal size.\n}}', arguments={}, result='Returns true if the size of the moon was reset, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/ResetMoonSize', name='resetMoonSize', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetRainLevel', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function resets the rain level of the current weather to its default.', arguments={}, result='Returns true if the rain level was reset.'), oop=None, url=FunctionUrl(url='/wiki/ResetRainLevel', name='resetRainLevel', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='resetRainLevel', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function resets the rain level of the current weather to its default.', arguments={}, result='Returns true if the rain level was reset.'), oop=None, url=FunctionUrl(url='/wiki/ResetRainLevel', name='resetRainLevel', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetSkyGradient', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function allows restoring of a changed sky gradient as a result of [[setSkyGradient]].', arguments={}, result="Returns ''true'' if sky color was reset correctly, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetSkyGradient', name='resetSkyGradient', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='resetSkyGradient', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function allows restoring of a changed sky gradient as a result of [[setSkyGradient]].', arguments={}, result="Returns ''true'' if sky color was reset correctly, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/ResetSkyGradient', name='resetSkyGradient', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetSunColor', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function is used to reset the color of the sun to its normal color.', arguments={}, result='Returns true if the color of the sun was reset, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/ResetSunColor', name='resetSunColor', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='resetSunColor', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function is used to reset the color of the sun to its normal color.', arguments={}, result='Returns true if the color of the sun was reset, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/ResetSunColor', name='resetSunColor', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetSunSize', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function is used to reset the size of the sun to its normal size.', arguments={}, result='Returns true if the size of the sun was reset, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/ResetSunSize', name='resetSunSize', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='resetSunSize', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function is used to reset the size of the sun to its normal size.', arguments={}, result='Returns true if the size of the sun was reset, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/ResetSunSize', name='resetSunSize', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='resetVehiclesLODDistance', return_types=['bool'], arguments=[]), docs=FunctionDoc(description="Resets the distance of vehicles LOD to default. Default values depends on client setting. If client has enabled ''high detail vehicles'' in video options, value will be reset to (500, 500) - otherwise to (70, 150). You can check value of this option using [[dxGetStatus]] (''SettingHighDetailVehicles'').\n}}", arguments={}, result='Returns true if the vehicles LOD distance was reset, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/ResetVehiclesLODDistance', name='resetVehiclesLODDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='resetWindVelocity', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function resets the wind velocity in San Andreas to its default state.', arguments={}, result='Returns true if successful, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/ResetWindVelocity', name='resetWindVelocity', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='resetWindVelocity', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function resets the wind velocity in San Andreas to its default state.', arguments={}, result='Returns true if successful, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/ResetWindVelocity', name='resetWindVelocity', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='resetWorldSounds', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function is used to reset the world sounds to the default setting.\n}}', arguments={}, result='Returns true if the world sounds were reset, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/ResetWorldSounds', name='resetWorldSounds', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='resetColorFilter', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='', arguments={}, result='Returns true if the color filtering was reset, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/ResetColorFilter', name='resetColorFilter', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='restoreAllWorldModels', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function allows restoring of all world objects,which were removed with [[RemoveWorldModel]].', arguments={}, result="Returns ''true'' if the world objects were restored, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/RestoreAllWorldModels', name='restoreAllWorldModels', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='restoreAllWorldModels', return_types=['bool'], arguments=[]), docs=FunctionDoc(description='This function allows restoring of all world objects,which were removed with [[RemoveWorldModel]].', arguments={}, result="Returns ''true'' if the world objects were restored, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/RestoreAllWorldModels', name='restoreAllWorldModels', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='restoreWorldModel', return_types=['bool'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='radius', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='iInterior', argument_type='int', default_value='-1', optional=True)]), docs=FunctionDoc(description='This function allows restoring of world object,which was removed with [[RemoveWorldModel]].', arguments={'modelID': 'A whole integer specifying the GTASA object model ID.', 'radius': 'A floating point number representing the radius that will be eliminated.', 'x': 'A floating point number representing the X coordinate on the map.', 'y': 'A floating point number representing the Y coordinate on the map.', 'z': 'A floating point number representing the Z coordinate on the map.\n{{New items|3.0132|1.3.2|', 'iInterior': '\n}}'}, result="Returns ''true'' if the world object was restored, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/RestoreWorldModel', name='restoreWorldModel', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='restoreWorldModel', return_types=['bool'], arguments=[FunctionArgument(name='modelID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='radius', argument_type='float', default_value=None, optional=False), FunctionArgument(name='x', argument_type='float', default_value=None, optional=False), FunctionArgument(name='y', argument_type='float', default_value=None, optional=False), FunctionArgument(name='z', argument_type='float', default_value=None, optional=False), FunctionArgument(name='iInterior', argument_type='int', default_value='-1', optional=True)]), docs=FunctionDoc(description='This function allows restoring of world object,which was removed with [[RemoveWorldModel]].', arguments={'modelID': 'A whole integer specifying the GTASA object model ID.', 'radius': 'A floating point number representing the radius that will be eliminated.', 'x': 'A floating point number representing the X coordinate on the map.', 'y': 'A floating point number representing the Y coordinate on the map.', 'z': 'A floating point number representing the Z coordinate on the map.\n{{New items|3.0132|1.3.2|', 'iInterior': '\n}}'}, result="Returns ''true'' if the world object was restored, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/RestoreWorldModel', name='restoreWorldModel', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setAircraftMaxHeight', return_types=['bool'], arguments=[FunctionArgument(name='Height', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the maximum flying height of aircraft.', arguments={'Height': 'The height you want aircraft to be able to go.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetAircraftMaxHeight', name='setAircraftMaxHeight', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setAircraftMaxHeight', return_types=['bool'], arguments=[FunctionArgument(name='Height', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the maximum flying height of aircraft.', arguments={'Height': 'The height you want aircraft to be able to go.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetAircraftMaxHeight', name='setAircraftMaxHeight', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setAircraftMaxVelocity', return_types=['bool'], arguments=[FunctionArgument(name='velocity', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the maximum velocity at which aircrafts could fly. Using this function server-side will overwrite the value that was previously set client-side.\n}}', arguments={'velocity': 'The max velocity, can be 0 or any positive value. Default is 1.5.'}, result='Returns true if the max velocity was set correctly, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/SetAircraftMaxVelocity', name='setAircraftMaxVelocity', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setAircraftMaxVelocity', return_types=['bool'], arguments=[FunctionArgument(name='velocity', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the maximum velocity at which aircrafts could fly. Using this function server-side will overwrite the value that was previously set client-side.\n}}', arguments={'velocity': 'The max velocity, can be 0 or any positive value. Default is 1.5.'}, result='Returns true if the max velocity was set correctly, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/SetAircraftMaxVelocity', name='setAircraftMaxVelocity', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setAmbientSoundEnabled', return_types=['bool'], arguments=[FunctionArgument(name='theType', argument_type='string', default_value=None, optional=False), FunctionArgument(name='enable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to disable some background sound effects. See also: [[setWorldSoundEnabled]].', arguments={'theType': 'The type of ambient sound to toggle. Can be either gunfire or general.', 'enable ': 'Set false to turn off, true to turn on'}, result="Returns ''true'' if the ambient sound was set correctly, ''false'' if invalid values were passed."), oop=None, url=FunctionUrl(url='/wiki/SetAmbientSoundEnabled', name='setAmbientSoundEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setBirdsEnabled', return_types=['bool'], arguments=[FunctionArgument(name='enable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function allows you to disable the flying birds.', arguments={'enabled': 'A boolean value determining if birds should be shown. Use true to show the birds and false to hide them.'}, result="Returns ''true'' if the birds state was changed succesfully, ''false'' if an invalid argument was specified."), oop=None, url=FunctionUrl(url='/wiki/SetBirdsEnabled', name='setBirdsEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setCloudsEnabled', return_types=['bool'], arguments=[FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will enable or disable clouds. This is useful for race maps which are placed high up as clouds can cause low FPS.', arguments={'enabled': 'A boolean value determining if clouds should be shown. Use true to show clouds and false to hide them.'}, result="Returns ''true'' if the cloud state was changed succesfully, ''false'' if an invalid argument was specified."), oop=None, url=FunctionUrl(url='/wiki/SetCloudsEnabled', name='setCloudsEnabled', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setCloudsEnabled', return_types=['bool'], arguments=[FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will enable or disable clouds. This is useful for race maps which are placed high up as clouds can cause low FPS.', arguments={'enabled': 'A boolean value determining if clouds should be shown. Use true to show clouds and false to hide them.'}, result="Returns ''true'' if the cloud state was changed succesfully, ''false'' if an invalid argument was specified."), oop=None, url=FunctionUrl(url='/wiki/SetCloudsEnabled', name='setCloudsEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setFarClipDistance', return_types=['bool'], arguments=[FunctionArgument(name='distance', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the distance of render. Areas beyond the specified distance will not be rendered.', arguments={'distance': 'A float specifying the distance of render. Setting this less than 5 will cause problems to the client.'}, result="Returns ''true'' if the distance was set correctly, ''false'' if invalid arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/SetFarClipDistance', name='setFarClipDistance', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setFarClipDistance', return_types=['bool'], arguments=[FunctionArgument(name='distance', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the distance of render. Areas beyond the specified distance will not be rendered.', arguments={'distance': 'A float specifying the distance of render. Setting this less than 5 will cause problems to the client.'}, result="Returns ''true'' if the distance was set correctly, ''false'' if invalid arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/SetFarClipDistance', name='setFarClipDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setFogDistance', return_types=['bool'], arguments=[FunctionArgument(name='distance', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function changes the distance at which fog appears. Keep in mind that this function doesn't change the distance of render.", arguments={'distance': 'distance in GTA units at which fog will appear. Very short or negative distances will cause graphical bugs to the players.'}, result="Returns ''true'' if the distance changed successfully, ''false'' if bad arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/SetFogDistance', name='setFogDistance', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setFogDistance', return_types=['bool'], arguments=[FunctionArgument(name='distance', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function changes the distance at which fog appears. Keep in mind that this function doesn't change the distance of render.", arguments={'distance': 'distance in GTA units at which fog will appear. Very short or negative distances will cause graphical bugs to the players.'}, result="Returns ''true'' if the distance changed successfully, ''false'' if bad arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/SetFogDistance', name='setFogDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setGameSpeed', return_types=['bool'], arguments=[FunctionArgument(name='value', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the game speed to the given value.', arguments={'value': ': The float value of the game speed (Range 0 - 10)'}, result="Returns ''true'' if the gamespeed was set successfully, ''false'' otherwise.\nThe normal game speed is '1'."), oop=None, url=FunctionUrl(url='/wiki/SetGameSpeed', name='setGameSpeed', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setGameSpeed', return_types=['bool'], arguments=[FunctionArgument(name='value', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the game speed to the given value.', arguments={'value': ': The float value of the game speed (Range 0 - 10)'}, result="Returns ''true'' if the gamespeed was set successfully, ''false'' otherwise.\nThe normal game speed is '1'."), oop=None, url=FunctionUrl(url='/wiki/SetGameSpeed', name='setGameSpeed', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setGarageOpen', return_types=['bool'], arguments=[FunctionArgument(name='garageID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='open', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function opens or closes the specified garage door in the world.', arguments={'garageID': 'The Garage|garage ID that represents the garage door being opened or closed.', 'isOpen': 'A boolean indicating whether or not to open the door.'}, result="Returns ''true'' if successful, ''false'' if an invalid garage id was given."), oop=None, url=FunctionUrl(url='/wiki/SetGarageOpen', name='setGarageOpen', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setGarageOpen', return_types=['bool'], arguments=[FunctionArgument(name='garageID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='open', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function opens or closes the specified garage door in the world.', arguments={'garageID': 'The Garage|garage ID that represents the garage door being opened or closed.', 'isOpen': 'A boolean indicating whether or not to open the door.'}, result="Returns ''true'' if successful, ''false'' if an invalid garage id was given."), oop=None, url=FunctionUrl(url='/wiki/SetGarageOpen', name='setGarageOpen', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setGravity', return_types=['bool'], arguments=[FunctionArgument(name='level', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the server's gravity level.\n*This will override [[setPedGravity]] applied to peds/players.\n*Setting the gravity level to different values on clients can cause animation bugs (players floating across ground because players see different fall animation.)}}", arguments={'level': ': The level of gravity (default is 0.008).'}, result="Returns ''true'' if gravity was changed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetGravity', name='setGravity', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setGravity', return_types=['bool'], arguments=[FunctionArgument(name='level', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description="This function sets the server's gravity level.\n*This will override [[setPedGravity]] applied to peds/players.\n*Setting the gravity level to different values on clients can cause animation bugs (players floating across ground because players see different fall animation.)}}", arguments={'level': ': The level of gravity (default is 0.008).'}, result="Returns ''true'' if gravity was changed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetGravity', name='setGravity', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setHeatHaze', return_types=['bool'], arguments=[FunctionArgument(name='intensity', argument_type='int', default_value=None, optional=False), FunctionArgument(name='randomShift', argument_type='int', default_value='0', optional=False), FunctionArgument(name='speedMin', argument_type='int', default_value='12', optional=False), FunctionArgument(name='speedMax', argument_type='int', default_value='18', optional=False), FunctionArgument(name='scanSizeX', argument_type='int', default_value='75', optional=False), FunctionArgument(name='scanSizeY', argument_type='int', default_value='80', optional=False), FunctionArgument(name='renderSizeX', argument_type='int', default_value='80', optional=False), FunctionArgument(name='renderSizeY', argument_type='int', default_value='85', optional=False), FunctionArgument(name='bShowInside', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='This function changes the heat haze effect.', arguments={}, result="Returns ''true'' if the heat haze effect was set correctly, ''false'' if invalid values were passed."), oop=None, url=FunctionUrl(url='/wiki/SetHeatHaze', name='setHeatHaze', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setHeatHaze', return_types=['bool'], arguments=[FunctionArgument(name='intensity', argument_type='int', default_value=None, optional=False), FunctionArgument(name='randomShift', argument_type='int', default_value='0', optional=False), FunctionArgument(name='speedMin', argument_type='int', default_value='12', optional=False), FunctionArgument(name='speedMax', argument_type='int', default_value='18', optional=False), FunctionArgument(name='scanSizeX', argument_type='int', default_value='75', optional=False), FunctionArgument(name='scanSizeY', argument_type='int', default_value='80', optional=False), FunctionArgument(name='renderSizeX', argument_type='int', default_value='80', optional=False), FunctionArgument(name='renderSizeY', argument_type='int', default_value='85', optional=False), FunctionArgument(name='bShowInside', argument_type='bool', default_value='false', optional=False)]), docs=FunctionDoc(description='This function changes the heat haze effect.', arguments={}, result="Returns ''true'' if the heat haze effect was set correctly, ''false'' if invalid values were passed."), oop=None, url=FunctionUrl(url='/wiki/SetHeatHaze', name='setHeatHaze', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setInteriorFurnitureEnabled', return_types=['bool'], arguments=[FunctionArgument(name='roomID', argument_type='int', default_value=None, optional=False), FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function toggles furniture generation in interiors with the specified room ID.\n}}', arguments={'roomID': 'The room type which you want disable or enable the furniture in:', '0': ': shop', '1': ': office', '2': ': lounge', '3': ': bedroom', '4': ': kitchen', 'enabled': ': A bool representing whether the interior furniture is enabled or disabled.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetInteriorFurnitureEnabled', name='setInteriorFurnitureEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setInteriorSoundsEnabled', return_types=['bool'], arguments=[FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function disables or enables the ambient sounds played by GTA in most interiors, like restaurants, casinos, clubs, houses, etc.', arguments={}, result="If a boolean was passed to the function, it always succeeds and returns ''true''."), oop=None, url=FunctionUrl(url='/wiki/SetInteriorSoundsEnabled', name='setInteriorSoundsEnabled', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setInteriorSoundsEnabled', return_types=['bool'], arguments=[FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function disables or enables the ambient sounds played by GTA in most interiors, like restaurants, casinos, clubs, houses, etc.', arguments={}, result="If a boolean was passed to the function, it always succeeds and returns ''true''."), oop=None, url=FunctionUrl(url='/wiki/SetInteriorSoundsEnabled', name='setInteriorSoundsEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setJetpackMaxHeight', return_types=['bool'], arguments=[FunctionArgument(name='Height', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the maximum flying height of jetpack.', arguments={'Height': ': The max height starting at approximately -20.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetJetpackMaxHeight', name='setJetpackMaxHeight', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setJetpackMaxHeight', return_types=['bool'], arguments=[FunctionArgument(name='Height', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the maximum flying height of jetpack.', arguments={'Height': ': The max height starting at approximately -20.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetJetpackMaxHeight', name='setJetpackMaxHeight', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setMinuteDuration', return_types=['bool'], arguments=[FunctionArgument(name='milliseconds', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the real-world duration of an ingame minute. The GTA default is 1000.', arguments={'milliseconds': ': the new duration of an ingame minute, accepted values 0 - 2147483647.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetMinuteDuration', name='setMinuteDuration', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setMinuteDuration', return_types=['bool'], arguments=[FunctionArgument(name='milliseconds', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the real-world duration of an ingame minute. The GTA default is 1000.', arguments={'milliseconds': ': the new duration of an ingame minute, accepted values 0 - 2147483647.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetMinuteDuration', name='setMinuteDuration', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setMoonSize', return_types=['bool'], arguments=[FunctionArgument(name='size', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the moon size. Using this function server-side will overwrite the value that was previously set client-side.\n}}', arguments={'size': 'The size, can be 0 or any positive value. Default is 3.'}, result='Returns true if the moon size was set correctly, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/SetMoonSize', name='setMoonSize', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setMoonSize', return_types=['bool'], arguments=[FunctionArgument(name='size', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the moon size. Using this function server-side will overwrite the value that was previously set client-side.\n}}', arguments={'size': 'The size, can be 0 or any positive value. Default is 3.'}, result='Returns true if the moon size was set correctly, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/SetMoonSize', name='setMoonSize', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setNearClipDistance', return_types=['bool'], arguments=[FunctionArgument(name='distance', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'distance': 'the new near clip distance. It must be between 0.1 and 20 for the function to do any effect. Default value is 0.3.'}, result="This function returns ''true'' if the argument is valid. Returns ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetNearClipDistance', name='setNearClipDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setOcclusionsEnabled', return_types=['bool'], arguments=[FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to enable or disable occlusions. Occlusions are used by GTA to enhance performance by hiding objects that are (normally) obscured by certain large buildings. However when [[removeWorldModel]] is used they may also have the undesired effect of making parts of the map disappear. Disabling occlusions will fix that.', arguments={'enabled': 'A bool specifying if GTA occlusions should be enabled'}, result="Returns ''true'' if the setting was set correctly, ''false'' if invalid arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/SetOcclusionsEnabled', name='setOcclusionsEnabled', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setOcclusionsEnabled', return_types=['bool'], arguments=[FunctionArgument(name='enabled', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to enable or disable occlusions. Occlusions are used by GTA to enhance performance by hiding objects that are (normally) obscured by certain large buildings. However when [[removeWorldModel]] is used they may also have the undesired effect of making parts of the map disappear. Disabling occlusions will fix that.', arguments={'enabled': 'A bool specifying if GTA occlusions should be enabled'}, result="Returns ''true'' if the setting was set correctly, ''false'' if invalid arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/SetOcclusionsEnabled', name='setOcclusionsEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setPlayerBlurLevel', return_types=['bool'], arguments=[FunctionArgument(name='thePlayer', argument_type='player', default_value=None, optional=False), FunctionArgument(name='level', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the motion blur level on the clients screen. Accepts a value between 0 and 255.', arguments={'thePlayer': 'The player whose blur level will be changed.', 'level': 'The level to set the blur to (default: 36)'}, result=''), oop=FunctionOOP(class_name='player', method_name='setBlurLevel', field='blurLevel'), url=FunctionUrl(url='/wiki/SetPlayerBlurLevel', name='setPlayerBlurLevel', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setBlurLevel', return_types=['bool'], arguments=[FunctionArgument(name='level', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the motion blur level on the clients screen. Accepts a value between 0 and 255.', arguments={'level': 'The level to set the blur to (default: 36)'}, result=''), oop=FunctionOOP(class_name='Player', method_name='setBlurLevel', field=None), url=FunctionUrl(url='/wiki/SetPlayerBlurLevel', name='setPlayerBlurLevel', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setRainLevel', return_types=['bool'], arguments=[FunctionArgument(name='level', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the rain level to any weather available in GTA. Use [[resetRainLevel]] to undo the changes.', arguments={'level': 'A floating point number representing the rain level. 1 represents the maximum rain level usually available in GTA, but higher values are accepted.', 'Note': 'The level value is clamped between 0.0 and 10.0 to avoid gameplay issues.'}, result="Returns ''true'' if the rain level was set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetRainLevel', name='setRainLevel', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setRainLevel', return_types=['bool'], arguments=[FunctionArgument(name='level', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the rain level to any weather available in GTA. Use [[resetRainLevel]] to undo the changes.', arguments={'level': 'A floating point number representing the rain level. 1 represents the maximum rain level usually available in GTA, but higher values are accepted.', 'Note': 'The level value is clamped between 0.0 and 10.0 to avoid gameplay issues.'}, result="Returns ''true'' if the rain level was set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetRainLevel', name='setRainLevel', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setSkyGradient', return_types=['bool'], arguments=[FunctionArgument(name='topRed', argument_type='int', default_value='0', optional=False), FunctionArgument(name='topGreen', argument_type='int', default_value='0', optional=False), FunctionArgument(name='topBlue', argument_type='int', default_value='0', optional=False), FunctionArgument(name='bottomRed', argument_type='int', default_value='0', optional=False), FunctionArgument(name='bottomGreen', argument_type='int', default_value='0', optional=False), FunctionArgument(name='bottomBlue', argument_type='int', default_value='0', optional=False)]), docs=FunctionDoc(description='This function changes the sky color to a two-color gradient.', arguments={'topRed': 'The red value of the upper part of the sky, from 0 to 255.', 'topGreen': 'The green value of the upper part of the sky, from 0 to 255.', 'topBlue': 'The blue value of the upper part of the sky, from 0 to 255.', 'bottomRed': 'The red value of the lower part of the sky, from 0 to 255.', 'bottomGreen': 'The green value of the lower part of the sky, from 0 to 255.', 'bottomBlue': 'The blue value of the lower part of the sky, from 0 to 255.'}, result="Returns ''true'' if sky color was set correctly, ''false'' if invalid values were passed."), oop=None, url=FunctionUrl(url='/wiki/SetSkyGradient', name='setSkyGradient', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setSkyGradient', return_types=['bool'], arguments=[FunctionArgument(name='topRed', argument_type='int', default_value='0', optional=False), FunctionArgument(name='topGreen', argument_type='int', default_value='0', optional=False), FunctionArgument(name='topBlue', argument_type='int', default_value='0', optional=False), FunctionArgument(name='bottomRed', argument_type='int', default_value='0', optional=False), FunctionArgument(name='bottomGreen', argument_type='int', default_value='0', optional=False), FunctionArgument(name='bottomBlue', argument_type='int', default_value='0', optional=False)]), docs=FunctionDoc(description='This function changes the sky color to a two-color gradient.', arguments={'topRed': 'The red value of the upper part of the sky, from 0 to 255.', 'topGreen': 'The green value of the upper part of the sky, from 0 to 255.', 'topBlue': 'The blue value of the upper part of the sky, from 0 to 255.', 'bottomRed': 'The red value of the lower part of the sky, from 0 to 255.', 'bottomGreen': 'The green value of the lower part of the sky, from 0 to 255.', 'bottomBlue': 'The blue value of the lower part of the sky, from 0 to 255.'}, result="Returns ''true'' if sky color was set correctly, ''false'' if invalid values were passed."), oop=None, url=FunctionUrl(url='/wiki/SetSkyGradient', name='setSkyGradient', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setSunColor', return_types=['bool'], arguments=[FunctionArgument(name='aRed', argument_type='int', default_value=None, optional=False), FunctionArgument(name='aGreen', argument_type='int', default_value=None, optional=False), FunctionArgument(name='aBlue', argument_type='int', default_value=None, optional=False), FunctionArgument(name='bRed', argument_type='int', default_value=None, optional=False), FunctionArgument(name='bGreen', argument_type='int', default_value=None, optional=False), FunctionArgument(name='bBlue', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the color of the sun.', arguments={'aRed': 'The amount of red (0-255) you want the sun to be.', 'aGreen': 'The amount of green (0-255) you want the sun to be.', 'aBlue': 'The amount of blue (0-255) you want the sun to be.', 'bRed': 'The amount of red (0-255) you want the sun to be.', 'bGreen': 'The amount of green (0-255) you want the sun to be.', 'bBlue': 'The amount of blue (0-255) you want the sun to be.'}, result='Returns true if the color of the sun was set, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/SetSunColor', name='setSunColor', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setSunColor', return_types=['bool'], arguments=[FunctionArgument(name='aRed', argument_type='int', default_value=None, optional=False), FunctionArgument(name='aGreen', argument_type='int', default_value=None, optional=False), FunctionArgument(name='aBlue', argument_type='int', default_value=None, optional=False), FunctionArgument(name='bRed', argument_type='int', default_value=None, optional=False), FunctionArgument(name='bGreen', argument_type='int', default_value=None, optional=False), FunctionArgument(name='bBlue', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the color of the sun.', arguments={'aRed': 'The amount of red (0-255) you want the sun to be.', 'aGreen': 'The amount of green (0-255) you want the sun to be.', 'aBlue': 'The amount of blue (0-255) you want the sun to be.', 'bRed': 'The amount of red (0-255) you want the sun to be.', 'bGreen': 'The amount of green (0-255) you want the sun to be.', 'bBlue': 'The amount of blue (0-255) you want the sun to be.'}, result='Returns true if the color of the sun was set, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/SetSunColor', name='setSunColor', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setSunSize', return_types=['bool'], arguments=[FunctionArgument(name='Size', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the size of the sun.', arguments={'Size': 'The size you want the sun to be in the sky.'}, result='Returns true if the size of the sun was set, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/SetSunSize', name='setSunSize', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setSunSize', return_types=['bool'], arguments=[FunctionArgument(name='Size', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to set the size of the sun.', arguments={'Size': 'The size you want the sun to be in the sky.'}, result='Returns true if the size of the sun was set, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/SetSunSize', name='setSunSize', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setTime', return_types=['bool'], arguments=[FunctionArgument(name='hour', argument_type='int', default_value=None, optional=False), FunctionArgument(name='minute', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the current GTA time to the given time.', arguments={'hour': ': The hour of the new time (range 0-23).', 'minute': ': The minute of the new time (range 0-59).'}, result="Returns ''true'' if the new time was successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetTime', name='setTime', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setTime', return_types=['bool'], arguments=[FunctionArgument(name='hour', argument_type='int', default_value=None, optional=False), FunctionArgument(name='minute', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the current GTA time to the given time.', arguments={'hour': ': The hour of the new time (range 0-23).', 'minute': ': The minute of the new time (range 0-59).'}, result="Returns ''true'' if the new time was successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetTime', name='setTime', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setTrafficLightState', return_types=['bool'], arguments=[FunctionArgument(name='state', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="Sets the current traffic light state. This state controls the traffic light colors. For instance, state '''1''' will cause the north and south traffic lights to be amber, and the ones left and east will turn red.", arguments={'state': ': If an integer is provided, the Traffic_light_states|state you wish to use (possible values: 0-9). Else, one of the following strings:', 'auto': ': Sets the traffic lights default behavior (switches the colors automatically).', 'disabled': ": Turns traffic lights off.\nAlternatively, you can provide two string parameters ('''colorNS''' and '''colorEW''') with the colors for north-south and east-west traffic lights respectively. Valid colors are:", 'green': '', 'yellow': '', 'red': ''}, result="Returns ''true'' if the state was successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetTrafficLightState', name='setTrafficLightState', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setTrafficLightState', return_types=['bool'], arguments=[FunctionArgument(name='state', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description="Sets the current traffic light state. This state controls the traffic light colors. For instance, state '''1''' will cause the north and south traffic lights to be amber, and the ones left and east will turn red.", arguments={'state': ': If an integer is provided, the Traffic_light_states|state you wish to use (possible values: 0-9). Else, one of the following strings:', 'auto': ': Sets the traffic lights default behavior (switches the colors automatically).', 'disabled': ": Turns traffic lights off.\nAlternatively, you can provide two string parameters ('''colorNS''' and '''colorEW''') with the colors for north-south and east-west traffic lights respectively. Valid colors are:", 'green': '', 'yellow': '', 'red': ''}, result="Returns ''true'' if the state was successfully set, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetTrafficLightState', name='setTrafficLightState', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setTrafficLightsLocked', return_types=['bool'], arguments=[FunctionArgument(name='toggle', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="Toggles whether you want the traffic lights to be locked. If the lights are locked, it means they won't change unless you do [[setTrafficLightState]].", arguments={'toggle': ': A bool indicating whether you want the traffic lights to change automatically, or not'}, result="Returns ''true'' if the successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetTrafficLightsLocked', name='setTrafficLightsLocked', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setTrafficLightsLocked', return_types=['bool'], arguments=[FunctionArgument(name='toggle', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description="Toggles whether you want the traffic lights to be locked. If the lights are locked, it means they won't change unless you do [[setTrafficLightState]].", arguments={'toggle': ': A bool indicating whether you want the traffic lights to change automatically, or not'}, result="Returns ''true'' if the successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetTrafficLightsLocked', name='setTrafficLightsLocked', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setVehiclesLODDistance', return_types=['bool'], arguments=[FunctionArgument(name='vehiclesDistance', argument_type='float', default_value=None, optional=False), FunctionArgument(name='trainsAndPlanesDistance', argument_type='float', default_value='vehiclesDistance * 2.14', optional=False)]), docs=FunctionDoc(description='Sets the distance of vehicles LOD.\n}}', arguments={'vehiclesDistance': 'general distance used for most vehicles, this value is clamped to 0 – 500', 'trainsAndPlanesDistance': 'distance used for trains and planes, this value is clamped to 0 – 500'}, result=''), oop=None, url=FunctionUrl(url='/wiki/SetVehiclesLODDistance', name='setVehiclesLODDistance', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setWeather', return_types=['bool'], arguments=[FunctionArgument(name='weatherID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the current [[weather]] to the given valid value. To change the weather gradually, see [[setWeatherBlended]].', arguments={'weatherID': ': The ID of new weather. Valid values are 0 to 255 inclusive.'}, result="Returns ''true'' if the weather was set succesfully, ''false'' if an invalid ''weatherID'' was specified."), oop=None, url=FunctionUrl(url='/wiki/SetWeather', name='setWeather', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setWeather', return_types=['bool'], arguments=[FunctionArgument(name='weatherID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function sets the current [[weather]] to the given valid value. To change the weather gradually, see [[setWeatherBlended]].', arguments={'weatherID': ': The ID of new weather. Valid values are 0 to 255 inclusive.'}, result="Returns ''true'' if the weather was set succesfully, ''false'' if an invalid ''weatherID'' was specified."), oop=None, url=FunctionUrl(url='/wiki/SetWeather', name='setWeather', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setWeatherBlended', return_types=['bool'], arguments=[FunctionArgument(name='weatherID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will change the current [[weather]] to another in a smooth manner, over the period of 1-2 in-game hours (unlike [[setWeather]], which sets a new weather instantly). To ensure this transition performs as expected, you should not call this function until [[getWeather]] indicates that no transition is already being done.', arguments={'weatherID': 'The ID of the weather state you wish to set. Valid values are 0 to 255 inclusive.'}, result="Returns ''true'' if successful, ''false'' if an invalid ''weatherID'' is passed."), oop=None, url=FunctionUrl(url='/wiki/SetWeatherBlended', name='setWeatherBlended', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setWeatherBlended', return_types=['bool'], arguments=[FunctionArgument(name='weatherID', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function will change the current [[weather]] to another in a smooth manner, over the period of 1-2 in-game hours (unlike [[setWeather]], which sets a new weather instantly). To ensure this transition performs as expected, you should not call this function until [[getWeather]] indicates that no transition is already being done.', arguments={'weatherID': 'The ID of the weather state you wish to set. Valid values are 0 to 255 inclusive.'}, result="Returns ''true'' if successful, ''false'' if an invalid ''weatherID'' is passed."), oop=None, url=FunctionUrl(url='/wiki/SetWeatherBlended', name='setWeatherBlended', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='setWindVelocity', return_types=['bool'], arguments=[FunctionArgument(name='velocityX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='velocityY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='velocityZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the wind velocity. The wind shakes the vegetation and makes particles fly in a direction. The intensity and direction of the effect deppends of the wind velocity in each axis.', arguments={'velocityX': ': The velocity of the wind along the x axis.', 'velocityY': ': The velocity of the wind along the y axis.', 'velocityZ': ': The velocity of the wind along the z axis.'}, result="Returns ''true'' if successful, ''false'' if bad arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/SetWindVelocity', name='setWindVelocity', category='World functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='setWindVelocity', return_types=['bool'], arguments=[FunctionArgument(name='velocityX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='velocityY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='velocityZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function changes the wind velocity. The wind shakes the vegetation and makes particles fly in a direction. The intensity and direction of the effect deppends of the wind velocity in each axis.', arguments={'velocityX': ': The velocity of the wind along the x axis.', 'velocityY': ': The velocity of the wind along the y axis.', 'velocityZ': ': The velocity of the wind along the z axis.'}, result="Returns ''true'' if successful, ''false'' if bad arguments were passed."), oop=None, url=FunctionUrl(url='/wiki/SetWindVelocity', name='setWindVelocity', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setWorldSoundEnabled', return_types=['bool'], arguments=[FunctionArgument(name='group', argument_type='int', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value='-1', optional=False), FunctionArgument(name='enable', argument_type='bool', default_value=None, optional=False), FunctionArgument(name='immediate', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description="This function allows you to disable world sounds. A world sound is a sound effect which has '''''not''''' been caused by [[playSound]] or [[playSound3D]].\n*The values for ''group'' and ''index'' can be determined by using the client command [[Client_Commands#showsound|showsound]] in conjunction with [[setDevelopmentMode]]\n*This function does not affect sounds which are already playing, such as the wind sound that can only be stopped by entering an interior.\n* See also: [[setAmbientSoundEnabled]]}}", arguments={'group': 'An int|integer representing the World sound groups|world sound group', 'enable': 'Set to false to disable, true to enable', 'index': 'An int|integer representing an individual sound within the group\n{{New feature/item|3.0156|1.5.5|11860|', 'immediate': 'A boolean if set to true will cancel the sound if its already playing. This parameter only works for stopping the sound.\n}}'}, result="Returns ''true'' if the world sound was correctly enabled/disabled, ''false'' if invalid values were passed."), oop=None, url=FunctionUrl(url='/wiki/SetWorldSoundEnabled', name='setWorldSoundEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setWorldSpecialPropertyEnabled', return_types=['bool'], arguments=[FunctionArgument(name='propname', argument_type='string', default_value=None, optional=False), FunctionArgument(name='enable', argument_type='bool', default_value=None, optional=False)]), docs=FunctionDoc(description='Enables or disables a special world property.', arguments={'propname': 'the name of the property to set. Possible values are:', 'hovercars': '- equivalent of the JBGVNB cheat, and allows cars to drive on water.', 'aircars': '- equivalent of the RIPAZHA cheat, and allows cars to fly.', 'extrabunny': '- equivalent of the CJPHONEHOME or JHJOECW cheat, and allows you to bunny hop on bicycles much higher.', 'extrajump': '- equivalent of the KANGAROO cheat, and allows you to jump on foot much higher.', 'randomfoliage': '- toggle randomly generated foliage on the GTA:SA map (default: true) https://wiki.multitheftauto.com/wiki/File:Randomfoliage.jpeg Image', 'snipermoon': '- toggle the GTA:SA easter egg, which increases the size of the moon every time you shoot it with a sniper rifle (default: false)', 'extraairresistance': "- toggle the vehicle speed limit on cross-country roads (default: true)\n**{{New feature/item|3.0156|1.5.5|12286|'''underworldwarp''' - toggle warp of peds and vehicles when fall under map (default: true)}}", 'enable': 'whether or not to enable the property.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/SetWorldSpecialPropertyEnabled', name='setWorldSpecialPropertyEnabled', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='setColorFilter', return_types=['bool'], arguments=[FunctionArgument(name='aRed', argument_type='int', default_value=None, optional=False), FunctionArgument(name='aGreen', argument_type='int', default_value=None, optional=False), FunctionArgument(name='aBlue', argument_type='int', default_value=None, optional=False), FunctionArgument(name='aAlpha', argument_type='int', default_value=None, optional=False), FunctionArgument(name='bRed', argument_type='int', default_value=None, optional=False), FunctionArgument(name='bGreen', argument_type='int', default_value=None, optional=False), FunctionArgument(name='bBlue', argument_type='int', default_value=None, optional=False), FunctionArgument(name='bAlpha', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'aRed': 'The amount of red (0-255).', 'aGreen': 'The amount of green (0-255).', 'aBlue': 'The amount of blue (0-255).', 'aAlpha': 'The amount of alpha (0-255).', 'bRed': 'The amount of red (0-255).', 'bGreen': 'The amount of green (0-255).', 'bBlue': 'The amount of blue (0-255).', 'bAlpha': 'The amount of alpha (0-255).'}, result='Returns true if the color filter was set, false otherwise.'), oop=None, url=FunctionUrl(url='/wiki/SetColorFilter', name='setColorFilter', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=None, client=FunctionData(signature=FunctionType(name='testLineAgainstWater', return_types=['bool', 'float', 'float', 'float'], arguments=[FunctionArgument(name='startX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='startZ', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endX', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endY', argument_type='float', default_value=None, optional=False), FunctionArgument(name='endZ', argument_type='float', default_value=None, optional=False)]), docs=FunctionDoc(description='This function checks to see if a line between two points collides with the water. This is similar to [[processLineOfSight]], but only collides with water. Waves are taken into account when testing the line.', arguments={'startX, startY, startZ': 'the position of the starting point of the line.', 'endX, endY, endZ': 'the position of the end point of the line.'}, result="Returns ''true'' and the position of the intersection point of the line and the water surface if there is a collision, or ''false'' if there is no collision."), oop=None, url=FunctionUrl(url='/wiki/TestLineAgainstWater', name='testLineAgainstWater', category='World functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlCopyFile', return_types=['xmlnode'], arguments=[FunctionArgument(name='nodeToCopy', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='newFilePath', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function copies all contents of a certain node in a XML document to a new document file, so the copied node becomes the new file's root node.\nThe new file will not be saved to file system until [[xmlSaveFile]]() is called", arguments={'nodeToCopy': 'the xmlnode that is to be copied to a new document.', 'newFilePath': 'the path of the file that is to be created, in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file.\n:For example, to create a file named \'newfile.xml\' with myNode as the root node in the resource \'ctf\', it can be done from another resource this way: \'\'xmlCopyFile(myNode, ":ctf/newfile.xml")\'\'.\n:If the file is to be in the current resource, only the file path is necessary, e.g. \'\'xmlCopyFile(myNode, "newfile.xml")\'\'.'}, result="Returns the [[xmlnode]] of the copy if the node was successfully copied, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='xmlnode', method_name='copy', field=None), url=FunctionUrl(url='/wiki/XmlCopyFile', name='xmlCopyFile', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlCopyFile', return_types=['xmlnode'], arguments=[FunctionArgument(name='nodeToCopy', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='newFilePath', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description="This function copies all contents of a certain node in a XML document to a new document file, so the copied node becomes the new file's root node.\nThe new file will not be saved to file system until [[xmlSaveFile]]() is called", arguments={'nodeToCopy': 'the xmlnode that is to be copied to a new document.', 'newFilePath': 'the path of the file that is to be created, in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file.\n:For example, to create a file named \'newfile.xml\' with myNode as the root node in the resource \'ctf\', it can be done from another resource this way: \'\'xmlCopyFile(myNode, ":ctf/newfile.xml")\'\'.\n:If the file is to be in the current resource, only the file path is necessary, e.g. \'\'xmlCopyFile(myNode, "newfile.xml")\'\'.'}, result="Returns the [[xmlnode]] of the copy if the node was successfully copied, ''false'' if invalid arguments were passed."), oop=FunctionOOP(class_name='xmlnode', method_name='copy', field=None), url=FunctionUrl(url='/wiki/XmlCopyFile', name='xmlCopyFile', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlCreateChild', return_types=['xmlnode'], arguments=[FunctionArgument(name='parentNode', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='tagName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function creates a new child node under an XML node.', arguments={'parentNode': 'the xmlnode you want to create a new child node under.', 'tagName': 'the type of the child node that will be created.'}, result="Returns the created [[xmlnode]] if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/XmlCreateChild', name='xmlCreateChild', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlCreateChild', return_types=['xmlnode'], arguments=[FunctionArgument(name='parentNode', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='tagName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function creates a new child node under an XML node.', arguments={'parentNode': 'the xmlnode you want to create a new child node under.', 'tagName': 'the type of the child node that will be created.'}, result="Returns the created [[xmlnode]] if successful, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/XmlCreateChild', name='xmlCreateChild', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlCreateFile', return_types=['xmlnode'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='rootNodeName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function creates a new XML document, which can later be saved to a file by using [[xmlSaveFile]]. This function will overwrite the file specified if it already exists.', arguments={'filePath': 'The filepath of the file in the following format: :resourceName/path. resourceName is the name of the resource the file will be in, and path is the path from the root directory of the resource to the file.\n:For example, if you want to create a file named \'new.xml\' in the resource \'ctf\', it can be created from another resource this way: \'\'xmlCreateFile(":ctf/new.xml", "newroot")\'\'.\n:If the file is in the current resource, only the file path is necessary, e.g. \'\'xmlCreateFile("new.xml", "newroot")\'\'.\n:Note that if a different resource than default is being accessed, the caller resource needs access to general.ModifyOtherObjects in the [[ACL]].', 'rootNodeName': 'the name of the root node in the XML document.'}, result="Returns the root [[xmlnode]] object of the new XML file if successful, or ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/XmlCreateFile', name='xmlCreateFile', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlCreateFile', return_types=['xmlnode'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='rootNodeName', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function creates a new XML document, which can later be saved to a file by using [[xmlSaveFile]]. This function will overwrite the file specified if it already exists.', arguments={'filePath': 'The filepath of the file in the following format: :resourceName/path. resourceName is the name of the resource the file will be in, and path is the path from the root directory of the resource to the file.\n:For example, if you want to create a file named \'new.xml\' in the resource \'ctf\', it can be created from another resource this way: \'\'xmlCreateFile(":ctf/new.xml", "newroot")\'\'.\n:If the file is in the current resource, only the file path is necessary, e.g. \'\'xmlCreateFile("new.xml", "newroot")\'\'.\n:Note that if a different resource than default is being accessed, the caller resource needs access to general.ModifyOtherObjects in the [[ACL]].', 'rootNodeName': 'the name of the root node in the XML document.'}, result="Returns the root [[xmlnode]] object of the new XML file if successful, or ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/XmlCreateFile', name='xmlCreateFile', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlDestroyNode', return_types=['bool'], arguments=[FunctionArgument(name='theXMLNode', argument_type='xmlnode', default_value=None, optional=False)]), docs=FunctionDoc(description='This function destroys a XML node from the XML node tree.', arguments={'theXMLNode': 'The xml node you want to destroy.'}, result="Returns ''true'' if the [[xml node]] was successfully destroyed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/XmlDestroyNode', name='xmlDestroyNode', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlDestroyNode', return_types=['bool'], arguments=[FunctionArgument(name='theXMLNode', argument_type='xmlnode', default_value=None, optional=False)]), docs=FunctionDoc(description='This function destroys a XML node from the XML node tree.', arguments={'theXMLNode': 'The xml node you want to destroy.'}, result="Returns ''true'' if the [[xml node]] was successfully destroyed, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/XmlDestroyNode', name='xmlDestroyNode', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlFindChild', return_types=['xmlnode'], arguments=[FunctionArgument(name='parent', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='tagName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a named child node of an XML node.', arguments={'parent': ': This is an xmlnode that you want to find the child node under.', 'tagName': ': This is the name of the child node you wish to find (case-sensitive).', 'index': ': This is the 0-based index of the node you wish to find. For example, to find the 5th subnode with a particular name, you would use 4 as the index value. To find the first occurence, use 0.'}, result="Returns an [[xmlnode]] if the node was found, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/XmlFindChild', name='xmlFindChild', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlFindChild', return_types=['xmlnode'], arguments=[FunctionArgument(name='parent', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='tagName', argument_type='string', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns a named child node of an XML node.', arguments={'parent': ': This is an xmlnode that you want to find the child node under.', 'tagName': ': This is the name of the child node you wish to find (case-sensitive).', 'index': ': This is the 0-based index of the node you wish to find. For example, to find the 5th subnode with a particular name, you would use 4 as the index value. To find the first occurence, use 0.'}, result="Returns an [[xmlnode]] if the node was found, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/XmlFindChild', name='xmlFindChild', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlLoadFile', return_types=['xmlnode'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='readOnly', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function provides an alternative way to load XML files to [[getResourceConfig]].\nThis function loads an XML file and returns the node by specifying a specific file path, while [[getResourceConfig]] allows for loading an XML file from a resource.', arguments={'filePath': 'The filepath of the file in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file.\n:For example, if there is a file named \'settings.xml\' in the resource \'ctf\', it can be accessed from another resource this way: \'\'xmlLoadFile(":ctf/settings.xml")\'\'.\n:If the file is in the current resource, only the file path is necessary, e.g. \'\'xmlLoadFile("settings.xml")\'\'.', 'readOnly': 'By default, the XML file is opened with reading and writing access. You can specify true for this parameter if you only need reading access.'}, result="Returns the root [[xmlnode]] object of an xml file if successful, or ''false'' otherwise.\n{{New items|3.0152|1.5|\nPrint error if something wrong with xml.\n|7485}}"), oop=FunctionOOP(class_name='XML', method_name='load', field=None), url=FunctionUrl(url='/wiki/XmlLoadFile', name='xmlLoadFile', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlLoadFile', return_types=['xmlnode'], arguments=[FunctionArgument(name='filePath', argument_type='string', default_value=None, optional=False), FunctionArgument(name='readOnly', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function provides an alternative way to load XML files to [[getResourceConfig]].\nThis function loads an XML file and returns the node by specifying a specific file path, while [[getResourceConfig]] allows for loading an XML file from a resource.', arguments={'filePath': 'The filepath of the file in the following format: :resourceName/path. resourceName is the name of the resource the file is in, and path is the path from the root directory of the resource to the file.\n:For example, if there is a file named \'settings.xml\' in the resource \'ctf\', it can be accessed from another resource this way: \'\'xmlLoadFile(":ctf/settings.xml")\'\'.\n:If the file is in the current resource, only the file path is necessary, e.g. \'\'xmlLoadFile("settings.xml")\'\'.', 'readOnly': 'By default, the XML file is opened with reading and writing access. You can specify true for this parameter if you only need reading access.'}, result="Returns the root [[xmlnode]] object of an xml file if successful, or ''false'' otherwise.\n{{New items|3.0152|1.5|\nPrint error if something wrong with xml.\n|7485}}"), oop=FunctionOOP(class_name='XML', method_name='load', field=None), url=FunctionUrl(url='/wiki/XmlLoadFile', name='xmlLoadFile', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlLoadString', return_types=['xmlnode'], arguments=[FunctionArgument(name='xmlString', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'xmlString': 'A string containing XML data'}, result="Returns the root [[xmlnode]] object of an xml string if successful, or ''false'' otherwise (invalid XML string)."), oop=FunctionOOP(class_name='XML', method_name='loadstring', field=None), url=FunctionUrl(url='/wiki/XmlLoadString', name='xmlLoadString', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlLoadString', return_types=['xmlnode'], arguments=[FunctionArgument(name='xmlString', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='', arguments={'xmlString': 'A string containing XML data'}, result="Returns the root [[xmlnode]] object of an xml string if successful, or ''false'' otherwise (invalid XML string)."), oop=FunctionOOP(class_name='XML', method_name='loadstring', field=None), url=FunctionUrl(url='/wiki/XmlLoadString', name='xmlLoadString', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlNodeGetAttribute', return_types=['string'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='name', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to return an attribute of a node in a configuration file.', arguments={'node': 'The node from which you wish to return the attribute', 'name': 'The name of the attribute.'}, result="Returns the attribute in string form or ''false'', if the attribute is not defined."), oop=FunctionOOP(class_name='xmlnode', method_name='getAttribute', field=None), url=FunctionUrl(url='/wiki/XmlNodeGetAttribute', name='xmlNodeGetAttribute', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlNodeGetAttribute', return_types=['string'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='name', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to return an attribute of a node in a configuration file.', arguments={'node': 'The node from which you wish to return the attribute', 'name': 'The name of the attribute.'}, result="Returns the attribute in string form or ''false'', if the attribute is not defined."), oop=FunctionOOP(class_name='xmlnode', method_name='getAttribute', field=None), url=FunctionUrl(url='/wiki/XmlNodeGetAttribute', name='xmlNodeGetAttribute', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlNodeGetAttributes', return_types=['table'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns all the attributes of a specific XML node.', arguments={'node': 'the XML node to get the attributes of.'}, result="If successful, returns a table with as keys the names of the attributes and as values the corresponding attribute values. If the node has no attributes, returns an empty table. In case of failure, returns ''false''."), oop=FunctionOOP(class_name='xmlnode', method_name='getAttributes', field="attributes}}\n===Required Arguments===\n*'''node:''' the XML node to get the attributes of.\n\n===Returns===\nIf successful, returns a table with as keys the names of the attributes and as values the corresponding attribute values. If the node has no attributes, returns an empty table. In case of failure, returns ''false''.\n\n"), url=FunctionUrl(url='/wiki/XmlNodeGetAttributes', name='xmlNodeGetAttributes', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlNodeGetAttributes', return_types=['table'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns all the attributes of a specific XML node.', arguments={'node': 'the XML node to get the attributes of.'}, result="If successful, returns a table with as keys the names of the attributes and as values the corresponding attribute values. If the node has no attributes, returns an empty table. In case of failure, returns ''false''."), oop=FunctionOOP(class_name='xmlnode', method_name='getAttributes', field="attributes}}\n===Required Arguments===\n*'''node:''' the XML node to get the attributes of.\n\n===Returns===\nIf successful, returns a table with as keys the names of the attributes and as values the corresponding attribute values. If the node has no attributes, returns an empty table. In case of failure, returns ''false''.\n\n"), url=FunctionUrl(url='/wiki/XmlNodeGetAttributes', name='xmlNodeGetAttributes', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlNodeGetChildren', return_types=['table/xmlnode'], arguments=[FunctionArgument(name='parent', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns all children of a particular XML node, or a particular child node.', arguments={'parent': 'This is the xmlnode you want to retrieve one or all child nodes of.', 'index': 'If you only want to retrieve one particular child node, specify its (0-based) index here. For example if you only want the first node, specify 0; the fifth node has index 4, etc.'}, result="If '''index''' isn't specified, returns a table containing all child nodes. If '''index''' is specified, returns the corresponding child node if it exists. If no nodes are found, it returns an empty table. Returns ''false'' in case of failure."), oop=FunctionOOP(class_name='xmlnode', method_name='getChildren', field="children}}\n\n===Required Arguments===\n* '''parent:''' This is the [[xmlnode]] you want to retrieve one or all child nodes of. \n\n===Optional Arguments=== \n* '''index:''' If you only want to retrieve one particular child node, specify its (0-based) index here. For example if you only want the first node, specify 0; the fifth node has index 4, etc.\n\n===Returns===\nIf '''index''' isn't specified, returns a table containing all child nodes. If '''index''' is specified, returns the corresponding child node if it exists. If no nodes are found, it returns an empty table. Returns ''false'' in case of failure.\n\n"), url=FunctionUrl(url='/wiki/XmlNodeGetChildren', name='xmlNodeGetChildren', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlNodeGetChildren', return_types=['table/xmlnode'], arguments=[FunctionArgument(name='parent', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='index', argument_type='int', default_value=None, optional=False)]), docs=FunctionDoc(description='This function returns all children of a particular XML node, or a particular child node.', arguments={'parent': 'This is the xmlnode you want to retrieve one or all child nodes of.', 'index': 'If you only want to retrieve one particular child node, specify its (0-based) index here. For example if you only want the first node, specify 0; the fifth node has index 4, etc.'}, result="If '''index''' isn't specified, returns a table containing all child nodes. If '''index''' is specified, returns the corresponding child node if it exists. If no nodes are found, it returns an empty table. Returns ''false'' in case of failure."), oop=FunctionOOP(class_name='xmlnode', method_name='getChildren', field="children}}\n\n===Required Arguments===\n* '''parent:''' This is the [[xmlnode]] you want to retrieve one or all child nodes of. \n\n===Optional Arguments=== \n* '''index:''' If you only want to retrieve one particular child node, specify its (0-based) index here. For example if you only want the first node, specify 0; the fifth node has index 4, etc.\n\n===Returns===\nIf '''index''' isn't specified, returns a table containing all child nodes. If '''index''' is specified, returns the corresponding child node if it exists. If no nodes are found, it returns an empty table. Returns ''false'' in case of failure.\n\n"), url=FunctionUrl(url='/wiki/XmlNodeGetChildren', name='xmlNodeGetChildren', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlNodeGetName', return_types=['string'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the tag name of the specified XML node.', arguments={'node': 'the node to get the tag name of.'}, result="Returns the tag name of the node if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='xmlnode', method_name='getName', field='name'), url=FunctionUrl(url='/wiki/XmlNodeGetName', name='xmlNodeGetName', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlNodeGetName', return_types=['string'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False)]), docs=FunctionDoc(description='Gets the tag name of the specified XML node.', arguments={'node': 'the node to get the tag name of.'}, result="Returns the tag name of the node if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='xmlnode', method_name='getName', field='name'), url=FunctionUrl(url='/wiki/XmlNodeGetName', name='xmlNodeGetName', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlNodeGetParent', return_types=['xmlnode'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the parent node of an xml node.', arguments={'node': 'the node of which you want to know the parent.'}, result="Returns the parent node of the specified node if successful. Returns ''false'' if the specified node is the root node or an invalid node was passed."), oop=FunctionOOP(class_name='xmlnode', method_name='getParent', field="parent}}\n\n===Required Arguments===\n*'''node:''' the node of which you want to know the parent.\n\n===Returns===\nReturns the parent node of the specified node if successful. Returns ''false'' if the specified node is the root node or an invalid node was passed.\n\n"), url=FunctionUrl(url='/wiki/XmlNodeGetParent', name='xmlNodeGetParent', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlNodeGetParent', return_types=['xmlnode'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False)]), docs=FunctionDoc(description='Returns the parent node of an xml node.', arguments={'node': 'the node of which you want to know the parent.'}, result="Returns the parent node of the specified node if successful. Returns ''false'' if the specified node is the root node or an invalid node was passed."), oop=FunctionOOP(class_name='xmlnode', method_name='getParent', field="parent}}\n\n===Required Arguments===\n*'''node:''' the node of which you want to know the parent.\n\n===Returns===\nReturns the parent node of the specified node if successful. Returns ''false'' if the specified node is the root node or an invalid node was passed.\n\n"), url=FunctionUrl(url='/wiki/XmlNodeGetParent', name='xmlNodeGetParent', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlNodeGetValue', return_types=['string'], arguments=[FunctionArgument(name='theXMLNode', argument_type='xmlnode', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is made to be able to read tag values in XML files (eg. <something>anything</something>).', arguments={'theXMLNode': 'The xml node of which you need to know the value.'}, result="Returns the value of the node as a [[string]] if it was received successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='xmlnode', method_name='getValue', field='value'), url=FunctionUrl(url='/wiki/XmlNodeGetValue', name='xmlNodeGetValue', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlNodeGetValue', return_types=['string'], arguments=[FunctionArgument(name='theXMLNode', argument_type='xmlnode', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is made to be able to read tag values in XML files (eg. <something>anything</something>).', arguments={'theXMLNode': 'The xml node of which you need to know the value.'}, result="Returns the value of the node as a [[string]] if it was received successfully, ''false'' otherwise."), oop=FunctionOOP(class_name='xmlnode', method_name='getValue', field='value'), url=FunctionUrl(url='/wiki/XmlNodeGetValue', name='xmlNodeGetValue', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlNodeSetAttribute', return_types=['bool'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='name', argument_type='string', default_value=None, optional=False), FunctionArgument(name='float', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to edit an attribute of a node in a configuration file.', arguments={'node': 'The node of which you wish to edit an attribute.', 'name': 'The name of the attribute.', 'value': 'The value which you wish to change the attribute to. (Note: nil will delete the attribute)'}, result="Returns ''true'' if the attribute was set successfully, ''false'' if the node and/or attribute do not exist, or if they're faulty."), oop=FunctionOOP(class_name='xmlnode', method_name='setAttribute', field=None), url=FunctionUrl(url='/wiki/XmlNodeSetAttribute', name='xmlNodeSetAttribute', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlNodeSetAttribute', return_types=['bool'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='name', argument_type='string', default_value=None, optional=False), FunctionArgument(name='float', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='This function is used to edit an attribute of a node in a configuration file.', arguments={'node': 'The node of which you wish to edit an attribute.', 'name': 'The name of the attribute.', 'value': 'The value which you wish to change the attribute to. (Note: nil will delete the attribute)'}, result="Returns ''true'' if the attribute was set successfully, ''false'' if the node and/or attribute do not exist, or if they're faulty."), oop=FunctionOOP(class_name='xmlnode', method_name='setAttribute', field=None), url=FunctionUrl(url='/wiki/XmlNodeSetAttribute', name='xmlNodeSetAttribute', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlNodeSetName', return_types=['bool'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='name', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the tag name of the specified XML node.', arguments={'node': 'the node to change the tag name of.', 'name': 'the new tag name to set.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='xmlnode', method_name='setName', field='name'), url=FunctionUrl(url='/wiki/XmlNodeSetName', name='xmlNodeSetName', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlNodeSetName', return_types=['bool'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='name', argument_type='string', default_value=None, optional=False)]), docs=FunctionDoc(description='Sets the tag name of the specified XML node.', arguments={'node': 'the node to change the tag name of.', 'name': 'the new tag name to set.'}, result="Returns ''true'' if successful, ''false'' otherwise."), oop=FunctionOOP(class_name='xmlnode', method_name='setName', field='name'), url=FunctionUrl(url='/wiki/XmlNodeSetName', name='xmlNodeSetName', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlNodeSetValue', return_types=['bool'], arguments=[FunctionArgument(name='theXMLNode', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='value', argument_type='string', default_value=None, optional=False), FunctionArgument(name='setCDATA', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function is made to be able to assign values to tags in XML files (eg. <something>anything</something>).', arguments={'theXMLNode': 'The xml node you want to set the value of.', 'value': 'The string value you want the node to have.\n{{New feature/item|4.0140|1.4.0|6782|', 'setCDATA': 'A boolean indicating if you want the value to be enclosed inside CDATA tags.\n}}'}, result="Returns ''true'' if value was successfully set, ''false'' otherwise."), oop=FunctionOOP(class_name='xmlnode', method_name='setValue', field='value'), url=FunctionUrl(url='/wiki/XmlNodeSetValue', name='xmlNodeSetValue', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlNodeSetValue', return_types=['bool'], arguments=[FunctionArgument(name='theXMLNode', argument_type='xmlnode', default_value=None, optional=False), FunctionArgument(name='value', argument_type='string', default_value=None, optional=False), FunctionArgument(name='setCDATA', argument_type='bool', default_value='false', optional=True)]), docs=FunctionDoc(description='This function is made to be able to assign values to tags in XML files (eg. <something>anything</something>).', arguments={'theXMLNode': 'The xml node you want to set the value of.', 'value': 'The string value you want the node to have.\n{{New feature/item|4.0140|1.4.0|6782|', 'setCDATA': 'A boolean indicating if you want the value to be enclosed inside CDATA tags.\n}}'}, result="Returns ''true'' if value was successfully set, ''false'' otherwise."), oop=FunctionOOP(class_name='xmlnode', method_name='setValue', field='value'), url=FunctionUrl(url='/wiki/XmlNodeSetValue', name='xmlNodeSetValue', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlSaveFile', return_types=['bool'], arguments=[FunctionArgument(name='rootNode', argument_type='xmlnode', default_value=None, optional=False)]), docs=FunctionDoc(description='This function saves a loaded XML file.', arguments={'rootNode': 'the root xmlnode of the loaded XML file.'}, result="Returns ''true'' if save was successful, ''false'' if the XML file does not exist."), oop=None, url=FunctionUrl(url='/wiki/XmlSaveFile', name='xmlSaveFile', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlSaveFile', return_types=['bool'], arguments=[FunctionArgument(name='rootNode', argument_type='xmlnode', default_value=None, optional=False)]), docs=FunctionDoc(description='This function saves a loaded XML file.', arguments={'rootNode': 'the root xmlnode of the loaded XML file.'}, result="Returns ''true'' if save was successful, ''false'' if the XML file does not exist."), oop=None, url=FunctionUrl(url='/wiki/XmlSaveFile', name='xmlSaveFile', category='XML functions', function_type=ListType.CLIENT)))
CompoundFunctionData(server=FunctionData(signature=FunctionType(name='xmlUnloadFile', return_types=['bool'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False)]), docs=FunctionDoc(description='Unloads an XML document from memory.', arguments={'node': 'root of the XML document to unload'}, result="Returns ''true'' if the document was unloaded successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/XmlUnloadFile', name='xmlUnloadFile', category='XML functions', function_type=ListType.CLIENT)), client=FunctionData(signature=FunctionType(name='xmlUnloadFile', return_types=['bool'], arguments=[FunctionArgument(name='node', argument_type='xmlnode', default_value=None, optional=False)]), docs=FunctionDoc(description='Unloads an XML document from memory.', arguments={'node': 'root of the XML document to unload'}, result="Returns ''true'' if the document was unloaded successfully, ''false'' otherwise."), oop=None, url=FunctionUrl(url='/wiki/XmlUnloadFile', name='xmlUnloadFile', category='XML functions', function_type=ListType.CLIENT)))
